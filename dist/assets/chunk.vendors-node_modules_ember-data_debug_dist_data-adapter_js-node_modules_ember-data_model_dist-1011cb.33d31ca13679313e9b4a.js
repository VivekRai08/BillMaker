"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunk_ember_auto_import_"] = globalThis["webpackChunk_ember_auto_import_"] || []).push([["vendors-node_modules_ember-data_debug_dist_data-adapter_js-node_modules_ember-data_model_dist-1011cb"],{

/***/ "./node_modules/@ember-data/debug/dist/data-adapter.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ember-data/debug/dist/data-adapter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Exported)\n/* harmony export */ });\n/* harmony import */ var _ember_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/array */ \"@ember/array\");\n/* harmony import */ var _ember_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ember_debug_data_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/debug/data-adapter */ \"@ember/debug/data-adapter\");\n/* harmony import */ var _ember_debug_data_adapter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_debug_data_adapter__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ember_object_observers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember/object/observers */ \"@ember/object/observers\");\n/* harmony import */ var _ember_object_observers__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ember_object_observers__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _ember_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ember/service */ \"@ember/service\");\n/* harmony import */ var _ember_service__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_ember_service__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ember-data/request-utils/string */ \"./node_modules/@ember-data/request-utils/dist/string.js\");\n/* harmony import */ var _ember_data_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ember-data/store */ \"./node_modules/@ember-data/store/dist/index.js\");\nvar _InspectorDataAdapter;function _classPrivateFieldInitSpec(e,t,a){_checkPrivateRedeclaration(e,t),t.set(e,a);}function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError(\"Cannot initialize the same private elements twice on an object\");}const deferred=/* @__PURE__ */new WeakMap();function deferDecorator(proto,prop,desc){let map=deferred.get(proto);if(!map){map=/* @__PURE__ */new Map();deferred.set(proto,map);}map.set(prop,desc);}function findDeferredDecorator(target,prop){var _a;let cursor=target.prototype;while(cursor){let desc=(_a=deferred.get(cursor))==null?void 0:_a.get(prop);if(desc){return desc;}cursor=cursor.prototype;}}function decorateFieldV2(prototype,prop,decorators,initializer){let desc={configurable:true,enumerable:true,writable:true,initializer:null};if(initializer){desc.initializer=initializer;}for(let decorator of decorators){desc=decorator(prototype,prop,desc)||desc;}if(desc.initializer===void 0){Object.defineProperty(prototype,prop,desc);}else{deferDecorator(prototype,prop,desc);}}function initializeDeferredDecorator(target,prop){let desc=findDeferredDecorator(target.constructor,prop);if(desc){Object.defineProperty(target,prop,{enumerable:desc.enumerable,configurable:desc.configurable,writable:desc.writable,value:desc.initializer?desc.initializer.call(target):void 0});}}const service=_ember_service__WEBPACK_IMPORTED_MODULE_3__.service??_ember_service__WEBPACK_IMPORTED_MODULE_3__.inject;const StoreTypesMap=new WeakMap();function debugInfo(){const relationships={};const expensiveProperties=[];const identifier=(0,_ember_data_store__WEBPACK_IMPORTED_MODULE_5__.recordIdentifierFor)(this);const fields=this.store.schema.fields(identifier);const attrGroup={name:'Attributes',properties:['id'],expand:true};const attributes=attrGroup.properties;const groups=[attrGroup];for(const field of fields.values()){switch(field.kind){case'attribute':attributes.push(field.name);break;case'belongsTo':case'hasMany':{let properties=relationships[field.kind];if(properties===undefined){properties=relationships[field.kind]=[];groups.push({name:field.kind,properties,expand:true});}properties.push(field.name);expensiveProperties.push(field.name);break;}}}groups.push({name:'Flags',properties:['isLoaded','hasDirtyAttributes','isSaving','isDeleted','isError','isNew','isValid'],expand:false});return{propertyInfo:{// include all other mixins / properties (not just the grouped ones)\nincludeOtherProperties:true,groups:groups,// don't pre-calculate unless cached\nexpensiveProperties:expensiveProperties}};}function installDebugInfo(ModelKlass){/**\n   Provides info about the model for debugging purposes\n   by grouping the properties into more semantic groups.\n    Meant to be used by debugging tools such as the Chrome Ember Extension.\n    - Groups all attributes in \"Attributes\" group.\n   - Groups all belongsTo relationships in \"Belongs To\" group.\n   - Groups all hasMany relationships in \"Has Many\" group.\n   - Groups all flags in \"Flags\" group.\n   - Flags relationship CPs as expensive properties.\n    @internal\n   */ModelKlass.prototype._debugInfo=debugInfo;}function typesMapFor(store){let typesMap=StoreTypesMap.get(store);if(typesMap===undefined){typesMap=new Map();StoreTypesMap.set(store,typesMap);}return typesMap;}/**\n  Implements `@ember/debug/data-adapter` with for EmberData\n  integration with the ember-inspector.\n\n  @private\n*/var _store=/*#__PURE__*/new WeakMap();class InspectorDataAdapter extends (_ember_debug_data_adapter__WEBPACK_IMPORTED_MODULE_1___default()){constructor(...args){super(...args);_classPrivateFieldInitSpec(this,_store,(initializeDeferredDecorator(this,\"store\"),void 0));}/**\n    Specifies how records can be filtered based on the state of the record\n    Records returned will need to have a `filterValues`\n    property with a key for every name in the returned array\n     @private\n    @return List of objects defining filters\n     The object should have a `name` and `desc` property\n  */getFilters(){return[{name:'isNew',desc:'New'},{name:'isModified',desc:'Modified'},{name:'isClean',desc:'Clean'}];}_nameToClass(type){return this.store.modelFor(type);}/**\n    Fetch the model types and observe them for changes.\n    Maintains the list of model types without needing the Model package for detection.\n     @private\n    @param typesAdded Callback to call to add types.\n    Takes an array of objects containing wrapped types (returned from `wrapModelType`).\n    @param typesUpdated Callback to call when a type has changed.\n    Takes an array of objects containing wrapped types.\n    @return Method to call to remove all observers\n  */watchModelTypes(typesAdded,typesUpdated){const{store}=this;const discoveredTypes=typesMapFor(store);const unsub=store.notifications.subscribe('resource',(identifier,notificationType)=>{if(notificationType==='added'){this.watchTypeIfUnseen(store,discoveredTypes,identifier.type,typesAdded,typesUpdated,_releaseMethods);}});const _releaseMethods=[()=>{store.notifications.unsubscribe(unsub);}];Object.keys(store.identifierCache._cache.resourcesByType).forEach(type=>{discoveredTypes.set(type,false);});// Add any models that were added during initialization of the app, before the inspector was opened\ndiscoveredTypes.forEach((_,type)=>{this.watchTypeIfUnseen(store,discoveredTypes,type,typesAdded,typesUpdated,_releaseMethods);});const release=()=>{_releaseMethods.forEach(fn=>fn());// reset the list so the models can be added if the inspector is re-opened\n// the entries are set to false instead of removed, since the models still exist in the app\n// we just need the inspector to become aware of them\ndiscoveredTypes.forEach((value,key)=>{discoveredTypes.set(key,false);});this.releaseMethods.removeObject(release);};this.releaseMethods.pushObject(release);return release;}/**\n   * Loop over the discovered types and use the callbacks from watchModelTypes to notify\n   * the consumer of this adapter about the mdoels.\n   *\n   * @private\n   */watchTypeIfUnseen(store,discoveredTypes,type,typesAdded,typesUpdated,releaseMethods){if(discoveredTypes.get(type)!==true){const klass=store.modelFor(type);installDebugInfo(klass);const wrapped=this.wrapModelType(klass,type);releaseMethods.push(this.observeModelType(type,typesUpdated));typesAdded([wrapped]);discoveredTypes.set(type,true);}}/**\n    Creates a human readable string used for column headers\n     @private\n    @param name The attribute name\n    @return Human readable string based on the attribute name\n  */columnNameToDesc(name){return (0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_4__.capitalize)((0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_4__.underscore)(name).replace(/_/g,' ').trim());}/**\n    Get the columns for a given model type\n     @private\n    @return An array of columns of the following format:\n     name: {String} The name of the column\n     desc: {String} Humanized description (what would show in a table column name)\n  */columnsForType(typeClass){const columns=[{name:'id',desc:'Id'}];let count=0;typeClass.attributes.forEach((meta,name)=>{if(count++>this.attributeLimit){return false;}const desc=this.columnNameToDesc(name);columns.push({name:name,desc:desc});});return columns;}/**\n    Fetches all loaded records for a given type\n     @private\n    @param modelClass of the record\n    @param modelName of the record\n    @return An array of Model records\n     This array will be observed for changes,\n     so it should update when new records are added/removed\n  */getRecords(modelClass,modelName){if(arguments.length<2){// Legacy Ember.js < 1.13 support\nconst containerKey=modelClass._debugContainerKey;if(containerKey){const match=containerKey.match(/model:(.*)/);if(match!==null){modelName=match[1];}}}(test=>{if(!test){throw new Error('Cannot find model name. Please upgrade to Ember.js >= 1.13 for Ember Inspector support');}})(!!modelName);return this.store.peekAll(modelName);}/**\n    Gets the values for each column\n    This is the attribute values for a given record\n     @private\n    @param record to get values from\n    @return Keys should match column names defined by the model type\n  */getRecordColumnValues(record){let count=0;const columnValues={id:record.id};record.eachAttribute(key=>{if(count++>this.attributeLimit){return false;}columnValues[key]=record[key];});return columnValues;}/**\n    Returns keywords to match when searching records\n     @private\n    @return Relevant keywords for search based on the record's attribute values\n  */getRecordKeywords(record){const keywords=[record.id];record.eachAttribute(key=>{keywords.push(record[key]);});return (0,_ember_array__WEBPACK_IMPORTED_MODULE_0__.A)(keywords);}/**\n    Returns the values of filters defined by `getFilters`\n    These reflect the state of the record\n     @private\n    @return The record state filter values\n  */getRecordFilterValues(record){return{isNew:record.isNew,isModified:record.hasDirtyAttributes&&!record.isNew,isClean:!record.hasDirtyAttributes};}/**\n    Returns a color that represents the record's state\n    Possible colors: black, blue, green\n     @private\n    @return The record color\n  */getRecordColor(record){let color='black';if(record.isNew){color='green';}else if(record.hasDirtyAttributes){color='blue';}return color;}/**\n    Observes all relevant properties and re-sends the wrapped record\n    when a change occurs\n     @private\n    @param record\n    @param recordUpdated Callback used to notify changes\n    @return The function to call to remove all observers\n  */observeRecord(record,recordUpdated){const releaseMethods=[];const keysToObserve=['id','isNew','hasDirtyAttributes'];record.eachAttribute(key=>keysToObserve.push(key));keysToObserve.forEach(key=>{const handler=()=>{recordUpdated(this.wrapRecord(record));};(0,_ember_object_observers__WEBPACK_IMPORTED_MODULE_2__.addObserver)(record,key,handler);releaseMethods.push(function(){(0,_ember_object_observers__WEBPACK_IMPORTED_MODULE_2__.removeObserver)(record,key,handler);});});const release=function(){releaseMethods.forEach(fn=>fn());};return release;}}_InspectorDataAdapter=InspectorDataAdapter;decorateFieldV2(_InspectorDataAdapter.prototype,\"store\",[service('store')]);const Exported=InspectorDataAdapter;\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/debug/dist/data-adapter.js?\n}");

/***/ }),

/***/ "./node_modules/@ember-data/model/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@ember-data/model/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   attr: () => (/* reexport safe */ _warp_drive_legacy_model__WEBPACK_IMPORTED_MODULE_0__.attr),\n/* harmony export */   belongsTo: () => (/* reexport safe */ _warp_drive_legacy_model__WEBPACK_IMPORTED_MODULE_0__.belongsTo),\n/* harmony export */   buildSchema: () => (/* reexport safe */ _warp_drive_legacy_model__WEBPACK_IMPORTED_MODULE_0__.buildSchema),\n/* harmony export */   \"default\": () => (/* reexport safe */ _warp_drive_legacy_model__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   hasMany: () => (/* reexport safe */ _warp_drive_legacy_model__WEBPACK_IMPORTED_MODULE_0__.hasMany),\n/* harmony export */   instantiateRecord: () => (/* reexport safe */ _warp_drive_legacy_model__WEBPACK_IMPORTED_MODULE_0__.instantiateRecord),\n/* harmony export */   modelFor: () => (/* reexport safe */ _warp_drive_legacy_model__WEBPACK_IMPORTED_MODULE_0__.modelFor),\n/* harmony export */   teardownRecord: () => (/* reexport safe */ _warp_drive_legacy_model__WEBPACK_IMPORTED_MODULE_0__.teardownRecord)\n/* harmony export */ });\n/* harmony import */ var _warp_drive_legacy_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @warp-drive/legacy/model */ \"./node_modules/@warp-drive/legacy/dist/model.js\");\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/model/dist/index.js?\n}");

/***/ }),

/***/ "./node_modules/@ember-data/request-utils/dist/deprecation-support.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ember-data/request-utils/dist/deprecation-support.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _warp_drive_utilities_private__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @warp-drive/utilities/-private */ \"./node_modules/@warp-drive/utilities/dist/-private.js\");\n/* harmony import */ var _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @warp-drive/utilities/string */ \"./node_modules/@warp-drive/utilities/dist/string.js\");\n{}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/request-utils/dist/deprecation-support.js?\n}");

/***/ }),

/***/ "./node_modules/@ember-data/request-utils/dist/string.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ember-data/request-utils/dist/string.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   camelize: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.camelize),\n/* harmony export */   capitalize: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.capitalize),\n/* harmony export */   clear: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.clear),\n/* harmony export */   clearRules: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.clearRules),\n/* harmony export */   dasherize: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.dasherize),\n/* harmony export */   irregular: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.irregular),\n/* harmony export */   loadIrregular: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.loadIrregular),\n/* harmony export */   loadUncountable: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.loadUncountable),\n/* harmony export */   plural: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.plural),\n/* harmony export */   pluralize: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.pluralize),\n/* harmony export */   resetToDefaults: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.resetToDefaults),\n/* harmony export */   setMaxLRUCacheSize: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.setMaxLRUCacheSize),\n/* harmony export */   singular: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.singular),\n/* harmony export */   singularize: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.singularize),\n/* harmony export */   uncountable: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.uncountable),\n/* harmony export */   underscore: () => (/* reexport safe */ _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__.underscore)\n/* harmony export */ });\n/* harmony import */ var _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @warp-drive/utilities/string */ \"./node_modules/@warp-drive/utilities/dist/string.js\");\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/request-utils/dist/string.js?\n}");

/***/ }),

/***/ "./node_modules/@ember-data/serializer/dist/transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ember-data/serializer/dist/transform.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanTransform: () => (/* reexport safe */ _warp_drive_legacy_serializer_transform__WEBPACK_IMPORTED_MODULE_0__.BooleanTransform),\n/* harmony export */   DateTransform: () => (/* reexport safe */ _warp_drive_legacy_serializer_transform__WEBPACK_IMPORTED_MODULE_0__.DateTransform),\n/* harmony export */   NumberTransform: () => (/* reexport safe */ _warp_drive_legacy_serializer_transform__WEBPACK_IMPORTED_MODULE_0__.NumberTransform),\n/* harmony export */   StringTransform: () => (/* reexport safe */ _warp_drive_legacy_serializer_transform__WEBPACK_IMPORTED_MODULE_0__.StringTransform),\n/* harmony export */   \"default\": () => (/* reexport safe */ _warp_drive_legacy_serializer_transform__WEBPACK_IMPORTED_MODULE_0__.Transform)\n/* harmony export */ });\n/* harmony import */ var _warp_drive_legacy_serializer_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @warp-drive/legacy/serializer/transform */ \"./node_modules/@warp-drive/legacy/dist/serializer/transform.js\");\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/serializer/dist/transform.js?\n}");

/***/ }),

/***/ "./node_modules/@ember-data/store/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@ember-data/store/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CacheHandler: () => (/* reexport safe */ _warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.CacheHandler),\n/* harmony export */   \"default\": () => (/* reexport safe */ _warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.Store),\n/* harmony export */   recordIdentifierFor: () => (/* reexport safe */ _warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor),\n/* harmony export */   setIdentifierForgetMethod: () => (/* reexport safe */ _warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.setIdentifierForgetMethod),\n/* harmony export */   setIdentifierGenerationMethod: () => (/* reexport safe */ _warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.setIdentifierGenerationMethod),\n/* harmony export */   setIdentifierResetMethod: () => (/* reexport safe */ _warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.setIdentifierResetMethod),\n/* harmony export */   setIdentifierUpdateMethod: () => (/* reexport safe */ _warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.setIdentifierUpdateMethod),\n/* harmony export */   setKeyInfoForResource: () => (/* reexport safe */ _warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.setKeyInfoForResource),\n/* harmony export */   storeFor: () => (/* reexport safe */ _warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.storeFor)\n/* harmony export */ });\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _warp_drive_core_configure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @warp-drive/core/configure */ \"./node_modules/@warp-drive/core/dist/configure.js\");\n/* harmony import */ var _embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../@embroider/macros/src/addon/es-compat2 */ \"./node_modules/@embroider/macros/src/addon/es-compat2.js\");\n/* harmony import */ var _warp_drive_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @warp-drive/core */ \"./node_modules/@warp-drive/core/dist/index.js\");\n/**\n * <p align=\"center\">\n *   <img\n *     class=\"project-logo\"\n *     src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n *     alt=\"EmberData Store\"\n *     width=\"240px\"\n *     title=\"EmberData Store\"\n *     />\n * </p>\n *\n * This package provides [*Ember***Data**](https://github.com/emberjs/data/)'s `Store` class.\n *\n * A [Store](https://api.emberjs.com/ember-data/release/classes/Store) coordinates interaction between your application, a [Cache](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache),\n * and sources of data (such as your API or a local persistence layer) accessed via a [RequestManager](https://github.com/emberjs/data/tree/main/packages/request).\n *\n * Optionally, a Store can be configured to hydrate the response data into rich presentation classes.\n *\n * ## Installation\n *\n * If you have installed `ember-data` then you already have this package installed.\n * Otherwise you can install it using your javascript package manager of choice.\n * For instance with [pnpm](https://pnpm.io/)\n *\n * ```\n * pnpm add @ember-data/store\n * ```\n *\n * After installing you will want to configure your first `Store`. Read more below\n * for how to create and configure stores for your application.\n *\n *\n * ## 🔨 Creating A Store\n *\n * To use a `Store` we will need to do few things: add a [Cache](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache)\n * to store data **in-memory**, add a [Handler](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache) to fetch data from a source,\n * and implement `instantiateRecord` to tell the store how to display the data for individual resources.\n *\n * > **Note**\n * > If you are using the package `ember-data` then a JSON:API cache, RequestManager, LegacyNetworkHandler,\n * > and `instantiateRecord` are configured for you by default.\n *\n * ### Configuring A Cache\n *\n * To start, let's install a [JSON:API](https://jsonapi.org/) cache. If your app uses `GraphQL` or `REST` other\n * caches may better fit your data. You can author your own cache by creating one that\n * conforms to the [spec](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache).\n *\n * The package `@ember-data/json-api` provides a [JSON:API](https://jsonapi.org/) cache we can use.\n * After installing it, we can configure the store to use this cache.\n *\n * ```js\n * import Store from '@ember-data/store';\n * import Cache from '@ember-data/json-api';\n *\n * class extends Store {\n *   createCache(storeWrapper) {\n *     return new Cache(storeWrapper);\n *   }\n * }\n * ```\n *\n * Now that we have a `cache` let's setup something to handle fetching\n * and saving data via our API.\n *\n * > **Note**\n * > The `ember-data` package automatically includes and configures\n * > the `@ember-data/json-api` cache for you.\n *\n * ### Handling Requests\n *\n * When *Ember***Data** needs to fetch or save data it will pass that request to your application's `RequestManager` for fulfillment. How this fulfillment occurs (in-memory, device storage, via single or multiple API requests, etc.) is then up to the registered request handlers.\n *\n * To start, let's install the `RequestManager` from `@ember-data/request` and the basic `Fetch` handler from ``@ember-data/request/fetch`.\n *\n * > **Note**\n * > If your app uses `GraphQL`, `REST` or different conventions for `JSON:API` than your cache expects, other handlers may better fit your data. You can author your own handler by creating one that conforms to the [handler interface](https://github.com/emberjs/data/tree/main/packages/request#handling-requests).\n *\n * ```ts\n * import Store from '@ember-data/store';\n * import RequestManager from '@ember-data/request';\n * import Fetch from '@ember-data/request/fetch';\n *\n * export default class extends Store {\n *   requestManager = new RequestManager()\n *    .use([Fetch]);\n * }\n * ```\n *\n * **Using RequestManager as a Service**\n *\n * Alternatively if you have configured the `RequestManager` to be a service you may re-use it.\n *\n * *app/services/request.js*\n * ```ts\n * import RequestManager from '@ember-data/request';\n * import Fetch from '@ember-data/request/fetch';\n *\n * export default {\n *   create() {\n *     return new RequestManager()\n *       .use([Fetch])\n *       .useCache(CacheHandler);\n *   }\n * }\n * ```\n *\n * *app/services/store.js*\n * ```ts\n * import Store from '@ember-data/store';\n * import { service } from '@ember/service';\n *\n * export default class extends Store {\n *   @service('request') requestManager\n * }\n * ```\n *\n *\n * ### Presenting Data from the Cache\n *\n * Now that we have a source and a cache for our data, we need to configure how\n * the Store delivers that data back to our application. We do this via the hook\n * [instantiateRecord](https://api.emberjs.com/ember-data/release/classes/Store/methods/instantiateRecord%20(hook)?anchor=instantiateRecord%20(hook)),\n * which allows us to transform the data for a resource before handing it to the application.\n *\n * A naive way to present the data would be to return it as JSON. Typically instead\n * this hook will be used to add reactivity and make each unique resource a singleton,\n * ensuring that if the cache updates our presented data will reflect the new state.\n *\n * Below is an example of using the hooks `instantiateRecord` and a `teardownRecord`\n * to provide minimal read-only reactive state for simple resources.\n *\n * ```ts\n * import Store, { recordIdentifierFor } from '@ember-data/store';\n * import { TrackedObject } from 'tracked-built-ins';\n *\n * class extends Store {\n *   instantiateRecord(identifier) {\n *     const { cache, notifications } = this;\n *\n *     // create a TrackedObject with our attributes, id and type\n *     const record = new TrackedObject(Object.assign({}, cache.peek(identifier)));\n *     record.type = identifier.type;\n *     record.id = identifier.id;\n *\n *     notifications.subscribe(identifier, (_, change) => {\n *       if (change === 'attributes') {\n *         Object.assign(record, cache.peek(identifier));\n *       }\n *     });\n *\n *     return record;\n *   }\n * }\n * ```\n *\n * Because `instantiateRecord` is opaque to the nature of the record, an implementation\n * can be anything from a fairly simple object to a robust proxy that intelligently links\n * together associated records through relationships.\n *\n * This also enables creating a record that separates `edit` flows from `create` flows\n * entirely. A record class might choose to implement a `checkout`method that gives access\n * to an editable instance while the primary record continues to be read-only and reflect\n * only persisted (non-mutated) state.\n *\n * Typically you will choose an existing record implementation such as `@ember-data/model`\n * for your application.\n *\n * Because of the boundaries around instantiation and the cache, record implementations\n * should be capable of interop both with each other and with any `Cache`. Due to this,\n * if needed an application can utilize multiple record implementations and multiple cache\n * implementations either to support enhanced features for only a subset of records or to\n * be able to incrementally migrate from one record/cache to another record or cache.\n *\n * > **Note**\n * > The `ember-data` package automatically includes the `@ember-data/model`\n * > package and configures it for you.\n *\n * @module\n */{let hasEmberDataTracking=false;{hasEmberDataTracking=true;// @ts-expect-error\nconst{buildSignalConfig}=(0,_embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(__webpack_require__(/*! @ember-data/tracking */ \"./node_modules/@ember-data/tracking/dist/index.js\"));// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n(0,_warp_drive_core_configure__WEBPACK_IMPORTED_MODULE_1__.setupSignals)(buildSignalConfig);}const message=[`Using WarpDrive with EmberJS requires configuring it to use Ember's reactivity system.`,`Previously this was provided by installing the package '@ember-data/tracking', but this package is now deprecated.`,``,`To resolve this deprecation, follow these steps:`,hasEmberDataTracking?`- remove \"@ember-data/tracking\" and (if needed) \"@ember-data-types/tracking\" from your project in both your package.json and tsconfig.json`:false,`- add \"@warp-drive/ember\" to your project in both your package.json and tsconfig.json`,'- add the following import to your app.js file:','','\\t```',`\\timport '@warp-drive/ember/install';`,'\\t```',``,'- mark this deprecation as resolved in your project by adding the following to your WarpDrive config in ember-cli-build.js:','','\\t```','\\tconst { setConfig } = await import(\"@warp-drive/build-config\");','\\tsetConfig(app, __dirname, {','\\t  deprecations: {','\\t    DEPRECATE_TRACKING_PACKAGE: false,','\\t  },','\\t});','\\t```',``,`For more information, see the Package Unification RFC: https://rfcs.emberjs.com/id/1075-warp-drive-package-unification/`].filter(l=>l!==false).join('\\n');(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(message,false,{id:'warp-drive.deprecate-tracking-package',until:'6.0.0',for:'warp-drive',since:{enabled:'5.3.4',available:'4.13'},url:'https://deprecations.emberjs.com/id/warp-drive.deprecate-tracking-package'});}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/store/dist/index.js?\n}");

/***/ }),

/***/ "./node_modules/@ember-data/tracking/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ember-data/tracking/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildSignalConfig: () => (/* binding */ buildSignalConfig)\n/* harmony export */ });\n/* harmony import */ var _ember_internals_metal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/-internals/metal */ \"@ember/-internals/metal\");\n/* harmony import */ var _ember_internals_metal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_internals_metal__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ember_runloop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/runloop */ \"@ember/runloop\");\n/* harmony import */ var _ember_runloop__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_runloop__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _glimmer_validator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @glimmer/validator */ \"@glimmer/validator\");\n/* harmony import */ var _glimmer_validator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_glimmer_validator__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../@embroider/macros/src/addon/es-compat2 */ \"./node_modules/@embroider/macros/src/addon/es-compat2.js\");\n/**\n * # ~~@ember-data/tracking~~ <Badge type=\"warning\" text=\"deprecated v5.5\" />\n *\n * Using ***Warp*Drive** with EmberJS requires configuring it to use Ember's reactivity system.\n *\n * ::: warning\n * The use of the package **@ember-data/tracking** is now deprecated. It\n * historically provided the bindings into Ember's reactivity system.\n *\n * This package is no longer needed as the configuration is now\n * provided by the package [@warp-drive/ember](../../@warp-drive/ember).\n * :::\n *\n * To resolve this deprecation, follow these steps:\n *\n * ## 1. Remove @ember-data/tracking\n *\n * - Remove `@ember-data/tracking` from package.json (if using `ember-data` this may not be present)\n * - Remove type imports for `@ember-data/tracking` from tsconfig.json\n * - If using `untracked`, change to using `untrack` from `@glimmer/validator`\n *\n * ## 2. Add @warp-drive/ember\n *\n * - Add `@warp-drive/ember` to package.json - the version to install should match the version of `ember-data` or `@ember-data/store`\n * - Do NOT add `@warp-drive/ember` to tsconfig.json - the types in this package install automatically, you can remove any entry for this if it is there\n * - Add `import '@warp-drive/ember/install';` to the top of your `app.js` or `app.ts` file\n *\n * ## 3. Clear the deprecation\n *\n * Once the above steps are complete, the deprecation can be silenced and the automatic fallback\n * registration of reactivity from `@ember-data/tracking` can be removed by updating your [WarpDrive\n * build config](../../@warp-drive/build-config) in your `ember-cli-build` file.\n *\n * ```js [ember-cli-build.js]\n * 'use strict';\n * const EmberApp = require('ember-cli/lib/broccoli/ember-app');\n * const { compatBuild } = require('@embroider/compat');\n *\n * module.exports = async function (defaults) {\n *   const { setConfig } = await import('@warp-drive/build-config'); // [!code focus]\n *   const { buildOnce } = await import('@embroider/vite');\n *   const app = new EmberApp(defaults, {});\n *\n *   setConfig(app, __dirname, { // [!code focus:9]\n *     // this should be the most recent <major>.<minor> version for\n *     // which all deprecations have been fully resolved\n *     // and should be updated when that changes\n *     compatWith: '4.12'\n *     deprecations: {\n *       // ... list individual deprecations that have been resolved here\n *       DEPRECATE_TRACKING_PACKAGE: false // [!code highlight]\n *     }\n *   });\n *\n *   return compatBuild(app, buildOnce);\n * };\n *```\n *\n * @deprecated in version 5.5.0\n * @module\n */const emberDirtyTag=_glimmer_validator__WEBPACK_IMPORTED_MODULE_2__.dirtyTag;/**\n * <Badge type=\"warning\" text=\"deprecated\" />\n *\n * Creates a signal configuration object for WarpDrive that integrates with Ember's\n * reactivity system. This will be automatically imported and registered by\n * `@ember-data/store` if the deprecation has not been resolved.\n *\n * This function should not be called directly in your application code\n * and this package is deprecated entirely, see the [package overview](../../)\n * for more details.\n *\n * @deprecated\n * @public\n */function buildSignalConfig(options){const ARRAY_SIGNAL=options.wellknown.Array;return{createSignal(obj,key){{if(key===ARRAY_SIGNAL){return[(0,_ember_internals_metal__WEBPACK_IMPORTED_MODULE_0__.tagForProperty)(obj,key),(0,_ember_internals_metal__WEBPACK_IMPORTED_MODULE_0__.tagForProperty)(obj,'length'),(0,_ember_internals_metal__WEBPACK_IMPORTED_MODULE_0__.tagForProperty)(obj,'[]')];}}return (0,_ember_internals_metal__WEBPACK_IMPORTED_MODULE_0__.tagForProperty)(obj,key);},consumeSignal(signal){{if(Array.isArray(signal)){(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_2__.consumeTag)(signal[0]);(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_2__.consumeTag)(signal[1]);(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_2__.consumeTag)(signal[2]);return;}}(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_2__.consumeTag)(signal);},notifySignal(signal){{if(Array.isArray(signal)){emberDirtyTag(signal[0]);emberDirtyTag(signal[1]);emberDirtyTag(signal[2]);return;}}emberDirtyTag(signal);},createMemo:(object,key,fn)=>{{const propertyTag=(0,_ember_internals_metal__WEBPACK_IMPORTED_MODULE_0__.tagForProperty)(object,key);const memo=(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_2__.createCache)(fn);let ret;const wrappedFn=()=>{ret=(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_2__.getValue)(memo);};return()=>{const tag=(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_2__.track)(wrappedFn);(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_2__.updateTag)(propertyTag,tag);(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_2__.consumeTag)(tag);return ret;};}},willSyncFlushWatchers:()=>{//@ts-expect-error\nreturn!!_ember_runloop__WEBPACK_IMPORTED_MODULE_1__._backburner.currentInstance&&_ember_runloop__WEBPACK_IMPORTED_MODULE_1__._backburner._autorun!==true;},waitFor:async promise=>{{const{waitForPromise}=(0,_embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(__webpack_require__(/*! @ember/test-waiters */ \"./node_modules/@ember/test-waiters/dist/index.js\"));return waitForPromise(promise);}// removed by dead control flow\n}};}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/tracking/dist/index.js?\n}");

/***/ }),

/***/ "./node_modules/@ember/test-waiters/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@ember/test-waiters/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _reset: () => (/* binding */ _reset),\n/* harmony export */   _resetWaiterNames: () => (/* binding */ _resetWaiterNames),\n/* harmony export */   buildWaiter: () => (/* binding */ buildWaiter),\n/* harmony export */   getPendingWaiterState: () => (/* binding */ getPendingWaiterState),\n/* harmony export */   getWaiters: () => (/* binding */ getWaiters),\n/* harmony export */   hasPendingWaiters: () => (/* binding */ hasPendingWaiters),\n/* harmony export */   register: () => (/* binding */ register),\n/* harmony export */   unregister: () => (/* binding */ unregister),\n/* harmony export */   waitFor: () => (/* binding */ waitFor),\n/* harmony export */   waitForFetch: () => (/* binding */ waitForFetch),\n/* harmony export */   waitForPromise: () => (/* binding */ waitForPromise)\n/* harmony export */ });\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./token.js */ \"./node_modules/@ember/test-waiters/dist/token.js\");\nfunction _defineProperty(e,r,t){return(r=_toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\";}function _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}// this ensures that if @ember/test-waiters exists in multiple places in the\n// build output we will still use a single map of waiters (there really should\n// only be one of them, or else `settled` will not work at all)\nconst WAITERS=function(){const HAS_SYMBOL=typeof Symbol!=='undefined';const symbolName='TEST_WAITERS';const symbol=HAS_SYMBOL?Symbol.for(symbolName):symbolName;const global=getGlobal();let waiters=global[symbol];if(waiters===undefined){waiters=global[symbol]=new Map();}return waiters;}();function indexable(input){return input;}function getGlobal(){if(typeof globalThis!=='undefined')return indexable(globalThis);if(typeof self!=='undefined')return indexable(self);if(typeof window!=='undefined')return indexable(window);throw new Error('unable to locate global object');}/**\n * Registers a waiter.\n *\n * @public\n * @param waiter {Waiter} A test waiter instance\n */function register(waiter){WAITERS.set(waiter.name,waiter);}/**\n * Un-registers a waiter.\n *\n * @public\n * @param waiter {Waiter} A test waiter instance\n */function unregister(waiter){WAITERS.delete(waiter.name);}/**\n * Gets an array of all waiters current registered.\n *\n * @public\n * @returns {Waiter[]}\n */function getWaiters(){const result=[];WAITERS.forEach(value=>{result.push(value);});return result;}/**\n * Clears all waiters.\n *\n * @private\n */function _reset(){for(const waiter of getWaiters()){waiter.isRegistered=false;}WAITERS.clear();}/**\n * Gets the current state of all waiters. Any waiters whose\n * `waitUntil` method returns false will be considered `pending`.\n *\n * @returns {PendingWaiterState} An object containing a count of all waiters\n * pending and a `waiters` object containing the name of all pending waiters\n * and their debug info.\n */function getPendingWaiterState(){const result={pending:0,waiters:{}};WAITERS.forEach(waiter=>{if(!waiter.waitUntil()){result.pending++;const debugInfo=waiter.debugInfo();result.waiters[waiter.name]=debugInfo||true;}});return result;}/**\n * Determines if there are any pending waiters.\n *\n * @returns {boolean} `true` if there are pending waiters, otherwise `false`.\n */function hasPendingWaiters(){const state=getPendingWaiterState();return state.pending>0;}const WAITER_NAME_PATTERN=/^[^:]*:?.*/;let WAITER_NAMES=new Set();function _resetWaiterNames(){WAITER_NAMES=new Set();}function getNextToken(){return new _token_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();}class TestWaiterImpl{constructor(name,nextToken){_defineProperty(this,\"name\",void 0);_defineProperty(this,\"nextToken\",void 0);_defineProperty(this,\"isRegistered\",false);_defineProperty(this,\"items\",new Map());_defineProperty(this,\"completedOperationsForTokens\",new WeakMap());_defineProperty(this,\"completedOperationsForPrimitives\",new Map());this.name=name;// @ts-ignore\nthis.nextToken=nextToken||getNextToken;}beginAsync(token=this.nextToken(),label){this._register();if(this.items.has(token)){// SAFETY: force stringification of a potential symbol\nthrow new Error(`beginAsync called for ${token} but it is already pending.`);}const error=new Error();this.items.set(token,{get stack(){return error.stack;},label});return token;}endAsync(token){if(!this.items.has(token)&&!this._getCompletedOperations(token).has(token)){throw new Error(`testWaiter.endAsync called with no preceding testWaiter.beginAsync call.\n        Test waiter calls should always be paired. This can occur when a test waiter's paired calls are invoked in a non-deterministic order.\n\n        See https://github.com/emberjs/ember-test-waiters#keep-beginasyncendasync-in-same-block-scope for more information.`);}this.items.delete(token);// Mark when a waiter operation has completed so we can distinguish\n// whether endAsync is being called before a prior beginAsync call above.\nthis._getCompletedOperations(token).set(token,true);}waitUntil(){return this.items.size===0;}debugInfo(){const result=[];this.items.forEach(value=>{result.push(value);});return result;}reset(){this.items.clear();}_register(){if(!this.isRegistered){register(this);this.isRegistered=true;}}_getCompletedOperations(token){const type=typeof token;const isFunction=type==='function';const isObject=token!==null&&type==='object';const isPrimitive=!isFunction&&!isObject;return isPrimitive?this.completedOperationsForPrimitives:this.completedOperationsForTokens;}}class NoopTestWaiter{constructor(name){_defineProperty(this,\"name\",void 0);this.name=name;}beginAsync(){return this;}endAsync(){}waitUntil(){return true;}debugInfo(){return[];}reset(){}}/**\n * Builds and returns a test waiter. The type of the\n * returned waiter is dependent on whether the app or\n * addon is in `isDevelopingApp()` mode or not.\n *\n * @public\n *\n * @param name {string} The name of the test waiter\n * @returns {TestWaiter}\n *\n * @example\n *\n * import Component from '@ember/component';\n * import { buildWaiter } from '@ember/test-waiters';\n *\n * if (macroCondition(isDevelopingApp())) {\n *   let waiter = buildWaiter('friend-waiter');\n * }\n *\n * export default class Friendz extends Component {\n *   didInsertElement() {\n *     let token = waiter.beginAsync(this);\n *\n *     someAsyncWork().then(() => {\n *       waiter.endAsync(token);\n *     });\n *   }\n * }\n */function buildWaiter(name){{(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.warn)(`The waiter name '${name}' is already in use`,!WAITER_NAMES.has(name),{id:'@ember/test-waiters.duplicate-waiter-name'});WAITER_NAMES.add(name);}{(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.warn)(`You must provide a name that contains a descriptive prefix separated by a colon.\n\n        Example: ember-fictitious-addon:some-file\n\n        You passed: ${name}`,WAITER_NAME_PATTERN.test(name),{id:'@ember/test-waiters.invalid-waiter-name'});return new TestWaiterImpl(name);}}const PROMISE_WAITER=buildWaiter('@ember/test-waiters:promise-waiter');/**\n * A convenient utility function to simplify waiting for a promise.\n *\n * @public\n * @param promise {Promise<T> | RSVP.Promise<T>} The promise to track async operations for\n * @param label {string} An optional string to identify the promise\n *\n * @example\n *\n * import Component from '@ember/component';\n * import { waitForPromise } from '@ember/test-waiters';\n *\n * export default class Friendz extends Component {\n *   didInsertElement() {\n *     waitForPromise(new Promise(resolve => {\n *       doSomeWork();\n *       resolve();\n *     }));\n *   }\n * }\n */function waitForPromise(promise,label){let result=promise;{PROMISE_WAITER.beginAsync(promise,label);result=promise.then(value=>{PROMISE_WAITER.endAsync(promise);return value;},error=>{PROMISE_WAITER.endAsync(promise);throw error;});}return result;}/**\n * A convenient utility function to simplify waiting for async. Can be used\n * in both decorator and function form. When applied to an async function, it\n * will cause tests to wait until the returned promise has resolves. When\n * applied to a generator function, it will cause tests to wait until the\n * returned iterator has run to completion, which is useful for wrapping\n * ember-concurrency task functions.\n *\n *\n * @public\n * @param promise {Function} An async function or a generator function\n * @param label {string} An optional string to identify the promise\n *\n * @example\n *\n * import Component from '@ember/component';\n * import { waitFor } from '@ember/test-waiters';\n *\n * export default Component.extend({\n *   doAsyncStuff: waitFor(async function doAsyncStuff() {\n *     await somethingAsync();\n *   }\n * });\n *\n * @example\n *\n * import Component from '@ember/component';\n * import { waitFor } from '@ember/test-waiters';\n *\n * export default class Friendz extends Component {\n *   @waitFor\n *   async doAsyncStuff() {\n *     await somethingAsync();\n *   }\n * }\n *\n */function waitFor(...args){const isFunction=args.length<3;if(isFunction){const[fn,label]=args;return wrapFunction(fn,label);}else{const[,,descriptor,label]=args;const fn=descriptor.value;descriptor.value=wrapFunction(fn,label);return descriptor;}}function wrapFunction(fn,label){return function(...args){const result=fn.call(this,...args);if(isThenable(result)){return waitForPromise(result,label);}else if(isGenerator(result)){return waitForGenerator(result,label);}else{return result;}};}function isThenable(maybePromise){const type=typeof maybePromise;return(maybePromise!==null&&type==='object'||type==='function')&&typeof maybePromise.then==='function';}function isGenerator(maybeGenerator){// Because we don't have Symbol.iterator in IE11\nreturn typeof maybeGenerator.next==='function'&&typeof maybeGenerator.return==='function'&&typeof maybeGenerator.throw==='function';}const GENERATOR_WAITER=buildWaiter('@ember/test-waiters:generator-waiter');function waitForGenerator(generator,label){GENERATOR_WAITER.beginAsync(generator,label);let isWaiting=true;function stopWaiting(){if(isWaiting){GENERATOR_WAITER.endAsync(generator);isWaiting=false;}}return{next(...args){let hasErrored=true;try{const val=generator.next(...args);hasErrored=false;if(val.done){stopWaiting();}return val;}finally{// If generator.next() throws, we need to stop waiting. But if we catch\n// and re-throw exceptions, it could move the location from which the\n// uncaught exception is thrown, interfering with the developer\n// debugging experience if they have break-on-exceptions enabled. So we\n// use a boolean flag and a finally block to emulate a catch block.\nif(hasErrored){stopWaiting();}}},return(...args){stopWaiting();return generator.return(...args);},throw(...args){stopWaiting();return generator.throw(...args);}};}const props=['body','bodyUsed','headers','ok','redirected','status','statusText','type','url'];function isResponseProperty(maybeProp){return props.some(prop=>maybeProp===prop);}const fns=['arrayBuffer','blob','bytes','clone','formData','json','text'];function isResponseFn(maybeFn){return fns.some(fn=>maybeFn===fn);}/**\n * Wraps the fetch promise in a test waiter, and also wraps the returned promises' async functions (like json()) in a\n * test waiter.\n */async function waitForFetch(fetchPromise){const response=await waitForPromise(fetchPromise);return new Proxy(response,{get(target,prop,receiver){/* Depending on the stack, Response is often already a Proxy. Reflect.get() will error for property values, when\n       * using a Proxy as the _receiver_ arg, so just return the value the normal way to avoid that issue. */if(typeof prop==='string'&&isResponseProperty(prop)){return target[prop];}const original=Reflect.get(target,prop,receiver);// Wrap Response functions in test waiter\nif(typeof prop==='string'&&isResponseFn(prop)){// clone() is sync, no need to wrap in test-waiter\nif(prop==='clone'){return(...args)=>{return original.call(target,...args);};}return(...args)=>{return waitForPromise(original.call(target,...args));};}// return the Reflect.get() result for anything else\nreturn original;}});}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember/test-waiters/dist/index.js?\n}");

/***/ }),

/***/ "./node_modules/@ember/test-waiters/dist/token.js":
/*!********************************************************!*\
  !*** ./node_modules/@ember/test-waiters/dist/token.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Token)\n/* harmony export */ });\n/**\n * A class representing a test waiter token.\n *\n * @public\n * @class\n */class Token{}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember/test-waiters/dist/token.js?\n}");

/***/ }),

/***/ "./node_modules/@embroider/macros/src/addon/es-compat2.js":
/*!****************************************************************!*\
  !*** ./node_modules/@embroider/macros/src/addon/es-compat2.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ esCompat)\n/* harmony export */ });\nfunction esCompat(m){return m?.__esModule?m:{default:m,...m};}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@embroider/macros/src/addon/es-compat2.js?\n}");

/***/ }),

/***/ "./node_modules/@embroider/macros/src/addon/runtime.js":
/*!*************************************************************!*\
  !*** ./node_modules/@embroider/macros/src/addon/runtime.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   each: () => (/* binding */ each),\n/* harmony export */   getGlobalConfig: () => (/* binding */ getGlobalConfig),\n/* harmony export */   isTesting: () => (/* binding */ isTesting),\n/* harmony export */   macroCondition: () => (/* binding */ macroCondition)\n/* harmony export */ });\n/*\n  These are the runtime implementations for the javascript macros that have\n  runtime implementations.\n\n  Not every macro has a runtime implementation, some only make sense in the\n  build and always run there.\n\n  Even when we have runtime implementations, we are still careful to emit static\n  errors during the build wherever possible, and runtime errors when necessary,\n  so that you're not surprised when you switch from runtime-mode to compile-time\n  mode.\n*//*\n  CAUTION: in classic builds, this file gets shared by all present copies of\n  @embroider/macros. If you want to change its public API, you need to rename it\n  and update `pathToRuntime` in ../babel/state.ts to point at it, so that your\n  babel plugin and runtime will match.\n*/function each(array){if(!Array.isArray(array)){throw new Error(`the argument to the each() macro must be an array`);}return array;}function macroCondition(predicate){return predicate;}// This is here as a compile target for `getConfig` and `getOwnConfig` when\n// we're in runtime mode. This is not public API to call from your own code.\nfunction config(packageRoot){return runtimeConfig.packages[packageRoot];}function getGlobalConfig(){return runtimeConfig.global;}function isTesting(){let g=runtimeConfig.global;let e=g&&g['@embroider/macros'];return Boolean(e&&e.isTesting);}const runtimeConfig=initializeRuntimeMacrosConfig();// this exists to be targeted by our babel plugin\nfunction initializeRuntimeMacrosConfig(){return{\"packages\":{},\"global\":{\"@embroider/macros\":{\"isTesting\":false},\"WarpDrive\":{\"debug\":{\"DEBUG_RELATIONSHIP_NOTIFICATIONS\":false,\"LOG_CACHE\":false,\"LOG_CACHE_POLICY\":false,\"LOG_GRAPH\":false,\"LOG_IDENTIFIERS\":false,\"LOG_INSTANCE_CACHE\":false,\"LOG_METRIC_COUNTS\":false,\"LOG_MUTATIONS\":false,\"LOG_NOTIFICATIONS\":false,\"LOG_OPERATIONS\":false,\"LOG_PAYLOADS\":false,\"LOG_REQUESTS\":false,\"LOG_REQUEST_STATUS\":false,\"__INTERNAL_LOG_NATIVE_MAP_SET_COUNTS\":false},\"polyfillUUID\":false,\"includeDataAdapter\":true,\"compatWith\":null,\"deprecations\":{\"DEPRECATE_CATCH_ALL\":true,\"DEPRECATE_COMPUTED_CHAINS\":true,\"DEPRECATE_EMBER_INFLECTOR\":true,\"DEPRECATE_LEGACY_IMPORTS\":true,\"DEPRECATE_MANY_ARRAY_DUPLICATES\":true,\"DEPRECATE_NON_STRICT_ID\":true,\"DEPRECATE_NON_STRICT_TYPES\":true,\"DEPRECATE_NON_UNIQUE_PAYLOADS\":true,\"DEPRECATE_RELATIONSHIP_REMOTE_UPDATE_CLEARING_LOCAL_STATE\":true,\"DEPRECATE_STORE_EXTENDS_EMBER_OBJECT\":false,\"DEPRECATE_TRACKING_PACKAGE\":true,\"DISABLE_7X_DEPRECATIONS\":true,\"ENABLE_LEGACY_SCHEMA_SERVICE\":true},\"features\":{\"JSON_API_CACHE_VALIDATION_ERRORS\":false,\"SAMPLE_FEATURE_FLAG\":false},\"activeLogging\":{\"DEBUG_RELATIONSHIP_NOTIFICATIONS\":true,\"LOG_CACHE\":true,\"LOG_CACHE_POLICY\":true,\"LOG_GRAPH\":true,\"LOG_IDENTIFIERS\":true,\"LOG_INSTANCE_CACHE\":true,\"LOG_METRIC_COUNTS\":true,\"LOG_MUTATIONS\":true,\"LOG_NOTIFICATIONS\":true,\"LOG_OPERATIONS\":true,\"LOG_PAYLOADS\":true,\"LOG_REQUESTS\":true,\"LOG_REQUEST_STATUS\":true,\"__INTERNAL_LOG_NATIVE_MAP_SET_COUNTS\":true},\"env\":{\"TESTING\":true,\"PRODUCTION\":false,\"DEBUG\":true,\"IS_RECORDING\":false,\"IS_CI\":false,\"SHOULD_RECORD\":true}}}};}function updaterMethods(){return{config,getGlobalConfig,setConfig(packageRoot,value){runtimeConfig.packages[packageRoot]=value;},setGlobalConfig(key,value){runtimeConfig.global[key]=value;}};}// this is how runtime config can get injected at boot. I'm not sure yet if this\n// should be public API, but we certainly need it internally to set things like\n// the global fastboot.isRunning.\n//\n// consumers of this API push a function onto\n// window._embroider_macros_runtime_config. The function is given four methods\n// which allow it to read and write the per-package and global configs. The\n// reason for allowing both read & write is that merging strategies are up to\n// each consumers -- read first, then merge, then write.\n//\n// For an example user of this API, see where we generate\n// embroider_macros_fastboot_init.js' in @embroider/core.\nlet updaters=typeof window!=='undefined'?window._embroider_macros_runtime_config:undefined;if(updaters){let methods=updaterMethods();for(let updater of updaters){updater(methods);}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@embroider/macros/src/addon/runtime.js?\n}");

/***/ }),

/***/ "./node_modules/@glimmer/component/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@glimmer/component/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GlimmerComponent)\n/* harmony export */ });\n/* harmony import */ var _glimmer_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @glimmer/env */ \"./node_modules/@glimmer/env/dist/modules/es2017/index.js\");\n/* harmony import */ var _ember_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/component */ \"@ember/component\");\n/* harmony import */ var _ember_component__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_component__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ember_destroyable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember/destroyable */ \"@ember/destroyable\");\n/* harmony import */ var _ember_destroyable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ember_destroyable__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _ember_runloop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ember/runloop */ \"@ember/runloop\");\n/* harmony import */ var _ember_runloop__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_ember_runloop__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _ember_owner__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ember/owner */ \"@ember/owner\");\n/* harmony import */ var _ember_owner__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_ember_owner__WEBPACK_IMPORTED_MODULE_4__);\nfunction _defineProperty(e,r,t){return(r=_toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\";}function _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}const DESTROYING=new WeakMap();const DESTROYED=new WeakMap();function setDestroying(component){DESTROYING.set(component,true);}function setDestroyed(component){DESTROYED.set(component,true);}// This provides a type-safe `WeakMap`: the getter and setter link the key to a\n// specific value. This is how `WeakMap`s actually behave, but the TS type\n// system does not (yet!) have a good way to capture that for types like\n// `WeakMap` where the type is generic over another generic type (here, `Args`).\n// SAFETY: this only holds because we *only* acces this when `DEBUG` is `true`.\n// There is not a great way to connect that data in TS at present.\nlet ARGS_SET;if(_glimmer_env__WEBPACK_IMPORTED_MODULE_0__.DEBUG){ARGS_SET=new WeakMap();}// --- Type utilities for component signatures --- //\n// Type-only \"symbol\" to use with `EmptyObject` below, so that it is *not*\n// equivalent to an empty interface.\n/**\n * This provides us a way to have a \"fallback\" which represents an empty object,\n * without the downsides of how TS treats `{}`. Specifically: this will\n * correctly leverage \"excess property checking\" so that, given a component\n * which has no named args, if someone invokes it with any named args, they will\n * get a type error.\n *\n * @internal This is exported so declaration emit works (if it were not emitted,\n *   declarations which fall back to it would not work). It is *not* intended for\n *   public usage, and the specific mechanics it uses may change at any time.\n *   The location of this export *is* part of the public API, because moving it\n *   will break existing declarations, but is not legal for end users to import\n *   themselves, so ***DO NOT RELY ON IT***.\n *//** Given a signature `S`, get back the `Args` type. *//**\n * Given any allowed shorthand form of a signature, desugars it to its full\n * expanded type.\n *\n * @internal This is only exported so we can avoid duplicating it in\n *   [Glint](https://github.com/typed-ember/glint) or other such tooling. It is\n *   *not* intended for public usage, and the specific mechanics it uses may\n *   change at any time. Although the signature produced by is part of Glimmer's\n *   public API the existence and mechanics of this specific symbol are *not*,\n *   so ***DO NOT RELY ON IT***.\n */// The conditional type here is because TS applies conditional types\n// distributively. This means that for union types, checks like `keyof T` get\n// all the keys from all elements of the union, instead of ending up as `never`\n// and then always falling into the `Signature` path instead of falling back to\n// the legacy args handling path.\n/**\n * @internal we use this type for convenience internally; inference means users\n *   should not normally need to name it\n *//**\n * The `Component` class defines an encapsulated UI element that is rendered to\n * the DOM. A component is made up of a template and, optionally, this component\n * object.\n *\n * ## Defining a Component\n *\n * To define a component, subclass `Component` and add your own properties,\n * methods and lifecycle hooks:\n *\n * ```ts\n * import Component from '@glimmer/component';\n *\n * export default class extends Component {\n * }\n * ```\n *\n * ## Lifecycle Hooks\n *\n * Lifecycle hooks allow you to respond to changes to a component, such as when\n * it gets created, rendered, updated or destroyed. To add a lifecycle hook to a\n * component, implement the hook as a method on your component subclass.\n *\n * For example, to be notified when Glimmer has rendered your component so you\n * can attach a legacy jQuery plugin, implement the `didInsertElement()` method:\n *\n * ```ts\n * import Component from '@glimmer/component';\n *\n * export default class extends Component {\n *   didInsertElement() {\n *     $(this.element).pickadate();\n *   }\n * }\n * ```\n *\n * ## Data for Templates\n *\n * `Component`s have two different kinds of data, or state, that can be\n * displayed in templates:\n *\n * 1. Arguments\n * 2. Properties\n *\n * Arguments are data that is passed in to a component from its parent\n * component. For example, if I have a `UserGreeting` component, I can pass it\n * a name and greeting to use:\n *\n * ```hbs\n * <UserGreeting @name=\"Ricardo\" @greeting=\"Olá\" />\n * ```\n *\n * Inside my `UserGreeting` template, I can access the `@name` and `@greeting`\n * arguments that I've been given:\n *\n * ```hbs\n * {{@greeting}}, {{@name}}!\n * ```\n *\n * Arguments are also available inside my component:\n *\n * ```ts\n * console.log(this.args.greeting); // prints \"Olá\"\n * ```\n *\n * Properties, on the other hand, are internal to the component and declared in\n * the class. You can use properties to store data that you want to show in the\n * template, or pass to another component as an argument.\n *\n * ```ts\n * import Component from '@glimmer/component';\n *\n * export default class extends Component {\n *   user = {\n *     name: 'Robbie'\n *   }\n * }\n * ```\n *\n * In the above example, we've defined a component with a `user` property that\n * contains an object with its own `name` property.\n *\n * We can render that property in our template:\n *\n * ```hbs\n * Hello, {{user.name}}!\n * ```\n *\n * We can also take that property and pass it as an argument to the\n * `UserGreeting` component we defined above:\n *\n * ```hbs\n * <UserGreeting @greeting=\"Hello\" @name={{user.name}} />\n * ```\n *\n * ## Arguments vs. Properties\n *\n * Remember, arguments are data that was given to your component by its parent\n * component, and properties are data your component has defined for itself.\n *\n * You can tell the difference between arguments and properties in templates\n * because arguments always start with an `@` sign (think \"A is for arguments\"):\n *\n * ```hbs\n * {{@firstName}}\n * ```\n *\n * We know that `@firstName` came from the parent component, not the current\n * component, because it starts with `@` and is therefore an argument.\n *\n * On the other hand, if we see:\n *\n * ```hbs\n * {{name}}\n * ```\n *\n * We know that `name` is a property on the component. If we want to know where\n * the data is coming from, we can go look at our component class to find out.\n *\n * Inside the component itself, arguments always show up inside the component's\n * `args` property. For example, if `{{@firstName}}` is `Tom` in the template,\n * inside the component `this.args.firstName` would also be `Tom`.\n */let GlimmerComponent$1=class GlimmerComponent{/**\n   * Constructs a new component and assigns itself the passed properties. You\n   * should not construct new components yourself. Instead, Glimmer will\n   * instantiate new components automatically as it renders.\n   *\n   * @param owner\n   * @param args\n   */constructor(owner,args){/**\n   * Named arguments passed to the component from its parent component.\n   * They can be accessed in JavaScript via `this.args.argumentName` and in the template via `@argumentName`.\n   *\n   * Say you have the following component, which will have two `args`, `firstName` and `lastName`:\n   *\n   * ```hbs\n   * <my-component @firstName=\"Arthur\" @lastName=\"Dent\" />\n   * ```\n   *\n   * If you needed to calculate `fullName` by combining both of them, you would do:\n   *\n   * ```ts\n   * didInsertElement() {\n   *   console.log(`Hi, my full name is ${this.args.firstName} ${this.args.lastName}`);\n   * }\n   * ```\n   *\n   * While in the template you could do:\n   *\n   * ```hbs\n   * <p>Welcome, {{@firstName}} {{@lastName}}!</p>\n   * ```\n   */_defineProperty(this,\"args\",void 0);if(_glimmer_env__WEBPACK_IMPORTED_MODULE_0__.DEBUG&&!(owner!==null&&typeof owner==='object'&&ARGS_SET.has(args))){throw new Error(`You must pass both the owner and args to super() in your component: ${this.constructor.name}. You can pass them directly, or use ...arguments to pass all arguments through.`);}this.args=args;DESTROYING.set(this,false);DESTROYED.set(this,false);}get isDestroying(){return DESTROYING.get(this)||false;}get isDestroyed(){return DESTROYED.get(this)||false;}/**\n   * Called before the component has been removed from the DOM.\n   */willDestroy(){}};class BaseComponentManager{constructor(owner){_defineProperty(this,\"owner\",void 0);this.owner=owner;}createComponent(ComponentClass,args){if(_glimmer_env__WEBPACK_IMPORTED_MODULE_0__.DEBUG){ARGS_SET.set(args.named,true);}return new ComponentClass(this.owner,args.named);}getContext(component){return component;}}const CAPABILITIES=(0,_ember_component__WEBPACK_IMPORTED_MODULE_1__.capabilities)('3.13',{destructor:true,asyncLifecycleCallbacks:false,updateHook:false});function scheduledDestroyComponent(component){if(component.isDestroyed){return;}(0,_ember_destroyable__WEBPACK_IMPORTED_MODULE_2__.destroy)(component);setDestroyed(component);}/**\n * This component manager runs in Ember.js environments and extends the base component manager to:\n *\n * 1. Properly destroy the component's associated `meta` data structure\n * 2. Schedule destruction using Ember's runloop\n */class EmberGlimmerComponentManager extends BaseComponentManager{constructor(...args){super(...args);_defineProperty(this,\"capabilities\",CAPABILITIES);}destroyComponent(component){if(component.isDestroying){return;}setDestroying(component);(0,_ember_runloop__WEBPACK_IMPORTED_MODULE_3__.schedule)('actions',component,component.willDestroy);(0,_ember_runloop__WEBPACK_IMPORTED_MODULE_3__.schedule)('destroy',this,scheduledDestroyComponent,component);}}/**\n  A component is a reusable UI element that consists of a `.hbs` template and an\n  optional JavaScript class that defines its behavior. For example, someone\n  might make a `button` in the template and handle the click behavior in the\n  JavaScript file that shares the same name as the template.\n\n  Components are broken down into two categories:\n\n  - Components _without_ JavaScript, that are based only on a template. These\n    are called Template-only or TO components.\n  - Components _with_ JavaScript, which consist of a template and a backing\n    class.\n\n  Ember ships with two types of JavaScript classes for components:\n\n  1. Glimmer components, imported from `@glimmer/component`, which are the\n     default components for Ember Octane (3.15) and more recent editions.\n  2. Classic components, imported from `@ember/component`, which were the\n     default for older editions of Ember (pre 3.15).\n\n  Below is the documentation for Template-only and Glimmer components. If you\n  are looking for the API documentation for Classic components, it is\n  [available here](/ember/release/classes/Component). The source code for\n  Glimmer components can be found in [`@glimmer/component`](https://github.com/glimmerjs/glimmer.js/tree/master/packages/%40glimmer/component).\n\n  ## Defining a Template-only Component\n\n  The simplest way to create a component is to create a template file in\n  `app/templates/components`. For example, if you name a template\n  `app/templates/components/person-profile.hbs`:\n\n  ```app/templates/components/person-profile.hbs\n  <h1>{{@person.name}}</h1>\n  <img src={{@person.avatar}}>\n  <p class='signature'>{{@person.signature}}</p>\n  ```\n\n  You will be able to use `<PersonProfile />` to invoke this component elsewhere\n  in your application:\n\n  ```app/templates/application.hbs\n  <PersonProfile @person={{this.currentUser}} />\n  ```\n\n  Note that component names are capitalized here in order to distinguish them\n  from regular HTML elements, but they are dasherized in the file system.\n\n  While the angle bracket invocation form is generally preferred, it is also\n  possible to invoke the same component with the `{{person-profile}}` syntax:\n\n  ```app/templates/application.hbs\n  {{person-profile person=this.currentUser}}\n  ```\n\n  Note that with this syntax, you use dashes in the component name and\n  arguments are passed without the `@` sign.\n\n  In both cases, Ember will render the content of the component template we\n  created above. The end result will be something like this:\n\n  ```html\n  <h1>Tomster</h1>\n  <img src=\"https://emberjs.com/tomster.jpg\">\n  <p class='signature'>Out of office this week</p>\n  ```\n\n  ## File System Nesting\n\n  Components can be nested inside sub-folders for logical groupping. For\n  example, if we placed our template in\n  `app/templates/components/person/short-profile.hbs`, we can invoke it as\n  `<Person::ShortProfile />`:\n\n  ```app/templates/application.hbs\n  <Person::ShortProfile @person={{this.currentUser}} />\n  ```\n\n  Or equivalently, `{{person/short-profile}}`:\n\n  ```app/templates/application.hbs\n  {{person/short-profile person=this.currentUser}}\n  ```\n\n  ## Using Blocks\n\n  You can use `yield` inside a template to include the **contents** of any block\n  attached to the component. For instance, if we added a `{{yield}}` to our\n  component like so:\n\n  ```app/templates/components/person-profile.hbs\n  <h1>{{@person.name}}</h1>\n  {{yield}}\n  ```\n\n  We could then invoke it like this:\n\n  ```handlebars\n  <PersonProfile @person={{this.currentUser}}>\n    <p>Admin mode</p>\n  </PersonProfile>\n  ```\n\n  or with curly syntax like this:\n\n  ```handlebars\n  {{#person-profile person=this.currentUser}}\n    <p>Admin mode</p>\n  {{/person-profile}}\n  ```\n\n  And the content passed in between the brackets of the component would be\n  rendered in the same place as the `{{yield}}` within it, replacing it.\n\n  Blocks are executed in their original context, meaning they have access to the\n  scope and any in-scope variables where they were defined.\n\n  ### Passing parameters to blocks\n\n  You can also pass positional parameters to `{{yield}}`, which are then made\n  available in the block:\n\n  ```app/templates/components/person-profile.hbs\n  <h1>{{@person.name}}</h1>\n  {{yield @person.signature}}\n  ```\n\n  We can then use this value in the block like so:\n\n  ```handlebars\n  <PersonProfile @person={{this.currentUser}} as |signature|>\n    {{signature}}\n  </PersonProfile>\n  ```\n\n  ### Passing multiple blocks\n\n  You can pass multiple blocks to a component by giving them names, and\n  specifying which block you are yielding to with `{{yield}}`. For instance, if\n  we wanted to add a way for users to customize the title of our\n  `<PersonProfile>` component, we could add a named block inside of the header:\n\n  ```app/templates/components/person-profile.hbs\n  <h1>{{yield to=\"title\"}}</h1>\n  {{yield}}\n  ```\n\n  This component could then be invoked like so:\n\n  ```handlebars\n  <PersonProfile @person={{this.currentUser}}>\n    <:title>{{this.currentUser.name}}</:title>\n    <:default>{{this.currentUser.signature}}</:default>\n  </PersonProfile>\n  ```\n\n  When passing named blocks, you must name every block, including the `default`\n  block, which is the block that is defined if you do not pass a `to` parameter\n  to `{{yield}}`. Whenever you invoke a component without passing explicitly\n  named blocks, the passed block is considered the `default` block.\n\n  ### Passing parameters to named blocks\n\n  You can also pass parameters to named blocks:\n\n  ```app/templates/components/person-profile.hbs\n  <h1>{{yield @person.name to=\"title\"}}</h1>\n  {{yield @person.signature}}\n  ```\n\n  These parameters can then be used like so:\n\n  ```handlebars\n  <PersonProfile @person={{this.currentUser}}>\n    <:title as |name|>{{name}}</:title>\n    <:default as |signature|>{{signature}}</:default>\n  </PersonProfile>\n  ```\n\n  ### Checking to see if a block exists\n\n  You can also check to see if a block exists using the `(has-block)` keyword,\n  and conditionally use it, or provide a default template instead.\n\n  ```app/templates/components/person-profile.hbs\n  <h1>\n    {{#if (has-block \"title\")}}\n      {{yield @person.name to=\"title\"}}\n    {{else}}\n      {{@person.name}}\n    {{/if}}\n  </h1>\n\n  {{#if (has-block)}}\n    {{yield @person.signature}}\n  {{else}}\n    {{@person.signature}}\n  {{/if}}\n  ```\n\n  With this template, we can then optionally pass in one block, both blocks, or\n  none at all:\n\n  ```handlebars\n  {{! passing both blocks }}\n  <PersonProfile @person={{this.currentUser}}>\n    <:title as |name|>{{name}}</:title>\n    <:default as |signature|>{{signature}}</:default>\n  </PersonProfile>\n\n  {{! passing just the title block }}\n  <PersonProfile @person={{this.currentUser}}>\n    <:title as |name|>{{name}}</:title>\n  </PersonProfile>\n\n  {{! passing just the default block }}\n  <PersonProfile @person={{this.currentUser}} as |signature|>\n    {{signature}}\n  </PersonProfile>\n\n  {{! not passing any blocks }}\n  <PersonProfile @person={{this.currentUser}}/>\n  ```\n\n  ### Checking to see if a block has parameters\n\n  We can also check if a block receives parameters using the `(has-block-params)`\n  keyword, and conditionally yield different values if so.\n\n  ```app/templates/components/person-profile.hbs\n  {{#if (has-block-params)}}\n    {{yield @person.signature}}\n  {{else}}\n    {{yield}}\n  {{/if}}\n  ```\n\n  ## Customizing Components With JavaScript\n\n  To add JavaScript to a component, create a JavaScript file in the same\n  location as the template file, with the same name, and export a subclass\n  of `Component` as the default value. For example, to add Javascript to the\n  `PersonProfile` component which we defined above, we would create\n  `app/components/person-profile.js` and export our class as the default, like\n  so:\n\n  ```app/components/person-profile.js\n  import Component from '@glimmer/component';\n\n  export default class PersonProfileComponent extends Component {\n    get displayName() {\n      let { title, firstName, lastName } = this.args.person;\n\n      if (title) {\n        return `${title} ${lastName}`;\n      } else {\n        return `${firstName} ${lastName}`;\n      }\n    })\n  }\n  ```\n\n  You can add your own properties, methods, and lifecycle hooks to this\n  subclass to customize its behavior, and you can reference the instance of the\n  class in your template using `{{this}}`. For instance, we could access the\n  `displayName` property of our `PersonProfile` component instance in the\n  template like this:\n\n  ```app/templates/components/person-profile.hbs\n  <h1>{{this.displayName}}</h1>\n  {{yield}}\n  ```\n\n  ## `constructor`\n\n  params: `owner` object and `args` object\n\n  Constructs a new component and assigns itself the passed properties. The\n  constructor is run whenever a new instance of the component is created, and\n  can be used to setup the initial state of the component.\n\n  ```javascript\n  import Component from '@glimmer/component';\n\n  export default class SomeComponent extends Component {\n    constructor(owner, args) {\n      super(owner, args);\n\n      if (this.args.displayMode === 'list') {\n        this.items = [];\n      }\n    }\n  }\n  ```\n\n  Service injections and arguments are available in the constructor.\n\n  ```javascript\n  import Component from '@glimmer/component';\n  import { service } from '@ember/service';\n\n  export default class SomeComponent extends Component {\n    @service myAnimations;\n\n    constructor(owner, args) {\n      super(owner, args);\n\n      if (this.args.fadeIn === true) {\n        this.myAnimations.register(this, 'fade-in');\n      }\n    }\n  }\n  ```\n\n  ## `willDestroy`\n\n  `willDestroy` is called after the component has been removed from the DOM, but\n  before the component is fully destroyed. This lifecycle hook can be used to\n  cleanup the component and any related state.\n\n  ```javascript\n  import Component from '@glimmer/component';\n  import { service } from '@ember/service';\n\n  export default class SomeComponent extends Component {\n    @service myAnimations;\n\n    willDestroy() {\n      super.willDestroy(...arguments);\n\n      this.myAnimations.unregister(this);\n    }\n  }\n  ```\n\n  ## `args`\n\n  The `args` property of Glimmer components is an object that contains the\n  _arguments_ that are passed to the component. For instance, the\n  following component usage:\n\n  ```handlebars\n  <SomeComponent @fadeIn={{true}} />\n  ```\n\n  Would result in the following `args` object to be passed to the component:\n\n  ```javascript\n  { fadeIn: true }\n  ```\n\n  `args` can be accessed at any point in the component lifecycle, including\n  `constructor` and `willDestroy`. They are also automatically marked as tracked\n  properties, and they can be depended on as computed property dependencies:\n\n  ```javascript\n  import Component from '@glimmer/component';\n  import { computed } from '@ember/object';\n\n  export default class SomeComponent extends Component {\n\n    @computed('args.someValue')\n    get computedGetter() {\n      // updates whenever args.someValue updates\n      return this.args.someValue;\n    }\n\n    get standardGetter() {\n      // updates whenever args.anotherValue updates (Ember 3.13+)\n      return this.args.anotherValue;\n    }\n  }\n  ```\n\n  ## `isDestroying`\n\n  A boolean flag to tell if the component is in the process of destroying. This is set to\n  true before `willDestroy` is called.\n\n  ## `isDestroyed`\n  A boolean to tell if the component has been fully destroyed. This is set to true\n  after `willDestroy` is called.\n\n  @module @glimmer/component\n  @public\n*/class GlimmerComponent extends GlimmerComponent$1{constructor(owner,args){super(owner,args);if(_glimmer_env__WEBPACK_IMPORTED_MODULE_0__.DEBUG&&!(owner!==null&&typeof owner==='object')){throw new Error(`You must pass both the owner and args to super() in your component: ${this.constructor.name}. You can pass them directly, or use ...arguments to pass all arguments through.`);}(0,_ember_owner__WEBPACK_IMPORTED_MODULE_4__.setOwner)(this,owner);}}(0,_ember_component__WEBPACK_IMPORTED_MODULE_1__.setComponentManager)(owner=>{return new EmberGlimmerComponentManager(owner);},GlimmerComponent);\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@glimmer/component/dist/index.js?\n}");

/***/ }),

/***/ "./node_modules/@glimmer/env/dist/modules/es2017/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@glimmer/env/dist/modules/es2017/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CI: () => (/* binding */ CI),\n/* harmony export */   DEBUG: () => (/* binding */ DEBUG)\n/* harmony export */ });\nconst DEBUG=false;const CI=false;\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@glimmer/env/dist/modules/es2017/index.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/configure-B48bFHOl.js":
/*!******************************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/configure-B48bFHOl.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ ARRAY_SIGNAL),\n/* harmony export */   O: () => (/* binding */ OBJECT_SIGNAL),\n/* harmony export */   a: () => (/* binding */ createSignal),\n/* harmony export */   b: () => (/* binding */ consumeSignal),\n/* harmony export */   c: () => (/* binding */ createMemo),\n/* harmony export */   d: () => (/* binding */ willSyncFlushWatchers),\n/* harmony export */   n: () => (/* binding */ notifySignal),\n/* harmony export */   s: () => (/* binding */ setupSignals),\n/* harmony export */   w: () => (/* binding */ waitFor)\n/* harmony export */ });\n/* harmony import */ var _types_private_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types/-private.js */ \"./node_modules/@warp-drive/core/dist/types/-private.js\");\nconst ARRAY_SIGNAL=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('#[]',Symbol('#[]'));const OBJECT_SIGNAL=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('#{}',Symbol('#{}'));/**\n * Requirements:\n *\n * Signal:\n *\n * - signal: a way of creating a reference that we can dirty when we desire to notify\n *         - @signal: a way of creating an accessor on an object that subscribes to a signal on access\n *                    and notifies the signal on set, or of upgrading a descriptor to be such an accessor\n *         - defineSignal: a way of creating a signal on an object\n *         - notifySignal: a way of notifying the underlying signal that it has been dirtied\n *         - peekSignal: a way of inspecting the signal without notifying it\n *\n *  - gate: a memoized getter function that re-runs when on access if its signal is dirty\n *          conceptually, a gate is a tightly coupled signal and memo\n *         - @gate: a way of creating a gate on an object or upgrading a descriptor with a getter\n *                  to be a gate\n *         - defineGate: a way of creating a gate on an object\n *         - notifySignal: a way of notifying the signal for a gate that it has been dirtied\n *\n * - memo:\n *        - @memo: a way of creating a memoized getter on an object or upgrading a descriptor with a getter\n *                 to be a memo\n *        - defineMemo: a way of creating a memo on an object\n *\n * - signalStore: storage bucket for signals associated to an object\n *        - withSignalStore: a way of pre-creating a signal store on an object\n *\n *\n * @internal\n *//**\n * An Opaque type that represents a framework specific or TC39 signal.\n *\n * It may be an array of signals or a single signal.\n *\n * @internal\n *//**\n * The hooks which MUST be configured in order to use reactive arrays,\n * resources and documents with framework specfic signals or TC39 signals.\n *\n * Support for multiple frameworks simultaneously can be done via\n * this abstraction by returning multiple signals from the `createSignal`\n * method, and consuming the correct one via the correct framework via\n * the `consumeSignal` and `notifySignal` methods.\n *\n * Unlike many signals implementations, WarpDrive does not wrap values as\n * signals directly, but instead uses signals to alert the reactive layer\n * to changes in the underlying cache. E.g. a signal is associated to a value,\n * but does not serve as the cache for that value directly. We refer to this as\n * a \"gate\", the pattern has also been called \"side-signals\".\n *\n * A no-op implementation is allowed, though it may lead to performance issues\n * in locations that use createMemo as no memoization would be done. This is\n * typically desirable only when integrating with a framework that does its own\n * memoization and does not integrate with any signals-like primitive. For these\n * scenarios you may also be interested in integrating with the {@link NotificationManager}\n * more directly.\n *\n * @public\n *//**\n * Contains information a {@link SignalHooks} implementation may want\n * to use, such as the specialized key used for the signal\n * representing an array's contents / length.\n *\n * ```ts\n * interface HooksOptions {\n *   wellknown: {\n *     Array: symbol | string;\n *   }\n * }\n * ```\n *\n * @public\n *//**\n * Configures the signals implementation to use. Supports multiple\n * implementations simultaneously.\n *\n * See {@link HooksOptions} for the options passed to the provided function\n * when called.\n *\n * See {@link SignalHooks} for the implementation the callback function should\n * return.\n *\n * @public\n * @param buildConfig - a function that takes options and returns a configuration object\n */function setupSignals(buildConfig){// We want to assert this but can't because too many package manager\n// and bundler bugs exist that cause this to be called multiple times\n// for what should be a single call.\n// assert(`Cannot override configured signal hooks`, peekTransient('signalHooks') === null);\nconst hooks=buildConfig({wellknown:{Array:ARRAY_SIGNAL}});(0,_types_private_js__WEBPACK_IMPORTED_MODULE_0__.setTransient)('signalHooks',hooks);}/**\n * Internal method for consuming the configured `createSignal` hook\n *\n * @internal\n */function createSignal(obj,key){const signalHooks=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_0__.peekTransient)('signalHooks');(test=>{if(!test){throw new Error(`Signal hooks not configured`);}})(signalHooks);return signalHooks.createSignal(obj,key);}/**\n * Internal method for consuming the configured `consumeSignal` hook\n *\n * @internal\n */function consumeSignal(signal){const signalHooks=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_0__.peekTransient)('signalHooks');(test=>{if(!test){throw new Error(`Signal hooks not configured`);}})(signalHooks);return signalHooks.consumeSignal(signal);}/**\n * Internal method for consuming the configured `notifySignal` hook\n *\n * @internal\n */function notifySignal(signal){const signalHooks=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_0__.peekTransient)('signalHooks');(test=>{if(!test){throw new Error(`Signal hooks not configured`);}})(signalHooks);return signalHooks.notifySignal(signal);}function createMemo(object,key,fn){const signalHooks=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_0__.peekTransient)('signalHooks');(test=>{if(!test){throw new Error(`Signal hooks not configured`);}})(signalHooks);return signalHooks.createMemo(object,key,fn);}function willSyncFlushWatchers(){const signalHooks=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_0__.peekTransient)('signalHooks');(test=>{if(!test){throw new Error(`Signal hooks not configured`);}})(signalHooks);return signalHooks.willSyncFlushWatchers();}function waitFor(promise){const signalHooks=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_0__.peekTransient)('signalHooks');if(signalHooks?.waitFor){return signalHooks.waitFor(promise);}return promise;}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/configure-B48bFHOl.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/configure.js":
/*!*********************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/configure.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupSignals: () => (/* reexport safe */ _configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_0__.s)\n/* harmony export */ });\n/* harmony import */ var _configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configure-B48bFHOl.js */ \"./node_modules/@warp-drive/core/dist/configure-B48bFHOl.js\");\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/configure.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/context-COmAnXUQ.js":
/*!****************************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/context-COmAnXUQ.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ IS_CACHE_HANDLER),\n/* harmony export */   a: () => (/* binding */ cloneResponseProperties),\n/* harmony export */   b: () => (/* binding */ assertValidRequest),\n/* harmony export */   c: () => (/* binding */ createDeferred),\n/* harmony export */   d: () => (/* binding */ getRequestResult),\n/* harmony export */   e: () => (/* binding */ executeNextHandler),\n/* harmony export */   f: () => (/* binding */ clearRequestResult),\n/* harmony export */   g: () => (/* binding */ getPromiseResult),\n/* harmony export */   s: () => (/* binding */ setPromiseResult),\n/* harmony export */   u: () => (/* binding */ upgradePromise)\n/* harmony export */ });\n/* harmony import */ var _types_request_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types/request.js */ \"./node_modules/@warp-drive/core/dist/types/request.js\");\n/* harmony import */ var _types_private_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types/-private.js */ \"./node_modules/@warp-drive/core/dist/types/-private.js\");\nfunction _classPrivateFieldInitSpec(e,t,a){_checkPrivateRedeclaration(e,t),t.set(e,a);}function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError(\"Cannot initialize the same private elements twice on an object\");}function _classPrivateFieldGet(s,a){return s.get(_assertClassBrand(s,a));}function _classPrivateFieldSet(s,a,r){return s.set(_assertClassBrand(s,a),r),r;}function _assertClassBrand(e,t,n){if(\"function\"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError(\"Private element is not present on this object\");}function _defineProperty(e,r,t){return(r=_toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\";}function _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}const BODY_TYPES={type:'string',klass:['Blob','ArrayBuffer','TypedArray','DataView','FormData','URLSearchParams','ReadableStream']};const ValidKeys=new Map([['duplex',['half']],['records','array'],['data','json'],['body',BODY_TYPES],['disableTestWaiter','boolean'],['options','object'],['cacheOptions','object'],['op','string'],['store','object'],['url','string'],['cache',['default','force-cache','no-cache','no-store','only-if-cached','reload']],['credentials',['include','omit','same-origin']],['destination',['','object','audio','audioworklet','document','embed','font','frame','iframe','image','manifest','paintworklet','report','script','sharedworker','style','track','video','worker','xslt']],['headers','headers'],['integrity','string'],['keepalive','boolean'],['method',['QUERY','GET','PUT','PATCH','DELETE','POST','OPTIONS','HEAD','CONNECT','TRACE']],['mode',['same-origin','cors','navigate','no-cors']],['redirect',['error','follow','manual']],['referrer','string'],['signal','AbortSignal'],['controller','AbortController'],['referrerPolicy',['','same-origin','no-referrer','no-referrer-when-downgrade','origin','origin-when-cross-origin','strict-origin','strict-origin-when-cross-origin','unsafe-url']]]);const IS_FROZEN=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_1__.getOrSetGlobal)('IS_FROZEN',Symbol('FROZEN'));const IS_COLLECTION=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_1__.getOrSetGlobal)('IS_COLLECTION',Symbol.for('Collection'));function freezeHeaders(headers){headers.delete=headers.set=headers.append=()=>{throw new Error(`Cannot Mutate Immutatable Headers, use headers.clone to get a copy`);};upgradeHeaders(headers);return headers;}function deepFreeze(value){if(value&&value[IS_FROZEN]){return value;}const _type=typeof value;switch(_type){case'boolean':case'string':case'number':case'symbol':case'undefined':case'bigint':return value;case'function':throw new Error(`Cannot deep-freeze a function`);case'object':{const _niceType=niceTypeOf(value);switch(_niceType){case'array':{if(value[IS_COLLECTION]){return value;}const arr=value.map(deepFreeze);arr[IS_FROZEN]=true;return Object.freeze(arr);}case'null':return value;case'object':Object.keys(value).forEach(key=>{try{value[key]=deepFreeze(value[key]);}catch{// continue\n}});value[IS_FROZEN]=true;return Object.freeze(value);case'headers':return freezeHeaders(value);case'Collection':case'Store':case'AbortSignal':return value;case'date':case'map':case'set':case'error':case'stream':default:// console.log(`Cannot deep-freeze ${_niceType}`);\nreturn value;}}}}function isMaybeContext(request){if(request&&typeof request==='object'){const keys=Object.keys(request);if(keys.length===1&&keys[0]==='request'){return true;}}return false;}function niceTypeOf(v){if(v===null){return'null';}if(typeof v==='string'){return v?'non-empty-string':'empty-string';}if(!v){return typeof v;}if(Array.isArray(v)){return'array';}if(v instanceof Date){return'date';}if(v instanceof Map){return'map';}if(v instanceof Set){return'set';}if(v instanceof Error){return'error';}if(v instanceof ReadableStream||v instanceof WritableStream||v instanceof TransformStream){return'stream';}if(v instanceof Headers){return'headers';}if(typeof v==='object'&&v.constructor&&v.constructor.name!=='Object'){return v.constructor.name;}return typeof v;}function validateKey(key,value,errors){const schema=ValidKeys.get(key);if(!schema&&!IgnoredKeys.has(key)){errors.push(`InvalidKey: '${key}'`);return;}if(schema){if(schema===BODY_TYPES){if(typeof value==='string'||value instanceof ReadableStream){return;}const type=niceTypeOf(value);if(schema.klass.includes(type)){return;}errors.push(`InvalidValue: key 'body' should be a string or one of '${schema.klass.join(\"', '\")}', received ${'<a value of type '+niceTypeOf(value)+'>'}`);return;}if(Array.isArray(schema)){if(!schema.includes(value)){errors.push(`InvalidValue: key ${key} should be one of '${schema.join(\"', '\")}', received ${typeof value==='string'?value:'<a value of type '+niceTypeOf(value)+'>'}`);}return;}else if(schema==='json'){try{JSON.stringify(value);}catch(e){errors.push(`InvalidValue: key ${key} should be a JSON serializable value, but failed to serialize with Error - ${e.message}`);}return;}else if(schema==='headers'){if(!(value instanceof Headers)){errors.push(`InvalidValue: key ${key} should be an instance of Headers, received ${niceTypeOf(value)}`);}return;}else if(schema==='record'){const _type=typeof value;// record must extend plain object or Object.create(null)\nif(!value||_type!=='object'||value.constructor&&value.constructor!==Object){errors.push(`InvalidValue: key ${key} should be a dictionary of string keys to string values, received ${niceTypeOf(value)}`);return;}const keys=Object.keys(value);keys.forEach(k=>{const v=value[k];if(typeof k!=='string'){errors.push(`\\tThe key ${String(k)} on ${key} should be a string key`);}else if(typeof v!=='string'){errors.push(`\\tThe value of ${key}.${k} should be a string not ${niceTypeOf(v)}`);}});return;}else if(schema==='string'){if(typeof value!=='string'||value.length===0){errors.push(`InvalidValue: key ${key} should be a non-empty string, received ${typeof value==='string'?\"''\":typeof value}`);}return;}else if(schema==='object'){if(!value||Array.isArray(value)||typeof value!=='object'){errors.push(`InvalidValue: key ${key} should be an object`);}return;}else if(schema==='boolean'){if(typeof value!=='boolean'){errors.push(`InvalidValue: key ${key} should be a boolean, received ${typeof value}`);}return;}else if(schema==='array'){if(!Array.isArray(value)){errors.push(`InvalidValue: key ${key} should be an array, received ${typeof value}`);}return;}}}const IgnoredKeys=new Set([]);function assertValidRequest(request,isTopLevel){{// handle basic shape\nif(!request){throw new Error(`Expected ${isTopLevel?'RequestManager.request':'next'}(<request>) to be called with a request, but none was provided.`);}if(Array.isArray(request)||typeof request!=='object'){throw new Error(`The \\`request\\` passed to \\`${isTopLevel?'RequestManager.request':'next'}(<request>)\\` should be an object, received \\`${niceTypeOf(request)}\\``);}if(Object.keys(request).length===0){throw new Error(`The \\`request\\` passed to \\`${isTopLevel?'RequestManager.request':'next'}(<request>)\\` was empty (\\`{}\\`). Requests need at least one valid key.`);}// handle accidentally passing context entirely\nif(request instanceof Context){throw new Error(`Expected a request passed to \\`${isTopLevel?'RequestManager.request':'next'}(<request>)\\` but received the previous handler's context instead`);}// handle Object.assign({}, context);\nif(isMaybeContext(request)){throw new Error(`Expected a request passed to \\`${isTopLevel?'RequestManager.request':'next'}(<request>)\\` but received an object with a request key instead.`);}// handle schema\nconst keys=Object.keys(request);const validationErrors=[];const isLegacyRequest=Boolean('op'in request&&!request.url);keys.forEach(key=>{if(isLegacyRequest&&key==='data'){return;}validateKey(key,request[key],validationErrors);});if(validationErrors.length){const error=new Error(`Invalid Request passed to \\`${isTopLevel?'RequestManager.request':'next'}(<request>)\\`.\\n\\nThe following issues were found:\\n\\n\\t${validationErrors.join('\\n\\t')}`);error.errors=validationErrors;throw error;}}}const PromiseCache=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_1__.getOrSetUniversal)('PromiseCache',new WeakMap());const RequestMap=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_1__.getOrSetUniversal)('RequestMap',new Map());function setRequestResult(requestId,result){RequestMap.set(requestId,result);}function clearRequestResult(requestId){RequestMap.delete(requestId);}function getRequestResult(requestId){return RequestMap.get(requestId);}function setPromiseResult(promise,result){PromiseCache.set(promise,result);}function getPromiseResult(promise){return PromiseCache.get(promise);}const IS_CACHE_HANDLER=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_1__.getOrSetGlobal)('IS_CACHE_HANDLER',Symbol('IS_CACHE_HANDLER'));function curryFuture(owner,inbound,outbound){owner.setStream(inbound.getStream());inbound.then(doc=>{const document={[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.STRUCTURED]:true,request:owner.request,response:doc.response,content:doc.content};outbound.resolve(document);},error=>{if(isDoc(error)){owner.setStream(owner.god.stream);}if(!error||!(error instanceof Error)){try{throw new Error(error?error:`Request Rejected with an Unknown Error`);}catch(e){if(error&&typeof error==='object'){Object.assign(e,error);e.message=error.message||`Request Rejected with an Unknown Error`;}error=e;}}error[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.STRUCTURED]=true;error.request=owner.request;error.response=owner.getResponse();error.error=error.error||error.message;outbound.reject(error);});return outbound.promise;}function isDoc(doc){return doc&&doc[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.STRUCTURED]===true;}function ensureDoc(owner,content,isError){if(isDoc(content)){return content;}if(isError){return{[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.STRUCTURED]:true,request:owner.request,response:owner.getResponse(),error:content};}return{[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.STRUCTURED]:true,request:owner.request,response:owner.getResponse(),content:content};}function enhanceReason(reason){return new DOMException(reason||'The user aborted a request.','AbortError');}function handleOutcome(owner,inbound,outbound){inbound.then(content=>{if(owner.controller.signal.aborted){// the next function did not respect the signal, we handle it here\noutbound.reject(enhanceReason(owner.controller.signal.reason));return;}if(isDoc(content)){owner.setStream(owner.god.stream);content=content.content;}const document={[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.STRUCTURED]:true,request:owner.request,response:owner.getResponse(),content};outbound.resolve(document);},error=>{if(isDoc(error)){owner.setStream(owner.god.stream);}if(!error||!(error instanceof Error)){try{throw new Error(error?error:`Request Rejected with an Unknown Error`);}catch(e){if(error&&typeof error==='object'){Object.assign(e,error);e.message=error.message||`Request Rejected with an Unknown Error`;}error=e;}}error[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.STRUCTURED]=true;error.request=owner.request;error.response=owner.getResponse();error.error=error.error||error.message;outbound.reject(error);});return outbound.promise;}function isCacheHandler(handler,index){return index===0&&Boolean(handler[IS_CACHE_HANDLER]);}function executeNextHandler(wares,request,i,god){{if(i===wares.length){throw new Error(`No handler was able to handle this request.`);}assertValidRequest(request,false);}const owner=new ContextOwner(request,god,i===0);function next(r){owner.nextCalled++;return executeNextHandler(wares,r,i+1,god);}const _isCacheHandler=isCacheHandler(wares[i],i);const context=new Context(owner,_isCacheHandler);let outcome;try{outcome=wares[i].request(context,next);if(_isCacheHandler){context._finalize();}if(!!outcome&&_isCacheHandler){if(!(outcome instanceof Promise)){setRequestResult(owner.requestId,{isError:false,result:ensureDoc(owner,outcome,false)});outcome=Promise.resolve(outcome);}}else{if(!outcome||!(outcome instanceof Promise)&&!(typeof outcome==='object'&&'then'in outcome)){// eslint-disable-next-line no-console\nconsole.log({request,handler:wares[i],outcome});if(outcome===undefined){throw new Error(`Expected handler.request to return a promise, instead received undefined.`);}throw new Error(`Expected handler.request to return a promise, instead received a synchronous value.`);}}}catch(e){if(_isCacheHandler){setRequestResult(owner.requestId,{isError:true,result:ensureDoc(owner,e,true)});}// eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\noutcome=Promise.reject(e);}const future=createFuture(owner);if(isFuture(outcome)){return curryFuture(owner,outcome,future);}return handleOutcome(owner,outcome,future);}function isFuture(maybe){return Boolean(maybe&&maybe instanceof Promise&&maybe[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.IS_FUTURE]===true);}function createDeferred(){let resolve;let reject;const promise=new Promise((res,rej)=>{resolve=res;reject=rej;});return{resolve,reject,promise};}function upgradePromise(promise,future){promise[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.IS_FUTURE]=true;// eslint-disable-next-line @typescript-eslint/unbound-method\npromise.getStream=future.getStream;// eslint-disable-next-line @typescript-eslint/unbound-method\npromise.abort=future.abort;// eslint-disable-next-line @typescript-eslint/unbound-method\npromise.onFinalize=future.onFinalize;promise.id=future.id;promise.lid=future.lid;return promise;}function createFuture(owner){const deferred=createDeferred();let{promise}=deferred;let cbs;promise=promise.finally(()=>{owner.resolveStream();if(cbs){cbs.forEach(cb=>cb());}});promise.onFinalize=fn=>{cbs=cbs||[];cbs.push(fn);};promise[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.IS_FUTURE]=true;promise.getStream=()=>{return owner.getStream();};promise.abort=reason=>{owner.abort(enhanceReason(reason));};promise.id=owner.requestId;promise.lid=owner.god.identifier;deferred.promise=promise;return deferred;}function upgradeHeaders(headers){headers.clone=()=>{return new Headers(headers);};headers.toJSON=()=>{return Array.from(headers);};return headers;}function cloneResponseProperties(response){const{headers,ok,redirected,status,statusText,type,url}=response;upgradeHeaders(headers);return{headers:headers,ok,redirected,status,statusText,type,url};}class ContextOwner{constructor(request,god,isRoot=false){_defineProperty(this,\"hasSetStream\",false);_defineProperty(this,\"hasSetResponse\",false);_defineProperty(this,\"hasSubscribers\",false);_defineProperty(this,\"stream\",createDeferred());_defineProperty(this,\"response\",null);_defineProperty(this,\"nextCalled\",0);this.isRoot=isRoot;this.requestId=god.id;this.controller=request.controller||god.controller;this.stream.promise.sizeHint=0;if(request.controller){if(request.controller!==god.controller){god.controller.signal.addEventListener('abort',()=>{this.controller.abort(god.controller.signal.reason);});}delete request.controller;}let enhancedRequest=Object.assign({signal:this.controller.signal},request);{if(!request?.cacheOptions?.[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.SkipCache]){request=deepFreeze(request);enhancedRequest=deepFreeze(enhancedRequest);}}this.enhancedRequest=enhancedRequest;this.request=request;this.god=god;this.stream.promise=this.stream.promise.then(stream=>{if(this.god.stream===stream&&this.hasSubscribers){this.god.stream=null;}return stream;});}get hasRequestedStream(){return this.god.hasRequestedStream;}getResponse(){if(this.hasSetResponse){return this.response;}if(this.nextCalled===1){return this.god.response;}return null;}getStream(){if(this.isRoot){this.god.hasRequestedStream=true;}if(!this.hasSetResponse){const hint=this.god.response?.headers?.get('content-length');this.stream.promise.sizeHint=hint?parseInt(hint,10):0;}this.hasSubscribers=true;return this.stream.promise;}abort(reason){this.controller.abort(reason);}setStream(stream){if(!this.hasSetStream){this.hasSetStream=true;if(!(stream instanceof Promise)){this.god.stream=stream;}// @ts-expect-error\nthis.stream.resolve(stream);}}resolveStream(){this.setStream(this.nextCalled===1?this.god.stream:null);}setResponse(response){if(this.hasSetResponse){{throw new Error(`Cannot setResponse when a response has already been set`);}// removed by dead control flow\n}this.hasSetResponse=true;if(response instanceof Response){// TODO potentially avoid cloning in prod\nlet responseData=cloneResponseProperties(response);{responseData=deepFreeze(responseData);}this.response=responseData;this.god.response=responseData;const sizeHint=response.headers?.get('content-length');this.stream.promise.sizeHint=sizeHint?parseInt(sizeHint,10):0;}else{this.response=response;this.god.response=response;}}}var _owner=/*#__PURE__*/new WeakMap();class Context{constructor(owner,isCacheHandler){_classPrivateFieldInitSpec(this,_owner,void 0);this.id=owner.requestId;_classPrivateFieldSet(_owner,this,owner);this.request=owner.enhancedRequest;this._isCacheHandler=isCacheHandler;this._finalized=false;}setStream(stream){_classPrivateFieldGet(_owner,this).setStream(stream);}setResponse(response){_classPrivateFieldGet(_owner,this).setResponse(response);}setIdentifier(identifier){(test=>{if(!test){throw new Error(`setIdentifier may only be used synchronously from a CacheHandler`);}})(identifier&&this._isCacheHandler&&!this._finalized);_classPrivateFieldGet(_owner,this).god.identifier=identifier;}get hasRequestedStream(){return _classPrivateFieldGet(_owner,this).hasRequestedStream;}_finalize(){this._finalized=true;}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/context-COmAnXUQ.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/handler-C2T-IyJK.js":
/*!****************************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/handler-C2T-IyJK.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ CacheHandler)\n/* harmony export */ });\n/* harmony import */ var _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./request-state-CjLph1LP.js */ \"./node_modules/@warp-drive/core/dist/request-state-CjLph1LP.js\");\n/* harmony import */ var _types_request_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types/request.js */ \"./node_modules/@warp-drive/core/dist/types/request.js\");\nconst MUTATION_OPS=new Set(['createRecord','updateRecord','deleteRecord']);function calcShouldFetch(store,request,hasCachedValue,identifier){const{cacheOptions}=request;return request.op&&MUTATION_OPS.has(request.op)||cacheOptions?.reload||!hasCachedValue||(store.lifetimes&&identifier?store.lifetimes.isHardExpired(identifier,store):false);}function calcShouldBackgroundFetch(store,request,willFetch,identifier){const{cacheOptions}=request;return cacheOptions?.backgroundReload||(store.lifetimes&&identifier?store.lifetimes.isSoftExpired(identifier,store):false);}function isMutation(request){return Boolean(request.op&&MUTATION_OPS.has(request.op));}function isCacheAffecting(document){if(!isMutation(document.request)){return true;}// a mutation combined with a 204 has no cache impact when no known records were involved\n// a createRecord with a 201 with an empty response and no known records should similarly\n// have no cache impact\nif(document.request.op==='createRecord'&&document.response?.status===201){return document.content?Object.keys(document.content).length>0:false;}return document.response?.status!==204;}function isAggregateError(error){return error instanceof AggregateError||error.name==='AggregateError'&&Array.isArray(error.errors);}// TODO @runspired, consider if we should deep freeze errors (potentially only in debug) vs cloning them\nfunction cloneError(error){const isAggregate=isAggregateError(error);const cloned=isAggregate?new AggregateError(structuredClone(error.errors),error.message):new Error(error.message);cloned.stack=error.stack;cloned.error=error.error;// copy over enumerable properties\nObject.assign(cloned,error);return cloned;}function getPriority(identifier,deduped,priority){if(identifier){const existing=deduped.get(identifier);if(existing){return existing.priority;}}return priority;}/**\n * A CacheHandler that adds support for using an WarpDrive Cache with a RequestManager.\n *\n * This handler will only run when a request has supplied a `store` instance. Requests\n * issued by the store via `store.request()` will automatically have the `store` instance\n * attached to the request.\n *\n * ```ts\n * requestManager.request({\n *   store: store,\n *   url: '/api/posts',\n *   method: 'GET'\n * });\n * ```\n *\n * When this handler elects to handle a request, it will return the raw `StructuredDocument`\n * unless the request has `[EnableHydration]` set to `true`. In this case, the handler will\n * return a `Document` instance that will automatically update the UI when the cache is updated\n * in the future and will hydrate any identifiers in the StructuredDocument into Record instances.\n *\n * When issuing a request via the store, [EnableHydration] is automatically set to `true`. This\n * means that if desired you can issue requests that utilize the cache without needing to also\n * utilize Record instances if desired.\n *\n * Said differently, you could elect to issue all requests via a RequestManager, without ever using\n * the store directly, by setting [EnableHydration] to `true` and providing a store instance. Not\n * necessarily the most useful thing, but the decoupled nature of the RequestManager and incremental-feature\n * approach of WarpDrive allows for this flexibility.\n *\n * ```ts\n * import { EnableHydration } from '@warp-drive/core/types/request';\n *\n * requestManager.request({\n *   store: store,\n *   url: '/api/posts',\n *   method: 'GET',\n *   [EnableHydration]: true\n * });\n *\n */const CacheHandler={request(context,next){// if we have no cache or no cache-key skip cache handling\nif(!context.request.store||context.request.cacheOptions?.[_types_request_js__WEBPACK_IMPORTED_MODULE_1__.SkipCache]){return next(context.request);}const{store}=context.request;const identifier=store.identifierCache.getOrCreateDocumentIdentifier(context.request);if(identifier){context.setIdentifier(identifier);}// used to dedupe existing requests that match\nconst DEDUPE=store.requestManager._deduped;const activeRequest=identifier&&DEDUPE.get(identifier);const peeked=identifier?store.cache.peekRequest(identifier):null;// determine if we should skip cache\nif(calcShouldFetch(store,context.request,!!peeked,identifier)){if(activeRequest){activeRequest.priority={blocking:true};return activeRequest.promise;}let promise=fetchContentAndHydrate(next,context,identifier,{blocking:true});if(identifier){promise=promise.finally(()=>{DEDUPE.delete(identifier);store.notifications.notify(identifier,'state');});DEDUPE.set(identifier,{priority:{blocking:true},promise});store.notifications.notify(identifier,'state');}return promise;}// if we have not skipped cache, determine if we should update behind the scenes\nif(calcShouldBackgroundFetch(store,context.request,false,identifier)){let promise=activeRequest?.promise||fetchContentAndHydrate(next,context,identifier,{blocking:false});if(identifier&&!activeRequest){promise=promise.finally(()=>{DEDUPE.delete(identifier);store.notifications.notify(identifier,'state');});DEDUPE.set(identifier,{priority:{blocking:false},promise});store.notifications.notify(identifier,'state');}store.requestManager._pending.set(context.id,promise);}(test=>{if(!test){throw new Error(`Expected a peeked request to be present`);}})(peeked);const shouldHydrate=context.request[_types_request_js__WEBPACK_IMPORTED_MODULE_1__.EnableHydration]||false;context.setResponse(peeked.response);if('error'in peeked){const content=shouldHydrate?maybeUpdateUiObjects(store,context.request,{shouldHydrate,identifier},peeked.content):peeked.content;const newError=cloneError(peeked);newError.content=content;throw newError;}const result=shouldHydrate?maybeUpdateUiObjects(store,context.request,{shouldHydrate,identifier},peeked.content):peeked.content;return result;}};function maybeUpdateUiObjects(store,request,options,document){const{identifier}=options;if(!document||!options.shouldHydrate){(test=>{if(!test){throw new Error(`The CacheHandler expected response content but none was found`);}})(!options.shouldHydrate);return document??null;}if(identifier){return store._instanceCache.getDocument(identifier);}// if we don't have an identifier, we give the document\n// its own local cache\nreturn new _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.J(store,null,{request,document});}function updateCacheForSuccess(store,request,options,document){let response=null;if(isMutation(request)){const record=request.data?.record||request.records?.[0];if(record){response=store.cache.didCommit(record,document);// a mutation combined with a 204 has no cache impact when no known records were involved\n// a createRecord with a 201 with an empty response and no known records should similarly\n// have no cache impact\n}else if(isCacheAffecting(document)){response=store.cache.put(document);}}else{response=store.cache.put(document);}return maybeUpdateUiObjects(store,request,options,response);}function handleFetchSuccess(store,context,options,document){const{request}=context;store.requestManager._pending.delete(context.id);store._enableAsyncFlush=true;let response;store._join(()=>{response=updateCacheForSuccess(store,request,options,document);});store._enableAsyncFlush=null;if(store.lifetimes?.didRequest){store.lifetimes.didRequest(context.request,document.response,options.identifier,store);}const finalPriority=getPriority(options.identifier,store.requestManager._deduped,options.priority);if(finalPriority.blocking){return response;}else{store.notifications._flush();}}function updateCacheForError(store,context,options,error){let response;if(isMutation(context.request)){// TODO similar to didCommit we should spec this to be similar to cache.put for handling full response\n// currently we let the response remain undefiend.\nconst errors=error&&error.content&&typeof error.content==='object'&&'errors'in error.content&&Array.isArray(error.content.errors)?error.content.errors:undefined;const record=context.request.data?.record||context.request.records?.[0];store.cache.commitWasRejected(record,errors);}else{response=store.cache.put(error);return maybeUpdateUiObjects(store,context.request,options,response);}}function handleFetchError(store,context,options,error){store.requestManager._pending.delete(context.id);if(context.request.signal?.aborted){throw error;}store._enableAsyncFlush=true;let response;store._join(()=>{response=updateCacheForError(store,context,options,error);});store._enableAsyncFlush=null;if(options.identifier&&store.lifetimes?.didRequest){store.lifetimes.didRequest(context.request,error.response,options.identifier,store);}if(isMutation(context.request)){throw error;}const finalPriority=getPriority(options.identifier,store.requestManager._deduped,options.priority);if(finalPriority.blocking){const newError=cloneError(error);newError.content=response;throw newError;}else{store.notifications._flush();}}function fetchContentAndHydrate(next,context,identifier,priority){const{store}=context.request;const shouldHydrate=context.request[_types_request_js__WEBPACK_IMPORTED_MODULE_1__.EnableHydration]||false;const options={shouldHydrate,identifier,priority};let isMut=false;if(isMutation(context.request)){isMut=true;// TODO should we handle multiple records in request.records by iteratively calling willCommit for each\nconst record=context.request.data?.record||context.request.records?.[0];(test=>{if(!test){throw new Error(`Expected to receive a list of records included in the ${context.request.op} request`);}})(record||!shouldHydrate);if(record){store.cache.willCommit(record,context);}}if(store.lifetimes?.willRequest){store.lifetimes.willRequest(context.request,identifier,store);}const promise=next(context.request).then(document=>{return handleFetchSuccess(store,context,options,document);},error=>{return handleFetchError(store,context,options,error);});if(!isMut){return promise;}(test=>{if(!test){throw new Error(`Expected a mutation`);}})(isMutation(context.request));// for mutations we need to enqueue the promise with the requestStateService\n// TODO should we enque a request per record in records?\nconst record=context.request.data?.record||context.request.records?.[0];return store._requestCache._enqueue(promise,{data:[{op:'saveRecord',recordIdentifier:record,options:undefined}]});}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/handler-C2T-IyJK.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CacheHandler: () => (/* reexport safe */ _handler_C2T_IyJK_js__WEBPACK_IMPORTED_MODULE_5__.C),\n/* harmony export */   Fetch: () => (/* binding */ Fetch),\n/* harmony export */   RequestManager: () => (/* binding */ RequestManager),\n/* harmony export */   Store: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_4__.S),\n/* harmony export */   recordIdentifierFor: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_4__.r),\n/* harmony export */   setIdentifierForgetMethod: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_4__.N),\n/* harmony export */   setIdentifierGenerationMethod: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_4__.K),\n/* harmony export */   setIdentifierResetMethod: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_4__.O),\n/* harmony export */   setIdentifierUpdateMethod: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_4__.L),\n/* harmony export */   setKeyInfoForResource: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_4__.P),\n/* harmony export */   storeFor: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_4__.s)\n/* harmony export */ });\n/* harmony import */ var _types_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types/runtime.js */ \"./node_modules/@warp-drive/core/dist/types/runtime.js\");\n/* harmony import */ var _context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context-COmAnXUQ.js */ \"./node_modules/@warp-drive/core/dist/context-COmAnXUQ.js\");\n/* harmony import */ var _configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./configure-B48bFHOl.js */ \"./node_modules/@warp-drive/core/dist/configure-B48bFHOl.js\");\n/* harmony import */ var _types_private_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types/-private.js */ \"./node_modules/@warp-drive/core/dist/types/-private.js\");\n/* harmony import */ var _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./request-state-CjLph1LP.js */ \"./node_modules/@warp-drive/core/dist/request-state-CjLph1LP.js\");\n/* harmony import */ var _handler_C2T_IyJK_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./handler-C2T-IyJK.js */ \"./node_modules/@warp-drive/core/dist/handler-C2T-IyJK.js\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/string.js */ \"./node_modules/@warp-drive/core/dist/utils/string.js\");\nfunction _classPrivateFieldInitSpec(e,t,a){_checkPrivateRedeclaration(e,t),t.set(e,a);}function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError(\"Cannot initialize the same private elements twice on an object\");}function _classPrivateFieldGet(s,a){return s.get(_assertClassBrand(s,a));}function _assertClassBrand(e,t,n){if(\"function\"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError(\"Private element is not present on this object\");}// Lazily close over fetch to avoid breaking Mirage\nconst _fetch=typeof fetch!=='undefined'?(...args)=>fetch(...args):typeof FastBoot!=='undefined'?(...args)=>FastBoot.require('node-fetch')(...args):()=>{throw new Error('No Fetch Implementation Found');};// clones a response in a way that should still\n// allow it to stream\nfunction cloneResponse(response,overrides){const props=(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.a)(response);return new Response(response.body,Object.assign(props,overrides));}let IS_MAYBE_MIRAGE=()=>false;{IS_MAYBE_MIRAGE=()=>Boolean(typeof window!=='undefined'&&(window.server?.pretender||window.fetch.toString().replace(/\\s+/g,'')!=='function fetch() { [native code] }'.replace(/\\s+/g,'')));}const MUTATION_OPS=new Set(['updateRecord','createRecord','deleteRecord']);const ERROR_STATUS_CODE_FOR=new Map([[400,'Bad Request'],[401,'Unauthorized'],[402,'Payment Required'],[403,'Forbidden'],[404,'Not Found'],[405,'Method Not Allowed'],[406,'Not Acceptable'],[407,'Proxy Authentication Required'],[408,'Request Timeout'],[409,'Conflict'],[410,'Gone'],[411,'Length Required'],[412,'Precondition Failed'],[413,'Payload Too Large'],[414,'URI Too Long'],[415,'Unsupported Media Type'],[416,'Range Not Satisfiable'],[417,'Expectation Failed'],[419,'Page Expired'],[420,'Enhance Your Calm'],[421,'Misdirected Request'],[422,'Unprocessable Entity'],[423,'Locked'],[424,'Failed Dependency'],[425,'Too Early'],[426,'Upgrade Required'],[428,'Precondition Required'],[429,'Too Many Requests'],[430,'Request Header Fields Too Large'],[431,'Request Header Fields Too Large'],[450,'Blocked By Windows Parental Controls'],[451,'Unavailable For Legal Reasons'],[500,'Internal Server Error'],[501,'Not Implemented'],[502,'Bad Gateway'],[503,'Service Unavailable'],[504,'Gateway Timeout'],[505,'HTTP Version Not Supported'],[506,'Variant Also Negotiates'],[507,'Insufficient Storage'],[508,'Loop Detected'],[509,'Bandwidth Limit Exceeded'],[510,'Not Extended'],[511,'Network Authentication Required']]);/**\n * ```ts\n * import { Fetch } from '@warp-drive/core';\n * ```\n *\n * A basic Fetch Handler which converts a request into a\n * `fetch` call presuming the response to be `json`.\n *\n * ```ts\n * import { RequestManager, Fetch } from '@warp-drive/core';\n *\n * const manager = new RequestManager()\n *   .use([Fetch]);\n * ```\n *\n * @public\n */const Fetch={async request(context){let response;try{(test=>{if(!test){throw new Error('The Fetch handler expects the request to have a URL, none was provided.');}})(context.request.url&&typeof context.request.url==='string');response=await _fetch(context.request.url,context.request);}catch(e){if(e instanceof DOMException&&e.name==='AbortError'){e.statusText='Aborted';e.status=20;e.isRequestError=true;}else{e.statusText='Unknown Network Error';e.status=0;e.isRequestError=true;}throw e;}const isError=!response.ok||response.status>=400;const op=context.request.op;const isMutationOp=Boolean(op&&MUTATION_OPS.has(op));if(!isError&&!isMutationOp&&response.status!==204&&!response.headers.has('date')){if(IS_MAYBE_MIRAGE()){response.headers.set('date',new Date().toUTCString());}else{const headers=new Headers(response.headers);headers.set('date',new Date().toUTCString());response=cloneResponse(response,{headers});}}context.setResponse(response);if(response.status===204){return null;}let text='';// if we are in a mirage context, we cannot support streaming\nif(IS_MAYBE_MIRAGE()){text=await response.text();}else{const reader=response.body.getReader();const decoder=new TextDecoder();let isStreaming=context.hasRequestedStream;let stream=isStreaming?new TransformStream():null;let writer=stream?.writable.getWriter();if(isStreaming){// Listen for the abort event on the AbortSignal\ncontext.request.signal?.addEventListener('abort',()=>{if(!isStreaming){return;}void stream.writable.abort('Request Aborted');void stream.readable.cancel('Request Aborted');});context.setStream(stream.readable);}while(true){// we manually read the stream instead of using `response.json()`\n// or `response.text()` because if we need to stream the body\n// we need to be able to pass the stream along efficiently.\nconst{done,value}=await reader.read();if(done){if(isStreaming){isStreaming=false;await writer.ready;await writer.close();}break;}text+=decoder.decode(value,{stream:true});// if we are streaming, we want to pass the stream along\nif(isStreaming){await writer.ready;await writer.write(value);}else if(context.hasRequestedStream){const encode=new TextEncoder();isStreaming=true;stream=new TransformStream();// Listen for the abort event on the AbortSignal\n// eslint-disable-next-line @typescript-eslint/no-loop-func\ncontext.request.signal?.addEventListener('abort',()=>{if(!isStreaming){return;}void stream.writable.abort('Request Aborted');void stream.readable.cancel('Request Aborted');});context.setStream(stream.readable);writer=stream.writable.getWriter();await writer.ready;await writer.write(encode.encode(text));await writer.ready;await writer.write(value);}}if(isStreaming){isStreaming=false;await writer.ready;await writer.close();}}// if we are an error, we will want to throw\nif(isError){let errorPayload;try{errorPayload=JSON.parse(text);}catch{// void;\n}// attempt errors discovery\nconst errors=Array.isArray(errorPayload)?errorPayload:isDict(errorPayload)&&Array.isArray(errorPayload.errors)?errorPayload.errors:null;const statusText=response.statusText||ERROR_STATUS_CODE_FOR.get(response.status)||'Unknown Request Error';const msg=`[${response.status} ${statusText}] ${context.request.method??'GET'} (${response.type}) - ${response.url}`;const error=errors?new AggregateError(errors,msg):new Error(msg);error.status=response.status;error.statusText=statusText;error.isRequestError=true;error.code=error.status;error.name=error.statusText.replaceAll(' ','')+'Error';error.content=errorPayload;throw error;}else{return JSON.parse(text);}}};function isDict(v){return v!==null&&typeof v==='object';}var _handlers=/*#__PURE__*/new WeakMap();class RequestManager{/** @internal *//**\n   * A map of pending requests from request.id to their\n   * associated CacheHandler promise.\n   *\n   * This queue is managed by the CacheHandler\n   *\n   * @internal\n   *//** @internal */constructor(options){_classPrivateFieldInitSpec(this,_handlers,[]);Object.assign(this,options);this._pending=new Map();this._deduped=new Map();}/**\n   * Register a handler to use for primary cache intercept.\n   *\n   * Only one such handler may exist. If using the same\n   * RequestManager as the Store instance the Store\n   * registers itself as a Cache handler.\n   *\n   * @public\n   */useCache(cacheHandler){{if(this._hasCacheHandler){throw new Error(`\\`RequestManager.useCache(<handler>)\\` May only be invoked once.`);}if(Object.isFrozen(_classPrivateFieldGet(_handlers,this))){throw new Error(`\\`RequestManager.useCache(<handler>)\\` May only be invoked prior to any request having been made.`);}this._hasCacheHandler=true;}cacheHandler[_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.I]=true;_classPrivateFieldGet(_handlers,this).unshift(cacheHandler);return this;}/**\n   * Register handler(s) to use when a request is issued.\n   *\n   * Handlers will be invoked in the order they are registered.\n   * Each Handler is given the opportunity to handle the request,\n   * curry the request, or pass along a modified request.\n   *\n   * @public\n   * @param {Handler[]} newHandlers\n   * @return {ThisType}\n   */use(newHandlers){const handlers=_classPrivateFieldGet(_handlers,this);{if(Object.isFrozen(handlers)){throw new Error(`Cannot add a Handler to a RequestManager after a request has been made`);}if(!Array.isArray(newHandlers)){throw new Error(`\\`RequestManager.use(<Handler[]>)\\` expects an array of handlers, but was called with \\`${typeof newHandlers}\\``);}newHandlers.forEach((handler,index)=>{if(!handler||typeof handler!=='function'&&typeof handler!=='object'||typeof handler.request!=='function'){throw new Error(`\\`RequestManager.use(<Handler[]>)\\` expected to receive an array of handler objects with request methods, by the handler at index ${index} does not conform.`);}});}handlers.push(...newHandlers);return this;}/**\n   * Issue a Request.\n   *\n   * Returns a Future that fulfills with a StructuredDocument\n   *\n   * @public\n   * @param {RequestInfo} request\n   * @return {Future}\n   */request(request){const handlers=_classPrivateFieldGet(_handlers,this);{if(!Object.isFrozen(handlers)){Object.freeze(handlers);}(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.b)(request,true);}const controller=request.controller||new AbortController();if(request.controller){delete request.controller;}const requestId=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.peekUniversalTransient)('REQ_ID')??0;(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.setUniversalTransient)('REQ_ID',requestId+1);const context={controller,response:null,stream:null,hasRequestedStream:false,id:requestId,identifier:null};const promise=(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.e)(handlers,request,0,context);// the cache handler will set the result of the request synchronously\n// if it is able to fulfill the request from the cache\nconst cacheResult=(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.d)(requestId);{if(!request.disableTestWaiter){const newPromise=(0,_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_2__.w)(promise);const finalPromise=(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.u)(newPromise.then(result=>{(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.s)(finalPromise,{isError:false,result});(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.f)(requestId);return result;},error=>{(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.s)(finalPromise,{isError:true,result:error});(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.f)(requestId);throw error;}),promise);if(cacheResult){(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.s)(finalPromise,cacheResult);}return finalPromise;}}// const promise1 = store.request(myRequest);\n// const promise2 = store.request(myRequest);\n// promise1 === promise2; // false\n// either we need to make promise1 === promise2, or we need to make sure that\n// we need to have a way to key from request to result\n// such that we can lookup the result here and return it if it exists\nconst finalPromise=(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.u)(promise.then(result=>{(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.s)(finalPromise,{isError:false,result});(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.f)(requestId);return result;},error=>{(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.s)(finalPromise,{isError:true,result:error});(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.f)(requestId);throw error;}),promise);if(cacheResult){(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_1__.s)(finalPromise,cacheResult);}return finalPromise;}/**\n   * This method exists so that the RequestManager can be created\n   * can be created by container/factory systems that expect to\n   * call a static `create` method to instantiate the class.\n   *\n   * Using `new RequestManager()` directly is preferred.\n   *\n   * @private\n   */static create(options){return new this(options);}}/**\n * @module\n * @mergeModuleWith <project>\n */// @ts-expect-error adding to globalThis\nglobalThis.setWarpDriveLogging=_types_runtime_js__WEBPACK_IMPORTED_MODULE_0__.setLogging;// @ts-expect-error adding to globalThis\nglobalThis.getWarpDriveRuntimeConfig=_types_runtime_js__WEBPACK_IMPORTED_MODULE_0__.getRuntimeConfig;\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/index.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/request-state-CjLph1LP.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/request-state-CjLph1LP.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ Signals),\n/* harmony export */   B: () => (/* binding */ peekInternalSignal),\n/* harmony export */   C: () => (/* binding */ Collection),\n/* harmony export */   D: () => (/* binding */ DISPOSE),\n/* harmony export */   E: () => (/* binding */ withSignalStore),\n/* harmony export */   F: () => (/* binding */ notifyInternalSignal),\n/* harmony export */   G: () => (/* binding */ consumeInternalSignal),\n/* harmony export */   H: () => (/* binding */ getOrCreateInternalSignal),\n/* harmony export */   I: () => (/* binding */ IdentifierArray),\n/* harmony export */   J: () => (/* binding */ ReactiveDocument),\n/* harmony export */   K: () => (/* binding */ setIdentifierGenerationMethod),\n/* harmony export */   L: () => (/* binding */ setIdentifierUpdateMethod),\n/* harmony export */   M: () => (/* binding */ MUTATE),\n/* harmony export */   N: () => (/* binding */ setIdentifierForgetMethod),\n/* harmony export */   O: () => (/* binding */ setIdentifierResetMethod),\n/* harmony export */   P: () => (/* binding */ setKeyInfoForResource),\n/* harmony export */   Q: () => (/* binding */ isExtensionProp),\n/* harmony export */   R: () => (/* binding */ RecordArrayManager),\n/* harmony export */   S: () => (/* binding */ Store),\n/* harmony export */   T: () => (/* binding */ performExtensionSet),\n/* harmony export */   U: () => (/* binding */ performArrayExtensionGet),\n/* harmony export */   V: () => (/* binding */ performObjectExtensionGet),\n/* harmony export */   _: () => (/* binding */ _clearCaches),\n/* harmony export */   a: () => (/* binding */ isDocumentIdentifier),\n/* harmony export */   b: () => (/* binding */ coerceId),\n/* harmony export */   c: () => (/* binding */ constructResource),\n/* harmony export */   d: () => (/* binding */ SOURCE),\n/* harmony export */   e: () => (/* binding */ ensureStringId),\n/* harmony export */   f: () => (/* binding */ fastPush),\n/* harmony export */   g: () => (/* binding */ removeRecordDataFor),\n/* harmony export */   h: () => (/* binding */ setRecordIdentifier),\n/* harmony export */   i: () => (/* binding */ isStableIdentifier),\n/* harmony export */   j: () => (/* binding */ StoreMap),\n/* harmony export */   k: () => (/* binding */ setCacheFor),\n/* harmony export */   l: () => (/* binding */ RelatedCollection),\n/* harmony export */   m: () => (/* binding */ log),\n/* harmony export */   n: () => (/* binding */ normalizeModelName),\n/* harmony export */   o: () => (/* binding */ logGroup),\n/* harmony export */   p: () => (/* binding */ peekCache),\n/* harmony export */   q: () => (/* binding */ getPromiseState),\n/* harmony export */   r: () => (/* binding */ recordIdentifierFor),\n/* harmony export */   s: () => (/* binding */ storeFor),\n/* harmony export */   t: () => (/* binding */ createRequestSubscription),\n/* harmony export */   u: () => (/* binding */ getRequestState),\n/* harmony export */   v: () => (/* binding */ memoized),\n/* harmony export */   w: () => (/* binding */ gate),\n/* harmony export */   x: () => (/* binding */ entangleSignal),\n/* harmony export */   y: () => (/* binding */ defineSignal),\n/* harmony export */   z: () => (/* binding */ defineNonEnumerableSignal)\n/* harmony export */ });\n/* harmony import */ var _types_request_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types/request.js */ \"./node_modules/@warp-drive/core/dist/types/request.js\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _types_runtime_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types/runtime.js */ \"./node_modules/@warp-drive/core/dist/types/runtime.js\");\n/* harmony import */ var _types_private_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types/-private.js */ \"./node_modules/@warp-drive/core/dist/types/-private.js\");\n/* harmony import */ var _types_identifier_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types/identifier.js */ \"./node_modules/@warp-drive/core/dist/types/identifier.js\");\n/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/string.js */ \"./node_modules/@warp-drive/core/dist/utils/string.js\");\n/* harmony import */ var _configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./configure-B48bFHOl.js */ \"./node_modules/@warp-drive/core/dist/configure-B48bFHOl.js\");\n/* harmony import */ var _context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./context-COmAnXUQ.js */ \"./node_modules/@warp-drive/core/dist/context-COmAnXUQ.js\");\n/* harmony import */ var _embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../@embroider/macros/src/addon/runtime */ \"./node_modules/@embroider/macros/src/addon/runtime.js\");\nvar _RequestSubscription;function _classPrivateFieldInitSpec(e,t,a){_checkPrivateRedeclaration(e,t),t.set(e,a);}function _defineProperty(e,r,t){return(r=_toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\";}function _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}function _classPrivateFieldGet(s,a){return s.get(_assertClassBrand(s,a));}function _classPrivateFieldSet(s,a,r){return s.set(_assertClassBrand(s,a),r),r;}function _classPrivateMethodInitSpec(e,a){_checkPrivateRedeclaration(e,a),a.add(e);}function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError(\"Cannot initialize the same private elements twice on an object\");}function _assertClassBrand(e,t,n){if(\"function\"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError(\"Private element is not present on this object\");}function coerceId(id){{let normalized;if(id===null||id===undefined||id===''){normalized=null;}else{normalized=String(id);}(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`The resource id '<${typeof id}> ${String(id)} ' is not normalized. Update your application code to use '${JSON.stringify(normalized)}' instead.`,normalized===id,{id:'ember-data:deprecate-non-strict-id',until:'6.0',for:'ember-data',since:{available:'4.13',enabled:'5.3'}});return normalized;}// removed by dead control flow\n// removed by dead control flow\n}function ensureStringId(id){let normalized=null;if(typeof id==='string'){normalized=id.length>0?id:null;}else if(typeof id==='number'&&!isNaN(id)){normalized=String(id);}(test=>{if(!test){throw new Error(`Expected id to be a string or number, received ${String(id)}`);}})(normalized!==null);return normalized;}function normalizeModelName(type){{const result=(0,_utils_string_js__WEBPACK_IMPORTED_MODULE_5__.dasherize)(type);(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`The resource type '${type}' is not normalized. Update your application code to use '${result}' instead of '${type}'.`,result===type,{id:'ember-data:deprecate-non-strict-types',until:'6.0',for:'ember-data',since:{available:'4.13',enabled:'5.3'}});return result;}// removed by dead control flow\n}function installPolyfill(){const isFastBoot=typeof FastBoot!=='undefined';const CRYPTO=isFastBoot?FastBoot.require('crypto'):globalThis.crypto;if(!CRYPTO.randomUUID){// we might be able to optimize this by requesting more bytes than we need at a time\nconst rng=function(){// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\nconst rnds8=new Uint8Array(16);if(!CRYPTO.getRandomValues&&!isFastBoot){throw new Error(`Unable to generate bytes for UUID`);}return CRYPTO.getRandomValues?CRYPTO.getRandomValues(rnds8):CRYPTO.randomFillSync(rnds8);};/*\n     * Convert array of 16 byte values to UUID string format of the form:\n     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n     */const byteToHex=[];for(let i=0;i<256;++i){byteToHex[i]=(i+0x100).toString(16).substr(1);}const bytesToUuid=function(buf){const bth=byteToHex;// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\nreturn[bth[buf[0]],bth[buf[1]],bth[buf[2]],bth[buf[3]],'-',bth[buf[4]],bth[buf[5]],'-',bth[buf[6]],bth[buf[7]],'-',bth[buf[8]],bth[buf[9]],'-',bth[buf[10]],bth[buf[11]],bth[buf[12]],bth[buf[13]],bth[buf[14]],bth[buf[15]]].join('');};CRYPTO.randomUUID=function uuidv4(){const rnds=rng();// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\nrnds[6]=rnds[6]&0x0f|0x40;rnds[8]=rnds[8]&0x3f|0x80;return bytesToUuid(rnds);};}}function isResource(resource){return Boolean(resource&&typeof resource==='object');}function hasProp(resource,prop){return Boolean(isResource(resource)&&prop in resource&&typeof resource[prop]==='string'&&resource[prop].length);}function hasLid(resource){return hasProp(resource,'lid');}function hasId(resource){return hasProp(resource,'id')||Boolean(isResource(resource)&&'id'in resource&&typeof resource.id==='number');}function hasType(resource){return hasProp(resource,'type');}const DOCUMENTS=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('DOCUMENTS',new Set());function isStableIdentifier(identifier){return identifier[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.CACHE_OWNER]!==undefined;}function isDocumentIdentifier(identifier){return DOCUMENTS.has(identifier);}const isFastBoot=typeof FastBoot!=='undefined';const _crypto=isFastBoot?FastBoot.require('crypto'):globalThis.crypto;function uuidv4(){(test=>{if(!test){throw new Error('crypto.randomUUID needs to be avaliable. Some browsers incorrectly disallow it in insecure contexts. You maybe want to enable the polyfill: https://github.com/emberjs/data#randomuuid-polyfill');}})(typeof _crypto.randomUUID==='function');return _crypto.randomUUID();}function freeze(obj){if(typeof Object.freeze==='function'){return Object.freeze(obj);}return obj;}// type IdentifierTypeLookup = { all: Set<StableRecordIdentifier>; id: Map<string, StableRecordIdentifier> };\n// type IdentifiersByType = Map<string, IdentifierTypeLookup>;\n/**\n  Configures how unique identifier lid strings are generated by @ember-data/store.\n\n  This configuration MUST occur prior to the store instance being created.\n\n  Takes a method which can expect to receive various data as its first argument\n  and the name of a bucket as its second argument.\n\n  Currently there are two buckets, 'record' and 'document'.\n\n  ### Resource (`Record`) Identity\n\n  If the bucket is `record` the method must return a unique (to at-least\n  the given bucket) string identifier for the given data as a string to be\n  used as the `lid` of an `Identifier` token.\n\n  This method will only be called by either `getOrCreateRecordIdentifier` or\n  `createIdentifierForNewRecord` when an identifier for the supplied data\n  is not already known via `lid` or `type + id` combo and one needs to be\n  generated or retrieved from a proprietary cache.\n\n  `data` will be the same data argument provided to `getOrCreateRecordIdentifier`\n  and in the `createIdentifierForNewRecord` case will be an object with\n  only `type` as a key.\n\n  ```ts\n  import { setIdentifierGenerationMethod } from '@warp-drive/core';\n\n  export function initialize(applicationInstance) {\n    // note how `count` here is now scoped to the application instance\n    // for our generation method by being inside the closure provided\n    // by the initialize function\n    let count = 0;\n\n    setIdentifierGenerationMethod((resource, bucket) => {\n      return resource.lid || `my-key-${count++}`;\n    });\n  }\n\n  export default {\n    name: 'configure-ember-data-identifiers',\n    initialize\n  };\n  ```\n\n  ### Document Identity\n\n  If the bucket is `document` the method will receive the associated\n  immutable `request` passed to `store.request` as its first argument\n  and should return a unique string for the given request if the document\n  should be cached, and `null` if it should not be cached.\n\n  Note, the request result will still be passed to the cache via `Cache.put`,\n  but caches should take this as a signal that the document should not itself\n  be cached, while its contents may still be used to update other cache state.\n\n  The presence of `cacheOptions.key` on the request will take precedence\n  for the document cache key, and this method will not be called if it is\n  present.\n\n  The default method implementation for this bucket is to return `null`\n  for all requests whose method is not `GET`, and to return the `url` for\n  those where it is.\n\n  This means that queries via `POST` MUST provide `cacheOptions.key` or\n  implement this hook.\n\n  ⚠️ Caution: Requests that do not have a `method` assigned are assumed to be `GET`\n\n  @public\n*/function setIdentifierGenerationMethod(method){(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.setTransient)('configuredGenerationMethod',method);}/**\n Configure a callback for when the identifier cache encounters new resource\n data for an existing resource.\n\n This configuration MUST occur prior to the store instance being created.\n\n ```js\n import { setIdentifierUpdateMethod } from '@warp-drive/core';\n ```\n\n Takes a method which can expect to receive an existing `Identifier` alongside\n some new data to consider as a second argument. This is an opportunity\n for secondary lookup tables and caches associated with the identifier\n to be amended.\n\n This method is called everytime `updateRecordIdentifier` is called and\n  with the same arguments. It provides the opportunity to update secondary\n  lookup tables for existing identifiers.\n\n It will always be called after an identifier created with `createIdentifierForNewRecord`\n  has been committed, or after an update to the `record` a `RecordIdentifier`\n  is assigned to has been committed. Committed here meaning that the server\n  has acknowledged the update (for instance after a call to `.save()`)\n\n If `id` has not previously existed, it will be assigned to the `Identifier`\n  prior to this `UpdateMethod` being called; however, calls to the parent method\n  `updateRecordIdentifier` that attempt to change the `id` or calling update\n  without providing an `id` when one is missing will throw an error.\n\n  @public\n*/function setIdentifierUpdateMethod(method){(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.setTransient)('configuredUpdateMethod',method);}/**\n Configure a callback for when the identifier cache is going to release an identifier.\n\n This configuration MUST occur prior to the store instance being created.\n\n ```js\n import { setIdentifierForgetMethod } from '@warp-drive/core';\n ```\n\n Takes method which can expect to receive an existing `Identifier` that should be eliminated\n from any secondary lookup tables or caches that the user has populated for it.\n\n  @public\n*/function setIdentifierForgetMethod(method){(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.setTransient)('configuredForgetMethod',method);}/**\n Configure a callback for when the identifier cache is being torn down.\n\n This configuration MUST occur prior to the store instance being created.\n\n ```js\n import { setIdentifierResetMethod } from '@warp-drive/core';\n ```\n\n Takes a method which can expect to be called when the parent application is destroyed.\n\n If you have properly used a WeakMap to encapsulate the state of your customization\n to the application instance, you may not need to implement the `resetMethod`.\n\n  @public\n*/function setIdentifierResetMethod(method){(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.setTransient)('configuredResetMethod',method);}/**\n Configure a callback for when the identifier cache is generating a new\n StableRecordIdentifier for a resource.\n\n This method controls the `type` and `id` that will be assigned to the\n `StableRecordIdentifier` that is created.\n\n This configuration MUST occur prior to the store instance being created.\n\n ```js\n import { setKeyInfoForResource } from '@warp-drive/core';\n ```\n\n  @public\n */function setKeyInfoForResource(method){(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.setTransient)('configuredKeyInfoMethod',method);}// Map<type, Map<id, lid>>\n// TODO can we just delete this?\nconst NEW_IDENTIFIERS=new Map();// TODO @runspired maybe needs peekTransient ?\nlet IDENTIFIER_CACHE_ID=0;function updateTypeIdMapping(typeMap,identifier,id){let idMap=typeMap.get(identifier.type);if(!idMap){idMap=new Map();typeMap.set(identifier.type,idMap);}idMap.set(id,identifier.lid);}function defaultUpdateMethod(identifier,data,bucket){if(bucket==='record'){(test=>{if(!test){throw new Error(`Expected identifier to be a StableRecordIdentifier`);}})(isStableIdentifier(identifier));if(!identifier.id&&hasId(data)){updateTypeIdMapping(NEW_IDENTIFIERS,identifier,data.id);}}}function defaultKeyInfoMethod(resource,known){// TODO RFC something to make this configurable\nconst id=hasId(resource)?coerceId(resource.id):null;const type=hasType(resource)?normalizeModelName(resource.type):known?known.type:null;(test=>{if(!test){throw new Error(`Expected keyInfoForResource to provide a type for the resource`);}})(type);return{type,id};}function defaultGenerationMethod(data,bucket){if(bucket==='record'){if(hasLid(data)){return data.lid;}(test=>{if(!test){throw new Error(`Cannot generate an identifier for a resource without a type`);}})(hasType(data));if(hasId(data)){const type=normalizeModelName(data.type);const lid=NEW_IDENTIFIERS.get(type)?.get(data.id);return lid||`@lid:${type}-${data.id}`;}return uuidv4();}else if(bucket==='document'){if(!data.url){return null;}if(!data.method||data.method.toUpperCase()==='GET'){return data.url;}return null;}(test=>{{throw new Error(`Unknown bucket ${bucket}`);}})();}function defaultEmptyCallback(...args){}function defaultMergeMethod(a,_b,_c){return a;}let DEBUG_MAP;{DEBUG_MAP=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('DEBUG_MAP',new WeakMap());}/**\n * Each instance of {@link Store} receives a unique instance of a IdentifierCache.\n *\n * This cache is responsible for assigning or retrieving the unique identify\n * for arbitrary resource data encountered by the store. Data representing\n * a unique resource or record should always be represented by the same\n * identifier.\n *\n * It can be configured by consuming applications.\n *\n * @hideconstructor\n * @public\n */class IdentifierCache{/** @internal */constructor(){// we cache the user configuredGenerationMethod at init because it must\n// be configured prior and is not allowed to be changed\nthis._generate=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.peekTransient)('configuredGenerationMethod')||defaultGenerationMethod;this._update=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.peekTransient)('configuredUpdateMethod')||defaultUpdateMethod;this._forget=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.peekTransient)('configuredForgetMethod')||defaultEmptyCallback;this._reset=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.peekTransient)('configuredResetMethod')||defaultEmptyCallback;this._merge=defaultMergeMethod;this._keyInfoForResource=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.peekTransient)('configuredKeyInfoMethod')||defaultKeyInfoMethod;this._id=IDENTIFIER_CACHE_ID++;this._cache={resources:new Map(),resourcesByType:Object.create(null),documents:new Map(),polymorphicLidBackMap:new Map()};}/**\n   * Internal hook to allow management of merge conflicts with identifiers.\n   *\n   * we allow late binding of this private internal merge so that\n   * the cache can insert itself here to handle elimination of duplicates\n   *\n   * @private\n   */__configureMerge(method){this._merge=method||defaultMergeMethod;}/** @internal */upgradeIdentifier(resource){return this._getRecordIdentifier(resource,2);}/**\n   * @private\n   */_getRecordIdentifier(resource,shouldGenerate){{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_IDENTIFIERS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_IDENTIFIERS){// eslint-disable-next-line no-console\nconsole.groupCollapsed(`Identifiers: ${shouldGenerate?'Generating':'Peeking'} Identifier`,resource);}}// short circuit if we're already the stable version\nif(isStableIdentifier(resource)){{// TODO should we instead just treat this case as a new generation skipping the short circuit?\nif(!this._cache.resources.has(resource.lid)||this._cache.resources.get(resource.lid)!==resource){throw new Error(`The supplied identifier ${JSON.stringify(resource)} does not belong to this store instance`);}}{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_IDENTIFIERS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_IDENTIFIERS){// eslint-disable-next-line no-console\nconsole.log(`Identifiers: cache HIT - Stable ${resource.lid}`);// eslint-disable-next-line no-console\nconsole.groupEnd();}}return resource;}// the resource is unknown, ask the application to identify this data for us\nconst lid=this._generate(resource,'record');{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_IDENTIFIERS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_IDENTIFIERS){// eslint-disable-next-line no-console\nconsole.log(`Identifiers: ${lid?'no ':''}lid ${lid?lid+' ':''}determined for resource`,resource);}}let identifier=/*#__NOINLINE__*/getIdentifierFromLid(this._cache,lid,resource);if(identifier!==null){{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_IDENTIFIERS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_IDENTIFIERS){// eslint-disable-next-line no-console\nconsole.groupEnd();}}return identifier;}if(shouldGenerate===0){{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_IDENTIFIERS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_IDENTIFIERS){// eslint-disable-next-line no-console\nconsole.groupEnd();}}return;}// if we still don't have an identifier, time to generate one\nif(shouldGenerate===2){resource.lid=lid;resource[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.CACHE_OWNER]=this._id;identifier=/*#__NOINLINE__*/makeStableRecordIdentifier(resource,'record',false);}else{// we lie a bit here as a memory optimization\nconst keyInfo=this._keyInfoForResource(resource,null);keyInfo.lid=lid;keyInfo[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.CACHE_OWNER]=this._id;identifier=/*#__NOINLINE__*/makeStableRecordIdentifier(keyInfo,'record',false);}addResourceToCache(this._cache,identifier);{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_IDENTIFIERS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_IDENTIFIERS){// eslint-disable-next-line no-console\nconsole.groupEnd();}}return identifier;}/**\n   * allows us to peek without generating when needed\n   * useful for the \"create\" case when we need to see if\n   * we are accidentally overwritting something\n   *\n   * @private\n   */peekRecordIdentifier(resource){return this._getRecordIdentifier(resource,0);}/**\n    Returns the DocumentIdentifier for the given Request, creates one if it does not yet exist.\n    Returns `null` if the request does not have a `cacheKey` or `url`.\n     @public\n  */getOrCreateDocumentIdentifier(request){let cacheKey=request.cacheOptions?.key;if(!cacheKey){cacheKey=this._generate(request,'document');}if(!cacheKey){return null;}let identifier=this._cache.documents.get(cacheKey);if(identifier===undefined){identifier={lid:cacheKey};{Object.freeze(identifier);}DOCUMENTS.add(identifier);this._cache.documents.set(cacheKey,identifier);}return identifier;}/**\n    Returns the Identifier for the given Resource, creates one if it does not yet exist.\n     Specifically this means that we:\n     - validate the `id` `type` and `lid` combo against known identifiers\n    - return an object with an `lid` that is stable (repeated calls with the same\n      `id` + `type` or `lid` will return the same `lid` value)\n    - this referential stability of the object itself is guaranteed\n     @public\n  */getOrCreateRecordIdentifier(resource){return this._getRecordIdentifier(resource,1);}/**\n   Returns a new Identifier for the supplied data. Call this method to generate\n   an identifier when a new resource is being created local to the client and\n   potentially does not have an `id`.\n    Delegates generation to the user supplied `GenerateMethod` if one has been provided\n   with the signature `generateMethod({ type }, 'record')`.\n    @public\n  */createIdentifierForNewRecord(data){const newLid=this._generate(data,'record');const identifier=/*#__NOINLINE__*/makeStableRecordIdentifier({id:data.id||null,type:data.type,lid:newLid,[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.CACHE_OWNER]:this._id},'record',true);// populate our unique table\n{if(this._cache.resources.has(identifier.lid)){throw new Error(`The lid generated for the new record is not unique as it matches an existing identifier`);}}/*#__NOINLINE__*/addResourceToCache(this._cache,identifier);{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_IDENTIFIERS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_IDENTIFIERS){// eslint-disable-next-line no-console\nconsole.log(`Identifiers: created identifier ${String(identifier)} for newly generated resource`,data);}}return identifier;}/**\n   Provides the opportunity to update secondary lookup tables for existing identifiers\n   Called after an identifier created with `createIdentifierForNewRecord` has been\n   committed.\n    Assigned `id` to an `Identifier` if `id` has not previously existed; however,\n   attempting to change the `id` or calling update without providing an `id` when\n   one is missing will throw an error.\n     - sets `id` (if `id` was previously `null`)\n    - `lid` and `type` MUST NOT be altered post creation\n     If a merge occurs, it is possible the returned identifier does not match the originally\n    provided identifier. In this case the abandoned identifier will go through the usual\n    `forgetRecordIdentifier` codepaths.\n     @public\n  */updateRecordIdentifier(identifierObject,data){let identifier=this.getOrCreateRecordIdentifier(identifierObject);const keyInfo=this._keyInfoForResource(data,identifier);let existingIdentifier=/*#__NOINLINE__*/detectMerge(this._cache,keyInfo,identifier,data);const hadLid=hasLid(data);if(!existingIdentifier){// If the incoming type does not match the identifier type, we need to create an identifier for the incoming\n// data so we can merge the incoming data with the existing identifier, see #7325 and #7363\nif(identifier.type!==keyInfo.type){if(hadLid){// Strip the lid to ensure we force a new identifier creation\ndelete data.lid;}existingIdentifier=this.getOrCreateRecordIdentifier(data);}}if(existingIdentifier){const generatedIdentifier=identifier;identifier=this._mergeRecordIdentifiers(keyInfo,generatedIdentifier,existingIdentifier,data);// make sure that the `lid` on the data we are processing matches the lid we kept\nif(hadLid){data.lid=identifier.lid;}{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_IDENTIFIERS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_IDENTIFIERS){// eslint-disable-next-line no-console\nconsole.log(`Identifiers: merged identifiers ${generatedIdentifier.lid} and ${existingIdentifier.lid} for resource into ${identifier.lid}`,data);}}}const id=identifier.id;/*#__NOINLINE__*/performRecordIdentifierUpdate(identifier,keyInfo,data,this._update);const newId=identifier.id;// add to our own secondary lookup table\nif(id!==newId&&newId!==null){{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_IDENTIFIERS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_IDENTIFIERS){// eslint-disable-next-line no-console\nconsole.log(`Identifiers: updated id for identifier ${identifier.lid} from '${String(id)}' to '${String(newId)}' for resource`,data);}}const typeSet=this._cache.resourcesByType[identifier.type];(test=>{if(!test){throw new Error(`Expected to find a typeSet for ${identifier.type}`);}})(typeSet);typeSet.id.set(newId,identifier);if(id!==null){typeSet.id.delete(id);}}else{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_IDENTIFIERS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_IDENTIFIERS){// eslint-disable-next-line no-console\nconsole.log(`Identifiers: updated identifier ${identifier.lid} resource`,data);}}return identifier;}/**\n   * @private\n   */_mergeRecordIdentifiers(keyInfo,identifier,existingIdentifier,data){(test=>{if(!test){throw new Error(`Expected keyInfo to contain an id`);}})(hasId(keyInfo));// delegate determining which identifier to keep to the configured MergeMethod\nconst kept=this._merge(identifier,existingIdentifier,data);const abandoned=kept===identifier?existingIdentifier:identifier;// get any backreferences before forgetting this identifier, as it will be removed from the cache\n// and we will no longer be able to find them\nconst abandonedBackReferences=this._cache.polymorphicLidBackMap.get(abandoned.lid);// delete the backreferences for the abandoned identifier so that forgetRecordIdentifier\n// does not try to remove them.\nif(abandonedBackReferences)this._cache.polymorphicLidBackMap.delete(abandoned.lid);// cleanup the identifier we no longer need\nthis.forgetRecordIdentifier(abandoned);// ensure a secondary cache entry for the original lid for the abandoned identifier\nthis._cache.resources.set(abandoned.lid,kept);// backReferences let us know which other identifiers are pointing at this identifier\n// so we can delete them later if we forget this identifier\nconst keptBackReferences=this._cache.polymorphicLidBackMap.get(kept.lid)??[];keptBackReferences.push(abandoned.lid);// update the backreferences from the abandoned identifier to be for the kept identifier\nif(abandonedBackReferences){abandonedBackReferences.forEach(lid=>{keptBackReferences.push(lid);this._cache.resources.set(lid,kept);});}this._cache.polymorphicLidBackMap.set(kept.lid,keptBackReferences);return kept;}/**\n   Provides the opportunity to eliminate an identifier from secondary lookup tables\n   as well as eliminates it from ember-data's own lookup tables and book keeping.\n    Useful when a record has been deleted and the deletion has been persisted and\n   we do not care about the record anymore. Especially useful when an `id` of a\n   deleted record might be reused later for a new record.\n    @public\n  */forgetRecordIdentifier(identifierObject){const identifier=this.getOrCreateRecordIdentifier(identifierObject);const typeSet=this._cache.resourcesByType[identifier.type];(test=>{if(!test){throw new Error(`Expected to find a typeSet for ${identifier.type}`);}})(typeSet);if(identifier.id!==null){typeSet.id.delete(identifier.id);}this._cache.resources.delete(identifier.lid);typeSet.lid.delete(identifier.lid);const backReferences=this._cache.polymorphicLidBackMap.get(identifier.lid);if(backReferences){backReferences.forEach(lid=>{this._cache.resources.delete(lid);});this._cache.polymorphicLidBackMap.delete(identifier.lid);}{identifier[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.DEBUG_STALE_CACHE_OWNER]=identifier[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.CACHE_OWNER];}identifier[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.CACHE_OWNER]=undefined;this._forget(identifier,'record');{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_IDENTIFIERS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_IDENTIFIERS){// eslint-disable-next-line no-console\nconsole.log(`Identifiers: released identifier ${identifierObject.lid}`);}}}/** @internal */destroy(){NEW_IDENTIFIERS.clear();this._cache.documents.forEach(identifier=>{DOCUMENTS.delete(identifier);});this._reset();}}function makeStableRecordIdentifier(recordIdentifier,bucket,clientOriginated){{// we enforce immutability in dev\n//  but preserve our ability to do controlled updates to the reference\nlet wrapper={type:recordIdentifier.type,lid:recordIdentifier.lid,get id(){return recordIdentifier.id;}};const proto={get[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.CACHE_OWNER](){return recordIdentifier[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.CACHE_OWNER];},set[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.CACHE_OWNER](value){recordIdentifier[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.CACHE_OWNER]=value;},get[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.DEBUG_STALE_CACHE_OWNER](){return recordIdentifier[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.DEBUG_STALE_CACHE_OWNER];},set[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.DEBUG_STALE_CACHE_OWNER](value){recordIdentifier[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.DEBUG_STALE_CACHE_OWNER]=value;},get[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.DEBUG_CLIENT_ORIGINATED](){return clientOriginated;},get[_types_identifier_js__WEBPACK_IMPORTED_MODULE_4__.DEBUG_IDENTIFIER_BUCKET](){return bucket;}};Object.defineProperty(proto,'toString',{enumerable:false,value:()=>{const{type,id,lid}=recordIdentifier;return`${clientOriginated?'[CLIENT_ORIGINATED] ':''}${String(type)}:${String(id)} (${lid})`;}});Object.defineProperty(proto,'toJSON',{enumerable:false,value:()=>{const{type,id,lid}=recordIdentifier;return{type,id,lid};}});Object.setPrototypeOf(wrapper,proto);DEBUG_MAP.set(wrapper,recordIdentifier);wrapper=freeze(wrapper);return wrapper;}// removed by dead control flow\n}function performRecordIdentifierUpdate(identifier,keyInfo,data,updateFn){{const{id,type}=keyInfo;// get the mutable instance behind our proxy wrapper\nconst wrapper=identifier;identifier=DEBUG_MAP.get(wrapper);if(hasLid(data)){const lid=data.lid;if(lid!==identifier.lid){throw new Error(`The 'lid' for a RecordIdentifier cannot be updated once it has been created. Attempted to set lid for '${wrapper.lid}' to '${lid}'.`);}}if(id&&identifier.id!==null&&identifier.id!==id){// here we warn and ignore, as this may be a mistake, but we allow the user\n// to have multiple cache-keys pointing at a single lid so we cannot error\n(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.warn)(`The 'id' for a RecordIdentifier should not be updated once it has been set. Attempted to set id for '${wrapper.lid}' to '${id}'.`,false,{id:'ember-data:multiple-ids-for-identifier'});}// TODO consider just ignoring here to allow flexible polymorphic support\nif(type&&type!==identifier.type){throw new Error(`The 'type' for a RecordIdentifier cannot be updated once it has been set. Attempted to set type for '${wrapper.lid}' to '${type}'.`);}updateFn(wrapper,data,'record');}// upgrade the ID, this is a \"one time only\" ability\n// for the multiple-cache-key scenario we \"could\"\n// use a heuristic to guess the best id for display\n// (usually when `data.id` is available and `data.attributes` is not)\nif(data.id!==undefined){identifier.id=coerceId(data.id);}}function detectMerge(cache,keyInfo,identifier,data){const newId=keyInfo.id;const{id,type,lid}=identifier;const typeSet=cache.resourcesByType[identifier.type];// if the IDs are present but do not match\n// then check if we have an existing identifier\n// for the newer ID.\nif(id!==null&&id!==newId&&newId!==null){const existingIdentifier=typeSet&&typeSet.id.get(newId);return existingIdentifier!==undefined?existingIdentifier:false;}else{const newType=keyInfo.type;// If the ids and type are the same but lid is not the same, we should trigger a merge of the identifiers\n// we trigger a merge of the identifiers\n// though probably we should just throw an error here\nif(id!==null&&id===newId&&newType===type&&hasLid(data)&&data.lid!==lid){return getIdentifierFromLid(cache,data.lid,data)||false;// If the lids are the same, and ids are the same, but types are different we should trigger a merge of the identifiers\n}else if(id!==null&&id===newId&&newType&&newType!==type&&hasLid(data)&&data.lid===lid){const newTypeSet=cache.resourcesByType[newType];const existingIdentifier=newTypeSet&&newTypeSet.id.get(newId);return existingIdentifier!==undefined?existingIdentifier:false;}}return false;}function getIdentifierFromLid(cache,lid,resource){const identifier=cache.resources.get(lid);{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_IDENTIFIERS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_IDENTIFIERS){// eslint-disable-next-line no-console\nconsole.log(`Identifiers: cache ${identifier?'HIT':'MISS'} - Non-Stable ${lid}`,resource);}}return identifier||null;}function addResourceToCache(cache,identifier){cache.resources.set(identifier.lid,identifier);let typeSet=cache.resourcesByType[identifier.type];if(!typeSet){typeSet={lid:new Map(),id:new Map()};cache.resourcesByType[identifier.type]=typeSet;}typeSet.lid.set(identifier.lid,identifier);if(identifier.id){typeSet.id.set(identifier.id,identifier);}}/**\n * A WarpDriveSignal is a wrapper around a framework specific or TC39 signal\n * that enables us to store and manage the signal in a universal way.\n *\n * WarpDrive uses signals to manage three separate concepts:\n *\n * - as a `storage` for a value local to the object that we want to be reactive\n *   (see `@local` schema field for an example)\n * - as a `gate` for a memoized getter that we want to act as a reactive property\n *   but whose value is computed/pulled from a non-reactive source elsewhere\n *   and whose latest value is stored in the signal\n *   (see `field` schema field for an example)\n * - as a `gate` with a manually managed value updated on pull when `isStale` is true\n *\n *\n * It offers\n *\n * - a non-reactive way to access/update the current value\n * - a non-reactive way to mark the signal as dirtied\n * - a non-reactive way to store content for why the signal was dirtied\n * - access to the underlying Signal(s) in-use\n *\n * For debugging:\n * - the \"key\" or \"name\" of the signal\n * - the \"object identity\" or \"context\" to which the signal is attached\n *\n * @internal\n *//**\n * We attach signals to their context object via\n * a Map attached to the object via this symbol.\n *\n * This allows us to store multiple signals\n * on the same object with smaller memory\n * overhead and no WeakMap lookups.\n *\n * Performance sensitive objects should\n * pre-warm their shape by assigning this\n * during initialization.\n *\n * ```ts\n * initializeSignalStore(obj);\n * ```\n *\n * @internal\n */const Signals=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('Signals',Symbol('Signals'));/**\n * A util that will create a signal store on the object\n * if it does not already exist and returns the associated\n * signal store.\n *\n * @internal\n */function withSignalStore(obj){if(obj[Signals]===undefined){initializeSignalStore(obj);}return obj[Signals];}/**\n * A util that will create a signal store on the object\n * if it does not already exist.\n *\n * Useful for pre-warming the shape of an object to ensure\n * a key-transition to add it is not required later.\n *\n * @internal\n */function initializeSignalStore(obj){(test=>{if(!test){throw new Error(`Signal store already exists on object`);}})(obj[Signals]===undefined);obj[Signals]=new Map();}function createInternalSignal(signals,obj,key,initialValue){const warpDriveSignal={key,context:obj,signal:(0,_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__.a)(obj,key),value:initialValue,isStale:false};signals.set(key,warpDriveSignal);return warpDriveSignal;}function getOrCreateInternalSignal(signals,obj,key,initialValue){let signal=peekInternalSignal(signals,key);if(!signal){signal=createInternalSignal(signals,obj,key,initialValue);}return signal;}function peekInternalSignal(signals,key){return signals?.get(key);}function consumeInternalSignal(signal){(0,_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__.b)(signal.signal);}function notifyInternalSignal(signal){if(signal){signal.isStale=true;(0,_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__.n)(signal.signal);}}function entangleSignal(signals,obj,key,initialValue){let signal=peekInternalSignal(signals,key);if(!signal){signal=createInternalSignal(signals,obj,key,initialValue);}consumeInternalSignal(signal);return signal;}function createSignalDescriptor(key,intialValue){return{enumerable:true,configurable:false,get(){const signals=withSignalStore(this);return entangleSignal(signals,this,key,intialValue).value;},set(value){const signals=withSignalStore(this);const signal=getOrCreateInternalSignal(signals,this,key,intialValue);if(signal.value!==value){signal.value=value;notifyInternalSignal(signal);}}};}/**\n * define an enumerable signal property.\n *\n * Akin to Object.defineProperty.\n *\n * The signal will be lazily created when accessed and scoped to the\n * instance of the object.\n *\n * @internal\n */function defineSignal(obj,key,v){Object.defineProperty(obj,key,createSignalDescriptor(key,v));}/**\n * Define a non-enumerable signal property.\n *\n * @internal\n */function defineNonEnumerableSignal(obj,key,v){const desc=createSignalDescriptor(key,v);desc.enumerable=false;Object.defineProperty(obj,key,desc);}function memoized(target,key,descriptor){// Error on `@memoized()`, `@memoized(...args)`, and `@memoized propName = value;`\n(test=>{if(!test){throw new Error('You attempted to use @memoized(), which is not necessary nor supported. Remove the parentheses and you will be good to go!');}})(target!==undefined);(test=>{if(!test){throw new Error(`You attempted to use @memoized on with ${arguments.length>1?'arguments':'an argument'} ( @memoized(${Array.from(arguments).map(d=>`'${d}'`).join(', ')}), which is not supported. Dependencies are automatically tracked, so you can just use ${'`@memoized`'}`);}})(typeof target==='object'&&typeof key==='string'&&typeof descriptor==='object'&&arguments.length===3);(test=>{if(!test){throw new Error(`The @memoized decorator must be applied to getters. '${key}' is not a getter.`);}})(typeof descriptor.get==='function');// eslint-disable-next-line @typescript-eslint/unbound-method\nconst getter=descriptor.get;descriptor.get=function(){const signals=withSignalStore(this);let memoSignal=signals.get(key);if(!memoSignal){memoSignal=(0,_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__.c)(this,key,getter.bind(this));signals.set(key,memoSignal);}return memoSignal();};return descriptor;}function gate(_target,key,desc){// eslint-disable-next-line @typescript-eslint/unbound-method\nconst getter=desc.get;// eslint-disable-next-line @typescript-eslint/unbound-method\nconst setter=desc.set;desc.get=function(){const signals=withSignalStore(this);let signal=peekInternalSignal(signals,key);if(!signal){signal=createInternalSignal(signals,this,key,getter.call(this));}else if(signal.isStale){signal.isStale=false;signal.value=getter.call(this);}consumeInternalSignal(signal);return signal.value;};if(setter){desc.set=function(v){const signals=withSignalStore(this);let signal=peekInternalSignal(signals,key);if(!signal){// we can't use `v` as initialValue here because setters don't\n// return the value and the final value may be different\n// than what the setter was called with.\nsignal=createInternalSignal(signals,this,key,undefined);signal.isStale=true;}setter.call(this,v);// when a gate is set, we do not notify the signal\n// as its update is controlled externally.\n};}return desc;}function defineGate(obj,key,desc){const options=Object.assign({enumerable:true,configurable:false},gate(obj,key,desc));Object.defineProperty(obj,key,options);}function urlFromLink(link){if(typeof link==='string')return link;return link.href;}/**\n * A Document is a class that wraps the response content from a request to the API\n * returned by `Cache.put` or `Cache.peek`, converting resource-identifiers into\n * record instances.\n *\n * It is not directly instantiated by the user, and its properties should not\n * be directly modified. Whether individual properties are mutable or not is\n * determined by the record instance itself.\n *\n * @public\n * @hideconstructor\n */var _ReactiveDocument_brand=/*#__PURE__*/new WeakSet();class ReactiveDocument{/**\n   * The links object for this document, if any\n   *\n   * e.g.\n   *\n   * ```\n   * {\n   *   self: '/articles?page[number]=3',\n   * }\n   * ```\n   *\n   * @property links\n   * @type {Object|undefined} - a links object\n   * @public\n   *//**\n   * The primary data for this document, if any.\n   *\n   * If this document has no primary data (e.g. because it is an error document)\n   * this property will be `undefined`.\n   *\n   * For collections this will be an array of record instances,\n   * for single resource requests it will be a single record instance or null.\n   *\n   * @property data\n   * @public\n   * @type {Object|Array<object>|null|undefined} - a data object\n   *//**\n   * The errors returned by the API for this request, if any\n   *\n   * @property errors\n   * @public\n   * @type {Object|undefined} - an errors object\n   *//**\n   * The meta object for this document, if any\n   *\n   * @property meta\n   * @public\n   * @type {Object|undefined} - a meta object\n   *//**\n   * The identifier associated with this document, if any\n   *\n   * @property identifier\n   * @public\n   * @type {StableDocumentIdentifier|null}\n   */constructor(store,identifier,localCache){_classPrivateMethodInitSpec(this,_ReactiveDocument_brand);this._store=store;this._localCache=localCache;this.identifier=identifier;const signals=withSignalStore(this);// TODO if we ever enable auto-cleanup of the cache, we will need to tear this down\n// in a destroy method\nif(identifier){store.notifications.subscribe(identifier,(_identifier,type)=>{switch(type){case'updated':// FIXME in the case of a collection we need to notify it's length\n// and have it recalc\nnotifyInternalSignal(peekInternalSignal(signals,'data'));notifyInternalSignal(peekInternalSignal(signals,'links'));notifyInternalSignal(peekInternalSignal(signals,'meta'));notifyInternalSignal(peekInternalSignal(signals,'errors'));break;}});}}/**\n   * Fetches the related link for this document, returning a promise that resolves\n   * with the document when the request completes. If no related link is present,\n   * will fallback to the self link if present\n   *\n   * @public\n   * @param {Object} options\n   * @return {Promise<Document>}\n   */fetch(options=(0,_types_request_js__WEBPACK_IMPORTED_MODULE_0__.withBrand)({url:'',method:'GET'})){(test=>{if(!test){throw new Error(`No self or related link`);}})(this.links?.related||this.links?.self);options.cacheOptions=options.cacheOptions||{};options.cacheOptions.key=this.identifier?.lid;return _assertClassBrand(_ReactiveDocument_brand,this,_request).call(this,this.links.related?'related':'self',options);}/**\n   * Fetches the next link for this document, returning a promise that resolves\n   * with the new document when the request completes, or null  if there is no\n   * next link.\n   *\n   * @public\n   * @param {Object} options\n   * @return {Promise<Document | null>}\n   */next(options){return _assertClassBrand(_ReactiveDocument_brand,this,_request).call(this,'next',options);}/**\n   * Fetches the prev link for this document, returning a promise that resolves\n   * with the new document when the request completes, or null if there is no\n   * prev link.\n   *\n   * @public\n   * @param {Object} options\n   * @return {Promise<Document | null>}\n   */prev(options){return _assertClassBrand(_ReactiveDocument_brand,this,_request).call(this,'prev',options);}/**\n   * Fetches the first link for this document, returning a promise that resolves\n   * with the new document when the request completes, or null if there is no\n   * first link.\n   *\n   * @public\n   * @param {Object} options\n   * @return {Promise<Document | null>}\n   */first(options){return _assertClassBrand(_ReactiveDocument_brand,this,_request).call(this,'first',options);}/**\n   * Fetches the last link for this document, returning a promise that resolves\n   * with the new document when the request completes, or null if there is no\n   * last link.\n   *\n   * @public\n   * @param {Object} options\n   * @return {Promise<Document | null>}\n   */last(options){return _assertClassBrand(_ReactiveDocument_brand,this,_request).call(this,'last',options);}/**\n   * Implemented for `JSON.stringify` support.\n   *\n   * Returns the JSON representation of the document wrapper.\n   *\n   * This is a shallow serialization, it does not deeply serialize\n   * the document's contents, leaving that to the individual record\n   * instances to determine how to do, if at all.\n   *\n   * @public\n   * @return\n   */toJSON(){const data={};data.identifier=this.identifier;if(this.data!==undefined){data.data=this.data;}if(this.links!==undefined){data.links=this.links;}if(this.errors!==undefined){data.errors=this.errors;}if(this.meta!==undefined){data.meta=this.meta;}return data;}}async function _request(link,options=(0,_types_request_js__WEBPACK_IMPORTED_MODULE_0__.withBrand)({url:'',method:'GET'})){const href=this.links?.[link];if(!href){return null;}options.method=options.method||'GET';Object.assign(options,{url:urlFromLink(href)});const response=await this._store.request(options);return response.content;}defineGate(ReactiveDocument.prototype,'errors',{get(){const{identifier}=this;if(!identifier){const{document}=this._localCache;if('errors'in document){return document.errors;}return;}const doc=this._store.cache.peek(identifier);(test=>{if(!test){throw new Error(`No cache data was found for the document '${identifier.lid}'`);}})(doc);return'errors'in doc?doc.errors:undefined;}});defineGate(ReactiveDocument.prototype,'data',{get(){const{identifier,_localCache}=this;const doc=identifier?this._store.cache.peek(identifier):_localCache.document;(test=>{if(!test){throw new Error(`No cache data was found for the document '${identifier?.lid??'<uncached document>'}'`);}})(doc);const data='data'in doc?doc.data:undefined;if(Array.isArray(data)){return this._store.recordArrayManager.getCollection({type:identifier?identifier.lid:_localCache.request.url,identifiers:data.slice(),doc:identifier?undefined:doc,identifier:identifier??null});}else if(data){return this._store.peekRecord(data);}else{return data;}}});defineGate(ReactiveDocument.prototype,'links',{get(){const{identifier}=this;if(!identifier){return this._localCache.document.links;}const data=this._store.cache.peek(identifier);(test=>{if(!test){throw new Error(`No cache data was found for the document '${identifier.lid}'`);}})(data);return data.links;}});defineGate(ReactiveDocument.prototype,'meta',{get(){const{identifier}=this;if(!identifier){return this._localCache.document.meta;}const data=this._store.cache.peek(identifier);(test=>{if(!test){throw new Error(`No cache data was found for the document '${identifier.lid}'`);}})(data);return data.meta;}});const TEXT_COLORS={TEXT:'inherit',notify:['white','white','inherit','magenta','inherit'],'reactive-ui':['white','white','inherit','magenta','inherit'],graph:['white','white','inherit','magenta','inherit'],request:['white','white','inherit','magenta','inherit'],cache:['white','white','inherit','magenta','inherit']};const BG_COLORS={TEXT:'transparent',notify:['dimgray','cadetblue','transparent','transparent','transparent'],'reactive-ui':['dimgray','cadetblue','transparent','transparent','transparent'],graph:['dimgray','cadetblue','transparent','transparent','transparent'],request:['dimgray','cadetblue','transparent','transparent','transparent'],cache:['dimgray','cadetblue','transparent','transparent','transparent']};const NOTIFY_BORDER={TEXT:0,notify:[3,2,0,0,0],'reactive-ui':[3,2,0,0,0],graph:[3,2,0,0,0],request:[3,2,0,0,0],cache:[3,2,0,0,0]};const LIGHT_DARK_ALT={lightgreen:'green',green:'lightgreen'};function badge(isLight,color,bgColor,border){return[`color: ${correctColor(isLight,color)}; background-color: ${correctColor(isLight,bgColor)}; padding: ${border}px ${2*border}px; border-radius: ${border}px;`,`color: ${TEXT_COLORS.TEXT}; background-color: ${BG_COLORS.TEXT};`];}function colorForBucket(isLight,scope,bucket){if(scope==='notify'){return bucket==='added'?badge(isLight,'lightgreen','transparent',0):bucket==='removed'?badge(isLight,'red','transparent',0):badge(isLight,TEXT_COLORS[scope][2],BG_COLORS[scope][2],NOTIFY_BORDER[scope][2]);}if(scope==='reactive-ui'){return bucket==='created'?badge(isLight,'lightgreen','transparent',0):bucket==='disconnected'?badge(isLight,'red','transparent',0):badge(isLight,TEXT_COLORS[scope][2],BG_COLORS[scope][2],NOTIFY_BORDER[scope][2]);}if(scope==='cache'){return bucket==='inserted'?badge(isLight,'lightgreen','transparent',0):bucket==='removed'?badge(isLight,'red','transparent',0):badge(isLight,TEXT_COLORS[scope][2],BG_COLORS[scope][2],NOTIFY_BORDER[scope][2]);}return badge(isLight,TEXT_COLORS[scope][3],BG_COLORS[scope][3],NOTIFY_BORDER[scope][3]);}function logGroup(scope,prefix,subScop1,subScop2,subScop3,subScop4){// eslint-disable-next-line no-console\nconsole.groupCollapsed(..._log(scope,prefix,subScop1,subScop2,subScop3,subScop4));}function log(scope,prefix,subScop1,subScop2,subScop3,subScop4){// eslint-disable-next-line no-console\nconsole.log(..._log(scope,prefix,subScop1,subScop2,subScop3,subScop4));}function correctColor(isLight,color){if(!isLight){return color;}return color in LIGHT_DARK_ALT?LIGHT_DARK_ALT[color]:color;}function isLightMode(){if(window?.matchMedia?.('(prefers-color-scheme: light)').matches){return true;}return false;}function _log(scope,prefix,subScop1,subScop2,subScop3,subScop4){const isLight=isLightMode();switch(scope){case'reactive-ui':case'notify':{const scopePath=prefix?`[${prefix}] ${scope}`:scope;const path=subScop4?`${subScop3}.${subScop4}`:subScop3;return[`%c@warp%c-%cdrive%c %c${scopePath}%c %c${subScop1}%c %c${subScop2}%c %c${path}%c`,...badge(isLight,'lightgreen','transparent',0),...badge(isLight,'magenta','transparent',0),...badge(isLight,TEXT_COLORS[scope][0],BG_COLORS[scope][0],NOTIFY_BORDER[scope][0]),...badge(isLight,TEXT_COLORS[scope][1],BG_COLORS[scope][1],NOTIFY_BORDER[scope][1]),...badge(isLight,TEXT_COLORS[scope][2],BG_COLORS[scope][2],NOTIFY_BORDER[scope][2]),...colorForBucket(isLight,scope,path)];}case'cache':{const scopePath=prefix?`${scope} (${prefix})`:scope;return[`%c@warp%c-%cdrive%c %c${scopePath}%c %c${subScop1}%c %c${subScop2}%c %c${subScop3}%c %c${subScop4}%c`,...badge(isLight,'lightgreen','transparent',0),...badge(isLight,'magenta','transparent',0),...badge(isLight,TEXT_COLORS[scope][0],BG_COLORS[scope][0],NOTIFY_BORDER[scope][0]),...badge(isLight,TEXT_COLORS[scope][1],BG_COLORS[scope][1],NOTIFY_BORDER[scope][1]),...badge(isLight,TEXT_COLORS[scope][2],BG_COLORS[scope][2],NOTIFY_BORDER[scope][2]),...colorForBucket(isLight,scope,subScop3),...badge(isLight,TEXT_COLORS[scope][4],BG_COLORS[scope][4],NOTIFY_BORDER[scope][4])];}}return[];}/**\n   A `RecordReference` is a low-level API that allows users and\n   addon authors to perform meta-operations on a record.\n\n   @hideconstructor\n   @public\n*/class RecordReference{// unsubscribe token given to us by the notification manager\nconstructor(store,identifier){this.store=store;this.___identifier=identifier;this.___token=store.notifications.subscribe(identifier,(_,bucket,notifiedKey)=>{if(bucket==='identity'||bucket==='attributes'&&notifiedKey==='id'){this._ref++;}});}/** @internal */destroy(){this.store.notifications.unsubscribe(this.___token);}get type(){return this.identifier().type;}/**\n     The `id` of the record that this reference refers to.\n      Together, the `type` and `id` properties form a composite key for\n     the identity map.\n      Example\n      ```javascript\n     let userRef = store.getReference('user', 1);\n      userRef.id(); // '1'\n     ```\n     @public\n  */id(){// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nthis._ref;// consume the tracked prop\nreturn this.___identifier.id;}/**\n     The `identifier` of the record that this reference refers to.\n      Together, the `type` and `id` properties form a composite key for\n     the identity map.\n      Example\n      ```javascript\n     let userRef = store.getReference('user', 1);\n      userRef.identifier(); // '1'\n     ```\n     @public\n  */identifier(){return this.___identifier;}/**\n     How the reference will be looked up when it is loaded. Currently\n     this always returns `identity` to signify that a record will be\n     loaded by its `type` and `id`.\n      Example\n      ```javascript\n     const userRef = store.getReference('user', 1);\n      userRef.remoteType(); // 'identity'\n     ```\n      @public\n  */remoteType(){return'identity';}/**\n    This API allows you to provide a reference with new data. The\n    simplest usage of this API is similar to `store.push`: you provide a\n    normalized hash of data and the object represented by the reference\n    will update.\n     If you pass a promise to `push`, Ember Data will not ask the adapter\n    for the data if another attempt to fetch it is made in the\n    interim. When the promise resolves, the underlying object is updated\n    with the new data, and the promise returned by *this function* is resolved\n    with that object.\n     For example, `recordReference.push(promise)` will be resolved with a\n    record.\n      Example\n      ```javascript\n     let userRef = store.getReference('user', 1);\n      // provide data for reference\n     userRef.push({\n       data: {\n         id: \"1\",\n         type: \"user\",\n         attributes: {\n           username: \"@user\"\n         }\n       }\n     }).then(function(user) {\n       userRef.value() === user;\n     });\n     ```\n     @public\n    @param objectOrPromise a JSON:API ResourceDocument or a promise resolving to one\n    @return a promise for the value (record or relationship)\n  */push(objectOrPromise){// TODO @deprecate pushing unresolved payloads\nreturn Promise.resolve(objectOrPromise).then(data=>{return this.store.push(data);});}/**\n    If the entity referred to by the reference is already loaded, it is\n    present as `reference.value`. Otherwise the value returned by this function\n    is `null`.\n      Example\n      ```javascript\n     let userRef = store.getReference('user', 1);\n      userRef.value(); // user\n     ```\n     @public\n  */value(){return this.store.peekRecord(this.___identifier);}/**\n     Triggers a fetch for the backing entity based on its `remoteType`\n     (see `remoteType` definitions per reference type).\n      Example\n      ```javascript\n     let userRef = store.getReference('user', 1);\n      // load user (via store.find)\n     userRef.load().then(...)\n     ```\n     @public\n  */load(){const id=this.id();if(id!==null){return this.store.findRecord(this.type,id);}(test=>{{throw new Error(`Unable to fetch record of type ${this.type} without an id`);}})();}/**\n     Reloads the record if it is already loaded. If the record is not\n     loaded it will load the record via `store.findRecord`\n      Example\n      ```javascript\n     let userRef = store.getReference('user', 1);\n      // or trigger a reload\n     userRef.reload().then(...)\n     ```\n     @public\n  */reload(){const id=this.id();if(id!==null){return this.store.findRecord(this.type,id,{reload:true});}(test=>{{throw new Error(`Unable to fetch record of type ${this.type} without an id`);}})();}}defineSignal(RecordReference.prototype,'_ref');class CacheCapabilitiesManager{constructor(_store){this._store=_store;this._willNotify=false;this._pendingNotifies=new Map();}get identifierCache(){return this._store.identifierCache;}_scheduleNotification(identifier,key){let pending=this._pendingNotifies.get(identifier);if(!pending){pending=new Set();this._pendingNotifies.set(identifier,pending);}pending.add(key);if(this._willNotify===true){return;}this._willNotify=true;// it's possible a cache adhoc notifies us,\n// in which case we sync flush\nif(this._store._cbs){this._store._schedule('notify',()=>this._flushNotifications());}else{// TODO @runspired determine if relationship mutations should schedule\n// into join/run vs immediate flush\nthis._flushNotifications();}}_flushNotifications(){if(this._willNotify===false){return;}const pending=this._pendingNotifies;this._pendingNotifies=new Map();this._willNotify=false;pending.forEach((set,identifier)=>{set.forEach(key=>{this._store.notifications.notify(identifier,'relationships',key);});});}notifyChange(identifier,namespace,key){(test=>{if(!test){throw new Error(`Expected a stable identifier`);}})(isStableIdentifier(identifier)||isDocumentIdentifier(identifier));// TODO do we still get value from this?\nif(namespace==='relationships'&&key){this._scheduleNotification(identifier,key);return;}// @ts-expect-error\nthis._store.notifications.notify(identifier,namespace,key);}get schema(){return this._store.schema;}setRecordId(identifier,id){(test=>{if(!test){throw new Error(`Expected a stable identifier`);}})(isStableIdentifier(identifier));this._store._instanceCache.setRecordId(identifier,id);}hasRecord(identifier){return Boolean(this._store._instanceCache.peek(identifier));}disconnectRecord(identifier){(test=>{if(!test){throw new Error(`Expected a stable identifier`);}})(isStableIdentifier(identifier));this._store._instanceCache.disconnect(identifier);this._pendingNotifies.delete(identifier);}}{CacheCapabilitiesManager.prototype.getSchemaDefinitionService=function(){// FIXME add deprecation for this\nreturn this._store.schema;};}/*\n * Returns the Cache instance associated with a given\n * Model or Identifier\n */const CacheForIdentifierCache=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('CacheForIdentifierCache',new Map());function setCacheFor(identifier,cache){(test=>{if(!test){throw new Error(`Illegal set of identifier`);}})(!CacheForIdentifierCache.has(identifier)||CacheForIdentifierCache.get(identifier)===cache);CacheForIdentifierCache.set(identifier,cache);}function removeRecordDataFor(identifier){CacheForIdentifierCache.delete(identifier);}function peekCache(instance){if(CacheForIdentifierCache.has(instance)){return CacheForIdentifierCache.get(instance);}return null;}function isDestroyable(record){return Boolean(record&&typeof record==='object'&&typeof record.destroy==='function');}const RecordCache=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('RecordCache',new Map());function peekRecordIdentifier(record){return RecordCache.get(record);}/**\n  Retrieves the unique referentially-stable [RecordIdentifier](/ember-data/release/classes/StableRecordIdentifier)\n  assigned to the given record instance.\n\n  ```js\n  import { recordIdentifierFor } from \"@ember-data/store\";\n  // ... gain access to a record, for instance with peekRecord or findRecord\n  const record = store.peekRecord(\"user\", \"1\");\n  // get the identifier for the record (see docs for StableRecordIdentifier)\n  const identifier = recordIdentifierFor(record);\n  // access the identifier's properties.\n  const { id, type, lid } = identifier;\n  ```\n\n  @public\n  @param {Object} record a record instance previously obstained from the store.\n  @return {StableRecordIdentifier}\n */function recordIdentifierFor(record){(test=>{if(!test){throw new Error(`${String(record)} is not a record instantiated by @ember-data/store`);}})(RecordCache.has(record));return RecordCache.get(record);}function setRecordIdentifier(record,identifier){{if(RecordCache.has(record)&&RecordCache.get(record)!==identifier){throw new Error(`${String(record)} was already assigned an identifier`);}}/*\n  It would be nice to do a reverse check here that an identifier has not\n  previously been assigned a record; however, unload + rematerialization\n  prevents us from having a great way of doing so when CustomRecordClasses\n  don't necessarily give us access to a `isDestroyed` for dematerialized\n  instance.\n  */RecordCache.set(record,identifier);}const StoreMap=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('StoreMap',new Map());/**\n * We may eventually make this public, but its likely better for this to be killed off\n * @internal\n */function storeFor(record){const store=StoreMap.get(record);(test=>{if(!test){throw new Error(`A record in a disconnected state cannot utilize the store. This typically means the record has been destroyed, most commonly by unloading it.`);}})(store);return store;}class InstanceCache{constructor(store){this.store=store;this.__instances={record:new Map(),reference:new WeakMap(),document:new Map()};this._storeWrapper=new CacheCapabilitiesManager(this.store);store.identifierCache.__configureMerge((identifier,matchedIdentifier,resourceData)=>{let keptIdentifier=identifier;if(identifier.id!==matchedIdentifier.id){// @ts-expect-error TODO this needs to be fixed\nkeptIdentifier='id'in resourceData&&identifier.id===resourceData.id?identifier:matchedIdentifier;}else if(identifier.type!==matchedIdentifier.type){keptIdentifier=// @ts-expect-error TODO this needs to be fixed\n'type'in resourceData&&identifier.type===resourceData.type?identifier:matchedIdentifier;}const staleIdentifier=identifier===keptIdentifier?matchedIdentifier:identifier;// check for duplicate entities\nconst keptHasRecord=this.__instances.record.has(keptIdentifier);const staleHasRecord=this.__instances.record.has(staleIdentifier);// we cannot merge entities when both have records\n// (this may not be strictly true, we could probably swap the cache data the record points at)\nif(keptHasRecord&&staleHasRecord){// TODO we probably don't need to throw these errors anymore\n// we can probably just \"swap\" what data source the abandoned\n// record points at so long as\n// it itself is not retained by the store in any way.\n// @ts-expect-error TODO this needs to be fixed\nif('id'in resourceData){throw new Error(`Failed to update the 'id' for the RecordIdentifier '${identifier.type}:${String(identifier.id)} (${identifier.lid})' to '${String(resourceData.id)}', because that id is already in use by '${matchedIdentifier.type}:${String(matchedIdentifier.id)} (${matchedIdentifier.lid})'`);}(test=>{{throw new Error(`Failed to update the RecordIdentifier '${identifier.type}:${String(identifier.id)} (${identifier.lid})' to merge with the detected duplicate identifier '${matchedIdentifier.type}:${String(matchedIdentifier.id)} (${String(matchedIdentifier.lid)})'`);}})();}this.store.cache.patch({op:'mergeIdentifiers',record:staleIdentifier,value:keptIdentifier});/*\n      TODO @runspired consider adding this to make polymorphism even nicer\n      if (identifier.type !== matchedIdentifier.type) {\n      this.store._graph?.registerPolymorphicType(identifier.type, matchedIdentifier.type);\n      }\n      */this.unloadRecord(staleIdentifier);return keptIdentifier;});}peek(identifier){return this.__instances.record.get(identifier);}getDocument(identifier){let doc=this.__instances.document.get(identifier);if(!doc){doc=new ReactiveDocument(this.store,identifier,null);this.__instances.document.set(identifier,doc);}return doc;}getRecord(identifier,properties){let record=this.__instances.record.get(identifier);if(!record){(test=>{if(!test){throw new Error(`Cannot create a new record instance while the store is being destroyed`);}})(!this.store.isDestroying&&!this.store.isDestroyed);const cache=this.store.cache;setCacheFor(identifier,cache);record=this.store.instantiateRecord(identifier,properties||{});setRecordIdentifier(record,identifier);setCacheFor(record,cache);StoreMap.set(record,this.store);this.__instances.record.set(identifier,record);{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_INSTANCE_CACHE||globalThis.getWarpDriveRuntimeConfig().debug.LOG_INSTANCE_CACHE){logGroup('reactive-ui','',identifier.type,identifier.lid,'created','');// eslint-disable-next-line no-console\nconsole.log({properties});// eslint-disable-next-line no-console\nconsole.groupEnd();}}}return record;}getReference(identifier){const cache=this.__instances.reference;let reference=cache.get(identifier);if(!reference){reference=new RecordReference(this.store,identifier);cache.set(identifier,reference);}return reference;}recordIsLoaded(identifier,filterDeleted=false){const cache=this.cache;if(!cache){return false;}const isNew=cache.isNew(identifier);const isEmpty=cache.isEmpty(identifier);// if we are new we must consider ourselves loaded\nif(isNew){return!cache.isDeleted(identifier);}// even if we have a past request, if we are now empty we are not loaded\n// typically this is true after an unloadRecord call\n// if we are not empty, not new && we have a fulfilled request then we are loaded\n// we should consider allowing for something to be loaded that is simply \"not empty\".\n// which is how RecordState currently handles this case; however, RecordState is buggy\n// in that it does not account for unloading.\nreturn filterDeleted&&cache.isDeletionCommitted(identifier)?false:!isEmpty;}disconnect(identifier){const record=this.__instances.record.get(identifier);(test=>{if(!test){throw new Error('Cannot destroy record while it is still materialized');}})(!isDestroyable(record)||record.isDestroyed||record.isDestroying);this.store._graph?.remove(identifier);this.store.identifierCache.forgetRecordIdentifier(identifier);removeRecordDataFor(identifier);this.store._requestCache._clearEntries(identifier);{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_INSTANCE_CACHE||globalThis.getWarpDriveRuntimeConfig().debug.LOG_INSTANCE_CACHE){log('reactive-ui','',identifier.type,identifier.lid,'disconnected','');}}}unloadRecord(identifier){{const requests=this.store.getRequestStateService().getPendingRequestsForRecord(identifier);if(requests.some(req=>{return req.type==='mutation';})){(test=>{{throw new Error(`You can only unload a record which is not inFlight. '${String(identifier)}'`);}})();}}{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_INSTANCE_CACHE||globalThis.getWarpDriveRuntimeConfig().debug.LOG_INSTANCE_CACHE){// eslint-disable-next-line no-console\nconsole.groupCollapsed(`InstanceCache: unloading record for ${String(identifier)}`);}}// TODO is this join still necessary?\nthis.store._join(()=>{const record=this.__instances.record.get(identifier);const cache=this.cache;if(record){this.store.teardownRecord(record);this.__instances.record.delete(identifier);StoreMap.delete(record);RecordCache.delete(record);removeRecordDataFor(record);{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_INSTANCE_CACHE||globalThis.getWarpDriveRuntimeConfig().debug.LOG_INSTANCE_CACHE){// eslint-disable-next-line no-console\nconsole.log(`InstanceCache: destroyed record for ${String(identifier)}`);}}}if(cache){cache.unloadRecord(identifier);removeRecordDataFor(identifier);{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_INSTANCE_CACHE||globalThis.getWarpDriveRuntimeConfig().debug.LOG_INSTANCE_CACHE){// eslint-disable-next-line no-console\nconsole.log(`InstanceCache: destroyed cache for ${String(identifier)}`);}}}else{this.disconnect(identifier);}this.store._requestCache._clearEntries(identifier);{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_INSTANCE_CACHE||globalThis.getWarpDriveRuntimeConfig().debug.LOG_INSTANCE_CACHE){// eslint-disable-next-line no-console\nconsole.log(`InstanceCache: unloaded RecordData for ${String(identifier)}`);// eslint-disable-next-line no-console\nconsole.groupEnd();}}});}clear(type){const cache=this.store.identifierCache._cache;if(type===undefined){// it would be cool if we could just de-ref cache here\n// but probably would require WeakRef models to do so.\ncache.resources.forEach(identifier=>{this.unloadRecord(identifier);});}else{const typeCache=cache.resourcesByType;const identifiers=typeCache[type]?.lid;if(identifiers){identifiers.forEach(identifier=>{// if (rds.has(identifier)) {\nthis.unloadRecord(identifier);// }\n// TODO we don't remove the identifier, should we?\n});}}}// TODO this should move into something coordinating operations\nsetRecordId(identifier,id){const{type,lid}=identifier;const oldId=identifier.id;// ID absolutely can't be missing if the oldID is empty (missing Id in response for a new record)\n(test=>{if(!test){throw new Error(`'${type}' was saved to the server, but the response does not have an id and your record does not either.`);}})(!(id===null&&oldId===null));// ID absolutely can't be different than oldID if oldID is not null\n// TODO this assertion and restriction may not strictly be needed in the identifiers world\n(test=>{if(!test){throw new Error(`Cannot update the id for '${type}:${lid}' from '${String(oldId)}' to '${id}'.`);}})(!(oldId!==null&&id!==oldId));// ID can be null if oldID is not null (altered ID in response for a record)\n// however, this is more than likely a developer error.\nif(oldId!==null&&id===null){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.warn)(`Your ${type} record was saved to the server, but the response does not have an id.`,!(oldId!==null&&id===null));return;}{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_INSTANCE_CACHE||globalThis.getWarpDriveRuntimeConfig().debug.LOG_INSTANCE_CACHE){// eslint-disable-next-line no-console\nconsole.log(`InstanceCache: updating id to '${id}' for record ${String(identifier)}`);}}const existingIdentifier=this.store.identifierCache.peekRecordIdentifier({type,id});(test=>{if(!test){throw new Error(`'${type}' was saved to the server, but the response returned the new id '${id}', which has already been used with another record.'`);}})(!existingIdentifier||existingIdentifier===identifier);if(identifier.id===null){// TODO potentially this needs to handle merged result\nthis.store.identifierCache.updateRecordIdentifier(identifier,{type,id});}// TODO update resource cache if needed ?\n// TODO handle consequences of identifier merge for notifications\nthis.store.notifications.notify(identifier,'identity');}}function _resourceIsFullDeleted(identifier,cache){return cache.isDeletionCommitted(identifier)||cache.isNew(identifier)&&cache.isDeleted(identifier);}function resourceIsFullyDeleted(instanceCache,identifier){const cache=instanceCache.cache;return!cache||_resourceIsFullDeleted(identifier,cache);}/*\n    When a find request is triggered on the store, the user can optionally pass in\n    attributes and relationships to be preloaded. These are meant to behave as if they\n    came back from the server, except the user obtained them out of band and is informing\n    the store of their existence. The most common use case is for supporting client side\n    nested URLs, such as `/posts/1/comments/2` so the user can do\n    `store.findRecord('comment', 2, { preload: { post: 1 } })` without having to fetch the post.\n\n    Preloaded data can be attributes and relationships passed in either as IDs or as actual\n    models.\n  */function preloadData(store,identifier,preload){const jsonPayload={};//TODO(Igor) consider the polymorphic case\nconst schemas=store.schema;const fields=schemas.fields(identifier);Object.keys(preload).forEach(key=>{const preloadValue=preload[key];const field=fields.get(key);if(field&&(field.kind==='hasMany'||field.kind==='belongsTo')){if(!jsonPayload.relationships){jsonPayload.relationships={};}jsonPayload.relationships[key]=preloadRelationship(field,preloadValue);}else{if(!jsonPayload.attributes){jsonPayload.attributes={};}jsonPayload.attributes[key]=preloadValue;}});const cache=store.cache;const hasRecord=Boolean(store._instanceCache.peek(identifier));cache.upsert(identifier,jsonPayload,hasRecord);}function preloadRelationship(schema,preloadValue){const relatedType=schema.type;if(schema.kind==='hasMany'){(test=>{if(!test){throw new Error('You need to pass in an array to set a hasMany property on a record');}})(Array.isArray(preloadValue));return{data:preloadValue.map(value=>_convertPreloadRelationshipToJSON(value,relatedType))};}(test=>{if(!test){throw new Error('You should not pass in an array to set a belongsTo property on a record');}})(!Array.isArray(preloadValue));return{data:preloadValue?_convertPreloadRelationshipToJSON(preloadValue,relatedType):null};}/*\n  findRecord('user', '1', { preload: { friends: ['1'] }});\n  findRecord('user', '1', { preload: { friends: [record] }});\n*/function _convertPreloadRelationshipToJSON(value,type){if(typeof value==='string'||typeof value==='number'){return{type,id:ensureStringId(value)};}// TODO if not a record instance assert it's an identifier\n// and allow identifiers to be used\nreturn recordIdentifierFor(value);}function _clearCaches(){RecordCache.clear();StoreMap.clear();CacheForIdentifierCache.clear();}// if modelFor turns out to be a bottleneck we should replace with a Map\n// and clear it during store teardown.\nconst AvailableShims=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('AvailableShims',new WeakMap());function getShimClass(store,modelName){let shims=AvailableShims.get(store);if(!shims){shims=Object.create(null);AvailableShims.set(store,shims);}let shim=shims[modelName];if(shim===undefined){shim=shims[modelName]=new ShimModelClass(store,modelName);}return shim;}// Mimics the static apis of @ember-data/model\nclass ShimModelClass{constructor(store,modelName){this.__store=store;this.modelName=modelName;}get fields(){const fields=new Map();const fieldSchemas=this.__store.schema.fields({type:this.modelName});fieldSchemas.forEach((schema,key)=>{if(schema.kind==='attribute'||schema.kind==='belongsTo'||schema.kind==='hasMany'){fields.set(key,schema.kind);}});return fields;}get attributes(){const attrs=new Map();const fields=this.__store.schema.fields({type:this.modelName});fields.forEach((schema,key)=>{if(schema.kind==='attribute'){attrs.set(key,schema);}});return attrs;}get relationshipsByName(){const rels=new Map();const fields=this.__store.schema.fields({type:this.modelName});fields.forEach((schema,key)=>{if(schema.kind==='belongsTo'||schema.kind==='hasMany'){rels.set(key,schema);}});return rels;}eachAttribute(callback,binding){this.__store.schema.fields({type:this.modelName}).forEach((schema,key)=>{if(schema.kind==='attribute'){callback.call(binding,key,schema);}});}eachRelationship(callback,binding){this.__store.schema.fields({type:this.modelName}).forEach((schema,key)=>{if(schema.kind==='belongsTo'||schema.kind==='hasMany'){callback.call(binding,key,schema);}});}eachTransformedAttribute(callback,binding){this.__store.schema.fields({type:this.modelName}).forEach((schema,key)=>{if(schema.kind==='attribute'){const type=schema.type;if(type)callback.call(binding,key,type);}});}}/**\n * The CacheManager wraps a Cache enforcing that only\n * the public API surface area is exposed.\n *\n * Hence, it is the value of `Store.cache`, wrapping\n * the cache instance returned by `Store.createCache`.\n *\n * It handles translating between cache versions when\n * necessary, for instance when a Store is configured\n * to use both a v1 and a v2 cache depending on some\n * heuristic.\n *\n * Starting with the v2 spec, the cache is designed such\n * that it must be implemented as a singleton.\n *\n * @class CacheManager\n * @public\n */var _cache=/*#__PURE__*/new WeakMap();class CacheManager{constructor(cache){_defineProperty(this,\"version\",'2');_classPrivateFieldInitSpec(this,_cache,void 0);_classPrivateFieldSet(_cache,this,cache);}// Cache Management\n// ================\n/**\n   * Cache the response to a request\n   *\n   * Unlike `store.push` which has UPSERT\n   * semantics, `put` has `replace` semantics similar to\n   * the `http` method `PUT`\n   *\n   * the individually cacheable\n   * e resource data it may contain\n   * should upsert, but the document data surrounding it should\n   * fully replace any existing information\n   *\n   * Note that in order to support inserting arbitrary data\n   * to the cache that did not originate from a request `put`\n   * should expect to sometimes encounter a document with only\n   * a `content` member and therefor must not assume the existence\n   * of `request` and `response` on the document.\n   *\n   * @param {StructuredDocument} doc\n   * @return {ResourceDocument}\n   * @public\n   */put(doc){return _classPrivateFieldGet(_cache,this).put(doc);}/**\n   * Perform an operation on the cache to update the remote state.\n   *\n   * Note: currently the only valid operation is a MergeOperation\n   * which occurs when a collision of identifiers is detected.\n   *\n   * @public\n   * @param op the operation to perform\n   * @return {void}\n   */patch(op){_classPrivateFieldGet(_cache,this).patch(op);}/**\n   * Update resource data with a local mutation. Currently supports operations\n   * on relationships only.\n   *\n   * @public\n   * @param mutation\n   */mutate(mutation){_classPrivateFieldGet(_cache,this).mutate(mutation);}/**\n   * Peek resource data from the Cache.\n   *\n   * In development, if the return value\n   * is JSON the return value\n   * will be deep-cloned and deep-frozen\n   * to prevent mutation thereby enforcing cache\n   * Immutability.\n   *\n   * This form of peek is useful for implementations\n   * that want to feed raw-data from cache to the UI\n   * or which want to interact with a blob of data\n   * directly from the presentation cache.\n   *\n   * An implementation might want to do this because\n   * de-referencing records which read from their own\n   * blob is generally safer because the record does\n   * not require retaining connections to the Store\n   * and Cache to present data on a per-field basis.\n   *\n   * This generally takes the place of `getAttr` as\n   * an API and may even take the place of `getRelationship`\n   * depending on implementation specifics, though this\n   * latter usage is less recommended due to the advantages\n   * of the Graph handling necessary entanglements and\n   * notifications for relational data.\n   *\n   * @public\n   * @param {StableRecordIdentifier | StableDocumentIdentifier} identifier\n   * @return {ResourceDocument | ResourceBlob | null} the known resource data\n   */peek(identifier){return _classPrivateFieldGet(_cache,this).peek(identifier);}peekRemoteState(identifier){return _classPrivateFieldGet(_cache,this).peekRemoteState(identifier);}/**\n   * Peek the Cache for the existing request data associated with\n   * a cacheable request\n   *\n   * @param {StableDocumentIdentifier}\n   * @return {StableDocumentIdentifier | null}\n   * @public\n   */peekRequest(identifier){return _classPrivateFieldGet(_cache,this).peekRequest(identifier);}/**\n   * Push resource data from a remote source into the cache for this identifier\n   *\n   * @public\n   * @param identifier\n   * @param data\n   * @param hasRecord\n   * @return {void | string[]} if `hasRecord` is true then calculated key changes should be returned\n   */upsert(identifier,data,hasRecord){return _classPrivateFieldGet(_cache,this).upsert(identifier,data,hasRecord);}// Cache Forking Support\n// =====================\n/**\n   * Create a fork of the cache from the current state.\n   *\n   * Applications should typically not call this method themselves,\n   * preferring instead to fork at the Store level, which will\n   * utilize this method to fork the cache.\n   *\n   * @public\n   * @return {Promise<Cache>}\n   */fork(){return _classPrivateFieldGet(_cache,this).fork();}/**\n   * Merge a fork back into a parent Cache.\n   *\n   * Applications should typically not call this method themselves,\n   * preferring instead to merge at the Store level, which will\n   * utilize this method to merge the caches.\n   *\n   * @param {Cache} cache\n   * @public\n   * @return {Promise<void>}\n   */merge(cache){return _classPrivateFieldGet(_cache,this).merge(cache);}/**\n   * Generate the list of changes applied to all\n   * record in the store.\n   *\n   * Each individual resource or document that has\n   * been mutated should be described as an individual\n   * `Change` entry in the returned array.\n   *\n   * A `Change` is described by an object containing up to\n   * three properties: (1) the `identifier` of the entity that\n   * changed; (2) the `op` code of that change being one of\n   * `upsert` or `remove`, and if the op is `upsert` a `patch`\n   * containing the data to merge into the cache for the given\n   * entity.\n   *\n   * This `patch` is opaque to the Store but should be understood\n   * by the Cache and may expect to be utilized by an Adapter\n   * when generating data during a `save` operation.\n   *\n   * It is generally recommended that the `patch` contain only\n   * the updated state, ignoring fields that are unchanged\n   *\n   * ```ts\n   * interface Change {\n   *  identifier: StableRecordIdentifier | StableDocumentIdentifier;\n   *  op: 'upsert' | 'remove';\n   *  patch?: unknown;\n   * }\n   * ```\n   *\n   * @public\n   */diff(){return _classPrivateFieldGet(_cache,this).diff();}// SSR Support\n// ===========\n/**\n   * Serialize the entire contents of the Cache into a Stream\n   * which may be fed back into a new instance of the same Cache\n   * via `cache.hydrate`.\n   *\n   * @return {Promise<ReadableStream>}\n   * @public\n   */dump(){return _classPrivateFieldGet(_cache,this).dump();}/**\n   * hydrate a Cache from a Stream with content previously serialized\n   * from another instance of the same Cache, resolving when hydration\n   * is complete.\n   *\n   * This method should expect to be called both in the context of restoring\n   * the Cache during application rehydration after SSR **AND** at unknown\n   * times during the lifetime of an already booted application when it is\n   * desired to bulk-load additional information into the cache. This latter\n   * behavior supports optimizing pre/fetching of data for route transitions\n   * via data-only SSR modes.\n   *\n   * @param {ReadableStream} stream\n   * @return {Promise<void>}\n   * @public\n   */hydrate(stream){return _classPrivateFieldGet(_cache,this).hydrate(stream);}// Cache\n// =====\n// Resource Support\n// ================\n/**\n   * [LIFECYCLE] Signal to the cache that a new record has been instantiated on the client\n   *\n   * It returns properties from options that should be set on the record during the create\n   * process. This return value behavior is deprecated.\n   *\n   * @public\n   * @param identifier\n   * @param options\n   */clientDidCreate(identifier,options){return _classPrivateFieldGet(_cache,this).clientDidCreate(identifier,options);}/**\n   * [LIFECYCLE] Signals to the cache that a resource\n   * will be part of a save transaction.\n   *\n   * @public\n   * @param identifier\n   */willCommit(identifier,context){_classPrivateFieldGet(_cache,this).willCommit(identifier,context);}/**\n   * [LIFECYCLE] Signals to the cache that a resource\n   * was successfully updated as part of a save transaction.\n   *\n   * @public\n   * @param identifier\n   * @param data\n   */didCommit(identifier,result){return _classPrivateFieldGet(_cache,this).didCommit(identifier,result);}/**\n   * [LIFECYCLE] Signals to the cache that a resource\n   * was update via a save transaction failed.\n   *\n   * @public\n   * @param identifier\n   * @param errors\n   */commitWasRejected(identifier,errors){_classPrivateFieldGet(_cache,this).commitWasRejected(identifier,errors);}/**\n   * [LIFECYCLE] Signals to the cache that all data for a resource\n   * should be cleared.\n   *\n   * @public\n   * @param identifier\n   */unloadRecord(identifier){_classPrivateFieldGet(_cache,this).unloadRecord(identifier);}// Granular Resource Data APIs\n// ===========================\n/**\n   * Retrieve the data for an attribute from the cache\n   *\n   * @public\n   * @param identifier\n   * @param propertyName\n   * @return {unknown}\n   */getAttr(identifier,propertyName){return _classPrivateFieldGet(_cache,this).getAttr(identifier,propertyName);}/**\n   * Retrieve the remote state for an attribute from the cache\n   *\n   * @public\n   * @param identifier\n   * @param propertyName\n   * @return {unknown}\n   */getRemoteAttr(identifier,propertyName){return _classPrivateFieldGet(_cache,this).getRemoteAttr(identifier,propertyName);}/**\n   * Mutate the data for an attribute in the cache\n   *\n   * @public\n   * @param identifier\n   * @param propertyName\n   * @param value\n   */setAttr(identifier,propertyName,value){_classPrivateFieldGet(_cache,this).setAttr(identifier,propertyName,value);}/**\n   * Query the cache for the changed attributes of a resource.\n   *\n   * @public\n   * @param identifier\n   * @return\n   */changedAttrs(identifier){return _classPrivateFieldGet(_cache,this).changedAttrs(identifier);}/**\n   * Query the cache for whether any mutated attributes exist\n   *\n   * @public\n   * @param identifier\n   * @return {Boolean}\n   */hasChangedAttrs(identifier){return _classPrivateFieldGet(_cache,this).hasChangedAttrs(identifier);}/**\n   * Tell the cache to discard any uncommitted mutations to attributes\n   *\n   * @public\n   * @param identifier\n   * @return the names of attributes that were restored\n   */rollbackAttrs(identifier){return _classPrivateFieldGet(_cache,this).rollbackAttrs(identifier);}// Relationships\n// =============\n/**\n   * Query the cache for the changes to relationships of a resource.\n   *\n   * Returns a map of relationship names to RelationshipDiff objects.\n   *\n   * ```ts\n   * type RelationshipDiff =\n  | {\n      kind: 'collection';\n      remoteState: StableRecordIdentifier[];\n      additions: Set<StableRecordIdentifier>;\n      removals: Set<StableRecordIdentifier>;\n      localState: StableRecordIdentifier[];\n      reordered: boolean;\n    }\n  | {\n      kind: 'resource';\n      remoteState: StableRecordIdentifier | null;\n      localState: StableRecordIdentifier | null;\n    };\n    ```\n   *\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {Map<string, RelationshipDiff>}\n   */changedRelationships(identifier){return _classPrivateFieldGet(_cache,this).changedRelationships(identifier);}/**\n   * Query the cache for whether any mutated attributes exist\n   *\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {Boolean}\n   */hasChangedRelationships(identifier){return _classPrivateFieldGet(_cache,this).hasChangedRelationships(identifier);}/**\n   * Tell the cache to discard any uncommitted mutations to relationships.\n   *\n   * This will also discard the change on any appropriate inverses.\n   *\n   * This method is a candidate to become a mutation\n   *\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {String[]} the names of relationships that were restored\n   */rollbackRelationships(identifier){return _classPrivateFieldGet(_cache,this).rollbackRelationships(identifier);}/**\n   * Query the cache for the current state of a relationship property\n   *\n   * @public\n   * @param identifier\n   * @param propertyName\n   * @return resource relationship object\n   */getRelationship(identifier,propertyName){return _classPrivateFieldGet(_cache,this).getRelationship(identifier,propertyName);}/**\n   * Query the cache for the remote state of a relationship property\n   *\n   * @public\n   * @param identifier\n   * @param propertyName\n   * @return resource relationship object\n   */getRemoteRelationship(identifier,propertyName){return _classPrivateFieldGet(_cache,this).getRemoteRelationship(identifier,propertyName);}// Resource State\n// ===============\n/**\n   * Update the cache state for the given resource to be marked as locally deleted,\n   * or remove such a mark.\n   *\n   * @public\n   * @param identifier\n   * @param isDeleted\n   */setIsDeleted(identifier,isDeleted){_classPrivateFieldGet(_cache,this).setIsDeleted(identifier,isDeleted);}/**\n   * Query the cache for any validation errors applicable to the given resource.\n   *\n   * @public\n   * @param identifier\n   * @return\n   */getErrors(identifier){return _classPrivateFieldGet(_cache,this).getErrors(identifier);}/**\n   * Query the cache for whether a given resource has any available data\n   *\n   * @public\n   * @param identifier\n   * @return {Boolean}\n   */isEmpty(identifier){return _classPrivateFieldGet(_cache,this).isEmpty(identifier);}/**\n   * Query the cache for whether a given resource was created locally and not\n   * yet persisted.\n   *\n   * @public\n   * @param identifier\n   * @return {Boolean}\n   */isNew(identifier){return _classPrivateFieldGet(_cache,this).isNew(identifier);}/**\n   * Query the cache for whether a given resource is marked as deleted (but not\n   * necessarily persisted yet).\n   *\n   * @public\n   * @param identifier\n   * @return {Boolean}\n   */isDeleted(identifier){return _classPrivateFieldGet(_cache,this).isDeleted(identifier);}/**\n   * Query the cache for whether a given resource has been deleted and that deletion\n   * has also been persisted.\n   *\n   * @public\n   * @param identifier\n   * @return {Boolean}\n   */isDeletionCommitted(identifier){return _classPrivateFieldGet(_cache,this).isDeletionCommitted(identifier);}}function isCacheOperationValue(value){return value==='added'||value==='state'||value==='updated'||value==='removed'||value==='invalidated';}function count(label){// @ts-expect-error\n// eslint-disable-next-line\nglobalThis.__WarpDriveMetricCountData[label]=(globalThis.__WarpDriveMetricCountData[label]||0)+1;}function asInternalToken(token){(test=>{if(!test){throw new Error(`Expected a token with a 'for' property`);}})(token&&typeof token==='function'&&'for'in token);}function _unsubscribe(token,cache){asInternalToken(token);const identifier=token.for;{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_NOTIFICATIONS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_NOTIFICATIONS){if(!identifier){// eslint-disable-next-line no-console\nconsole.log('Passed unknown unsubscribe token to unsubscribe',identifier);}}}if(identifier){const callbacks=cache.get(identifier);if(!callbacks){return;}const index=callbacks.indexOf(token);if(index===-1){(test=>{if(!test){throw new Error(`Cannot unsubscribe a token that is not subscribed`);}})(index!==-1);return;}callbacks.splice(index,1);}}/**\n * The NotificationManager provides the ability to subscribe to\n * changes to Cache state.\n *\n * This Feature is what allows WarpDrive to create subscriptions that\n * work with any framework or change-notification system.\n *\n * @hideconstructor\n * @public\n */class NotificationManager{/** @internal *//** @internal *//** @internal *//** @internal *//** @internal *//** @internal */constructor(store){this.store=store;this.isDestroyed=false;this._buffered=new Map();this._hasFlush=false;this._cache=new Map();}/**\n   * Subscribe to changes for a given resource identifier, resource addition/removal, or document addition/removal.\n   *\n   * ```ts\n   * export type CacheOperation = 'added' | 'removed' | 'updated' | 'state';\n   *\n   * export interface NotificationCallback {\n   *   (identifier: StableRecordIdentifier, notificationType: 'attributes' | 'relationships', key?: string): void;\n   *   (identifier: StableRecordIdentifier, notificationType: 'errors' | 'meta' | 'identity' | 'state'): void;\n   *   (identifier: StableRecordIdentifier, notificationType: NotificationType, key?: string): void;\n   * }\n   * export interface ResourceOperationCallback {\n   *   // resource updates\n   *   (identifier: StableRecordIdentifier, notificationType: CacheOperation): void;\n   * }\n   * export interface DocumentOperationCallback {\n   *   // document updates\n   *   (identifier: StableDocumentIdentifier, notificationType: CacheOperation): void;\n   * }\n   * ```\n   *\n   * @public\n   * @param {StableDocumentIdentifier | StableRecordIdentifier | 'resource' | 'document'} identifier\n   * @param {NotificationCallback | ResourceOperationCallback | DocumentOperationCallback} callback\n   * @return {UnsubscribeToken} an opaque token to be used with unsubscribe\n   */subscribe(identifier,callback){(test=>{if(!test){throw new Error(`Expected to receive a stable Identifier to subscribe to`);}})(identifier==='resource'||identifier==='document'||isStableIdentifier(identifier)||isDocumentIdentifier(identifier));let callbacks=this._cache.get(identifier);(test=>{if(!test){throw new Error(`expected to receive a valid callback`);}})(typeof callback==='function');(test=>{if(!test){throw new Error(`cannot subscribe with the same callback twice`);}})(!callbacks||!callbacks.includes(callback));// we use the callback as the cancellation token\n//@ts-expect-error\ncallback.for=identifier;if(!callbacks){callbacks=[];this._cache.set(identifier,callbacks);}callbacks.push(callback);return callback;}/**\n   * remove a previous subscription\n   *\n   * @public\n   */unsubscribe(token){if(!this.isDestroyed){_unsubscribe(token,this._cache);}}/**\n   * Custom Caches and Application Code should not call this method directly.\n   *\n   * @private\n   */notify(identifier,value,key){(test=>{if(!test){throw new Error(`Notify does not accept a key argument for the namespace '${value}'. Received key '${key||''}'.`);}})(!key||value==='attributes'||value==='relationships');if(!isStableIdentifier(identifier)&&!isDocumentIdentifier(identifier)){{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_NOTIFICATIONS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_NOTIFICATIONS){// eslint-disable-next-line no-console\nconsole.log(`Notifying: Expected to receive a stable Identifier to notify '${value}' '${key||''}' with, but ${String(identifier)} is not in the cache`,identifier);}}return false;}const hasSubscribers=Boolean(this._cache.get(identifier)?.length);if(isCacheOperationValue(value)||hasSubscribers){let buffer=this._buffered.get(identifier);if(!buffer){buffer=[];this._buffered.set(identifier,buffer);}buffer.push([value,key]);{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_METRIC_COUNTS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_METRIC_COUNTS){count(`notify ${'type'in identifier?identifier.type:'<document>'} ${value} ${key}`);}}if(!this._scheduleNotify()){{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_NOTIFICATIONS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_NOTIFICATIONS){log('notify','buffered',`${'type'in identifier?identifier.type:'document'}`,identifier.lid,`${value}`,key||'');}}}}else{{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_NOTIFICATIONS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_NOTIFICATIONS){log('notify','discarded',`${'type'in identifier?identifier.type:'document'}`,identifier.lid,`${value}`,key||'');}}{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_METRIC_COUNTS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_METRIC_COUNTS){count(`DISCARDED notify ${'type'in identifier?identifier.type:'<document>'} ${value} ${key}`);}}}return hasSubscribers;}/** @internal */_onNextFlush(cb){this._onFlushCB=cb;}_scheduleNotify(){const asyncFlush=this.store._enableAsyncFlush;if(this._hasFlush){if(asyncFlush!==false&&!(0,_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__.d)()){return false;}}if(asyncFlush&&!(0,_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__.d)()){this._hasFlush=true;return false;}this._flush();return true;}/** @internal */_flush(){const buffered=this._buffered;if(buffered.size){this._buffered=new Map();buffered.forEach((states,identifier)=>{states.forEach(args=>{// @ts-expect-error\nthis._flushNotification(identifier,args[0],args[1]);});});}this._hasFlush=false;this._onFlushCB?.();this._onFlushCB=undefined;}_flushNotification(identifier,value,key){{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_NOTIFICATIONS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_NOTIFICATIONS){log('notify','',`${'type'in identifier?identifier.type:'document'}`,identifier.lid,`${value}`,key||'');}}// TODO for documents this will need to switch based on Identifier kind\nif(isCacheOperationValue(value)){const callbackMap=this._cache.get(isDocumentIdentifier(identifier)?'document':'resource');if(callbackMap){callbackMap.forEach(cb=>{cb(identifier,value);});}}const callbacks=this._cache.get(identifier);if(!callbacks||!callbacks.length){return false;}callbacks.forEach(cb=>{// @ts-expect-error overload doesn't narrow within body\ncb(identifier,value,key);});return true;}/** @internal */destroy(){this.isDestroyed=true;this._cache.clear();}}function isExtensionProp(extensions,prop){return Boolean(extensions&&typeof prop!=='number'&&extensions.has(prop));}function performObjectExtensionGet(receiver,extensions,signals,prop){const desc=extensions.get(prop);switch(desc.kind){case'method':{return desc.fn;}case'readonly-value':{return desc.value;}case'mutable-value':{const signal=getOrCreateInternalSignal(signals,receiver,prop,desc.value);// we don't consume this signal, since its not a true local.\nreturn signal.value;}case'readonly-field':case'mutable-field':{return desc.get.call(receiver);}case'writeonly-field':{(test=>{{throw new Error(`Cannot get extended field ${String(prop)} as its definition has only a setter`);}})();return undefined;}default:{(test=>{{throw new Error(`Unhandled extension kind ${desc.kind}`);}})();return undefined;}}}function performExtensionSet(receiver,extensions,signals,prop,value){const desc=extensions.get(prop);switch(desc.kind){case'method':case'readonly-value':case'readonly-field':(test=>{{throw new Error(`Cannot set extension field ${String(prop)} as it is a ${desc.kind}`);}})();return false;case'mutable-value':{const signal=getOrCreateInternalSignal(signals,receiver,prop,desc.value);if(signal.value!==value){// we don't notify this signal, since its not a true local.\nsignal.value=value;}return true;}case'writeonly-field':case'mutable-field':{desc.set.call(receiver,value);return true;}default:{(test=>{{throw new Error(`Unhandled extension kind ${desc.kind}`);}})();return false;}}}function performArrayExtensionGet(receiver,extensions,signals,prop,_SIGNAL,boundFns,transaction){const desc=extensions.get(prop);switch(desc.kind){case'method':{let fn=boundFns.get(prop);if(fn===undefined){fn=function(){consumeInternalSignal(_SIGNAL);transaction(true);const result=Reflect.apply(desc.fn,receiver,arguments);transaction(false);return result;};boundFns.set(prop,fn);}return fn;}case'mutable-field':case'readonly-field':{return desc.get.call(receiver);}case'readonly-value':{return desc.value;}case'mutable-value':{const signal=getOrCreateInternalSignal(signals,receiver,prop,desc.value);// we don't consume this signal, since its not a true local.\nreturn signal.value;}case'writeonly-field':{(test=>{{throw new Error(`Cannot get extended field ${String(prop)} as its definition has only a setter`);}})();return undefined;}default:{(test=>{{throw new Error(`Unhandled extension kind ${desc.kind}`);}})();return undefined;}}}/* eslint-disable @typescript-eslint/no-explicit-any *//*\n  We redefine Proxy because the native Proxy type treats the `target` and\n  `receiver` as the same type incorrectly.\n\n  We ported this from Typescript's own Proxy types on 3/10/2024.\n*/const NativeProxy=Proxy;const ARRAY_GETTER_METHODS=new Set([Symbol.iterator,'concat','entries','every','fill','filter','find','findIndex','flat','flatMap','forEach','includes','indexOf','join','keys','lastIndexOf','map','reduce','reduceRight','slice','some','values']);const ARRAY_SETTER_METHODS=new Set(['push','pop','unshift','shift','splice','sort']);const SYNC_PROPS=new Set(['[]','length','links','meta']);function isArrayGetter(prop){return ARRAY_GETTER_METHODS.has(prop);}function isArraySetter(prop){return ARRAY_SETTER_METHODS.has(prop);}function isSelfProp(self,prop){return prop in self;}const SOURCE=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('#source',Symbol('#source'));const MUTATE=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('#update',Symbol('#update'));const IS_COLLECTION=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('IS_COLLECTION',Symbol.for('Collection'));function convertToInt(prop){if(typeof prop==='symbol')return null;const num=Number(prop);if(isNaN(num))return null;return num%1===0?num:null;}function safeForEach(instance,arr,store,callback,target){if(target===undefined){target=null;}// clone to prevent mutation\narr=arr.slice();(test=>{if(!test){throw new Error('`forEach` expects a function as first argument.');}})(typeof callback==='function');// because we retrieveLatest above we need not worry if array is mutated during iteration\n// by unloadRecord/rollbackAttributes\n// push/add/removeObject may still be problematic\n// but this is a more traditionally expected forEach bug.\nconst length=arr.length;// we need to access length to ensure we are consumed\nfor(let index=0;index<length;index++){callback.call(target,store._instanceCache.getRecord(arr[index]),index,instance);}return instance;}/**\n  A record array is an array that contains records of a certain type (or modelName).\n  The record array materializes records as needed when they are retrieved for the first\n  time. You should not create record arrays yourself. Instead, an instance of\n  `RecordArray` or its subclasses will be returned by your application's store\n  in response to queries.\n\n  This class should not be imported and instantiated by consuming applications.\n\n  @class RecordArray\n  @public\n*/// these are \"internally\" mutable, they should not be mutated by consumers\n// though this is not currently enforced.\n//\n// all of these should become gated by field-type as they shouldn't be available\n// on request results or non-legacy relationships.\nconst MUTABLE_PROPS=['_updatingPromise','isDestroying','isDestroyed','query','isUpdating','isLoaded','meta','links','isAsync','isPolymorphic','identifier','cache','_inverseIsAsync','key','DEPRECATED_CLASS_NAME'];class IdentifierArray{/**\n    The store that created this record array.\n     @property store\n    @private\n    @type Store\n    */destroy(clear){this.isDestroying=!clear;// changing the reference breaks the Proxy\n// this[SOURCE] = [];\nthis[SOURCE].length=0;notifyInternalSignal(this[_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__.A]);this.isDestroyed=!clear;}constructor(options){/**\n    The flag to signal a `RecordArray` is currently loading data.\n    Example\n    ```javascript\n    let people = store.peekAll('person');\n    people.isUpdating; // false\n    people.update();\n    people.isUpdating; // true\n    ```\n    @property isUpdating\n    @public\n    @type Boolean\n  */_defineProperty(this,\"isLoaded\",true);_defineProperty(this,\"isDestroying\",false);_defineProperty(this,\"isDestroyed\",false);_defineProperty(this,\"_updatingPromise\",null);_defineProperty(this,\"identifier\",void 0);// eslint-disable-next-line @typescript-eslint/no-this-alias\nconst self=this;this.modelName=options.type;this.store=options.store;this._manager=options.manager;this.identifier=options.identifier||null;this[SOURCE]=options.identifiers;this[IS_COLLECTION]=true;// we attach the signal storage to the class\n// so that its easier to find debugging.\nconst signals=withSignalStore(this);const store=options.store;const boundFns=new Map();const PrivateState={links:options.links||null,meta:options.meta||null};let transaction=false;// when a mutation occurs\n// we track all mutations within the call\n// and forward them as one\nlet _SIGNAL=null;const extensions=options.field&&this.store.schema.CAUTION_MEGA_DANGER_ZONE_arrayExtensions?this.store.schema.CAUTION_MEGA_DANGER_ZONE_arrayExtensions(options.field):null;const proxy=new NativeProxy(this[SOURCE],{get(target,prop,receiver){const index=convertToInt(prop);if(_SIGNAL.isStale&&(index!==null||SYNC_PROPS.has(prop)||isArrayGetter(prop))){options.manager._syncArray(receiver);_SIGNAL.isStale=false;}if(index!==null){const identifier=target[index];if(!transaction){consumeInternalSignal(_SIGNAL);}return identifier&&store._instanceCache.getRecord(identifier);}if(prop===_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__.A){return _SIGNAL;}if(prop==='length'){return consumeInternalSignal(_SIGNAL),target.length;}if(prop==='meta')return consumeInternalSignal(_SIGNAL),PrivateState.meta;if(prop==='links')return consumeInternalSignal(_SIGNAL),PrivateState.links;if(prop==='[]')return consumeInternalSignal(_SIGNAL),receiver;if(isArrayGetter(prop)){let fn=boundFns.get(prop);if(fn===undefined){if(prop==='forEach'){fn=function(){consumeInternalSignal(_SIGNAL);transaction=true;const result=safeForEach(receiver,target,store,arguments[0],arguments[1]);transaction=false;return result;};}else{fn=function(){consumeInternalSignal(_SIGNAL);// array functions must run through Reflect to work properly\n// binding via other means will not work.\ntransaction=true;const result=Reflect.apply(target[prop],receiver,arguments);transaction=false;return result;};}boundFns.set(prop,fn);}return fn;}if(isArraySetter(prop)){let fn=boundFns.get(prop);if(fn===undefined){fn=function(){// array functions must run through Reflect to work properly\n// binding via other means will not work.\nif(!options.allowMutation){(test=>{if(!test){throw new Error(`Mutating this array of records via ${String(prop)} is not allowed.`);}})(options.allowMutation);return;}const args=Array.prototype.slice.call(arguments);(test=>{if(!test){throw new Error(`Cannot start a new array transaction while a previous transaction is underway`);}})(!transaction);transaction=true;const result=options[MUTATE](target,receiver,prop,args,_SIGNAL);transaction=false;return result;};boundFns.set(prop,fn);}return fn;}if(isSelfProp(self,prop)){if(prop===SOURCE){return self[prop];}let fn=boundFns.get(prop);if(fn)return fn;const outcome=self[prop];if(typeof outcome==='function'){fn=function(){consumeInternalSignal(_SIGNAL);// array functions must run through Reflect to work properly\n// binding via other means will not work.\nreturn Reflect.apply(outcome,receiver,arguments);};boundFns.set(prop,fn);return fn;}return consumeInternalSignal(_SIGNAL),outcome;}if(isExtensionProp(extensions,prop)){return performArrayExtensionGet(receiver,extensions,signals,prop,_SIGNAL,boundFns,v=>void(transaction=v));}return target[prop];},// FIXME: Should this get a generic like get above?\nset(target,prop,value,receiver){if(!options.allowMutation&&!MUTABLE_PROPS.includes(prop)){(test=>{if(!test){throw new Error(`Mutating ${String(prop)} on this Array is not allowed.`);}})(options.allowMutation);return false;}if(prop==='length'){if(!transaction&&value===0){transaction=true;options[MUTATE](target,receiver,'length 0',[],_SIGNAL);transaction=false;return true;}else if(transaction){return Reflect.set(target,prop,value);}else{(test=>{{throw new Error(`unexpected length set`);}})();}}if(prop==='links'){PrivateState.links=value||null;return true;}if(prop==='meta'){PrivateState.meta=value||null;return true;}if(isExtensionProp(extensions,prop)){return performExtensionSet(receiver,extensions,signals,prop,value);}const index=convertToInt(prop);// we do not allow \"holey\" arrays and so if the index is\n// greater than length then we will disallow setting it.\n// however, there is a special case for \"unshift\" with more than\n// one item being inserted since current items will be moved to the\n// new indices first.\n// we \"loosely\" detect this by just checking whether we are in\n// a transaction.\nif(index===null||index>target.length){if(index!==null&&transaction){const identifier=recordIdentifierFor(value);(test=>{if(!test){throw new Error(`Cannot set index ${index} past the end of the array.`);}})(isStableIdentifier(identifier));target[index]=identifier;return true;}else if(isSelfProp(self,prop)){// @ts-expect-error not all properties are indeces and we can't safely cast\nself[prop]=value;return true;}return false;}const original=target[index];const newIdentifier=extractIdentifierFromRecord$2(value);(test=>{if(!test){throw new Error(`Expected a record`);}})(isStableIdentifier(newIdentifier));// We generate \"transactions\" whenever a setter method on the array\n// is called and might bulk update multiple array cells. Fundamentally,\n// all array operations decompose into individual cell replacements.\n// e.g. a push is really a \"replace cell at next index with new value\"\n// or a splice is \"shift all values left/right by X and set out of new\n// bounds cells to undefined\"\n//\n// so, if we are in a transaction, then this is not a user generated change\n// but one generated by a setter method. In this case we want to only apply\n// the change to the target array and not call the MUTATE method.\n// If there is no transaction though, then this means the user themselves has\n// directly changed the value of a specific index and we need to thus generate\n// a mutation for that change.\n// e.g. \"arr.push(newVal)\" is handled by a \"addToRelatedRecords\" mutation within\n// a transaction.\n// while \"arr[arr.length] = newVal;\" is handled by this replace cell code path.\nif(!transaction){options[MUTATE](target,receiver,'replace cell',[index,original,newIdentifier],_SIGNAL);}else{target[index]=newIdentifier;}return true;},deleteProperty(target,prop){(test=>{if(!test){throw new Error(`Deleting keys on managed arrays is disallowed`);}})(transaction);if(!transaction){return false;}return Reflect.deleteProperty(target,prop);},getPrototypeOf(){return Array.prototype;}});{Object.defineProperty(this,'__SHOW_ME_THE_DATA_(debug mode only)__',{enumerable:false,configurable:true,get(){return proxy.slice();}});}// we entangle the signal on the returned proxy since that is\n// the object that other code will be interfacing with.\n_SIGNAL=entangleSignal(signals,proxy,_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__.A,undefined);return proxy;}/**\n    Used to get the latest version of all of the records in this array\n    from the adapter.\n     Example\n     ```javascript\n    let people = store.peekAll('person');\n    people.isUpdating; // false\n     people.update().then(function() {\n      people.isUpdating; // false\n    });\n     people.isUpdating; // true\n    ```\n     @public\n  */update(){if(this.isUpdating){return this._updatingPromise;}this.isUpdating=true;const updatingPromise=this._update();void updatingPromise.finally(()=>{this._updatingPromise=null;if(this.isDestroying||this.isDestroyed){return;}this.isUpdating=false;});this._updatingPromise=updatingPromise;return updatingPromise;}/*\n    Update this Array and return a promise which resolves once the update\n    is finished.\n   */_update(){(test=>{if(!test){throw new Error(`_update cannot be used with this array`);}})(this.modelName);// @ts-expect-error typescript is unable to handle the complexity of\n//   T = unknown, modelName = string\n//   T extends TypedRecordInstance, modelName = TypeFromInstance<T>\n// both being valid options to pass through here.\nreturn this.store.findAll(this.modelName,{reload:true});}// TODO deprecate\n/**\n    Saves all of the records in the `RecordArray`.\n     Example\n     ```javascript\n    let messages = store.peekAll('message');\n    messages.forEach(function(message) {\n      message.hasBeenSeen = true;\n    });\n    messages.save();\n    ```\n     @public\n    @return {Promise<IdentifierArray>} promise\n  */save(){const promise=Promise.all(this.map(record=>this.store.saveRecord(record))).then(()=>this);return promise;}}// this will error if someone tries to call\n// A(identifierArray) since it is not configurable\n// which is preferable to the `meta` override we used\n// before which required importing all of Ember\nconst desc={enumerable:true,configurable:false,get:function(){// here to support computed chains\n// and {{#each}}\n{return this;}}};// compat(desc);\nObject.defineProperty(IdentifierArray.prototype,'[]',desc);defineSignal(IdentifierArray.prototype,'isUpdating',false);class Collection extends IdentifierArray{constructor(options){super(options);_defineProperty(this,\"query\",null);this.query=options.query||null;this.isLoaded=options.isLoaded||false;}_update(){const{store,query}=this;// TODO save options from initial request?\n(test=>{if(!test){throw new Error(`update cannot be used with this array`);}})(this.modelName);(test=>{if(!test){throw new Error(`update cannot be used with no query`);}})(query);// @ts-expect-error typescript is unable to handle the complexity of\n//   T = unknown, modelName = string\n//   T extends TypedRecordInstance, modelName = TypeFromInstance<T>\n// both being valid options to pass through here.\nconst promise=store.query(this.modelName,query,{_recordArray:this});return promise;}destroy(clear){super.destroy(clear);this._manager._managed.delete(this);this._manager._pending.delete(this);}}// trick the proxy \"in\" check\nCollection.prototype.query=null;// Ensure instanceof works correctly\n// Object.setPrototypeOf(IdentifierArray.prototype, Array.prototype);\nfunction assertRecordPassedToHasMany$1(record){(test=>{if(!test){throw new Error(`All elements of a hasMany relationship must be instances of Model, you passed $${typeof record}`);}})(function(){try{recordIdentifierFor(record);return true;}catch{return false;}}());}function extractIdentifierFromRecord$2(record){if(!record){return null;}assertRecordPassedToHasMany$1(record);return recordIdentifierFor(record);}const FAKE_ARR=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('FAKE_ARR',{});const SLICE_BATCH_SIZE=1200;/**\n * This is a clever optimization.\n *\n * clever optimizations rarely stand the test of time, so if you're\n * ever curious or think something better is possible please benchmark\n * and discuss. The benchmark for this at the time of writing is in\n * `scripts/benchmark-push.js`\n *\n * This approach turns out to be 150x faster in Chrome and node than\n * simply using push or concat. It's highly susceptible to the specifics\n * of the batch size, and may require tuning.\n *\n * Clever optimizations should always come with a `why`. This optimization\n * exists for two reasons.\n *\n * 1) array.push(...objects) and Array.prototype.push.apply(arr, objects)\n *   are susceptible to stack overflows. The size of objects at which this\n *   occurs varies by environment, browser, and current stack depth and memory\n *   pressure; however, it occurs in all browsers in fairly pristine conditions\n *   somewhere around 125k to 200k elements. Since WarpDrive regularly encounters\n *   arrays larger than this in size, we cannot use push.\n *\n * 2) `array.concat` or simply setting the array to a new reference is often an\n *   easier approach; however, native Proxy to an array cannot swap it's target array\n *   and attempts at juggling multiple array sources have proven to be victim to a number\n *   of browser implementation bugs. Should these bugs be addressed then we could\n *   simplify to using `concat`, however, do note this is currently 150x faster\n *   than concat, and due to the overloaded signature of concat will likely always\n *   be faster.\n *\n * Sincerely,\n *   - runspired (Chris Thoburn) 08/21/2022\n *\n * @function fastPush\n * @internal\n * @param target the array to push into\n * @param source the items to push into target\n */function fastPush(target,source){let startLength=0;const newLength=source.length;while(newLength-startLength>SLICE_BATCH_SIZE){// eslint-disable-next-line prefer-spread\ntarget.push.apply(target,source.slice(startLength,startLength+SLICE_BATCH_SIZE));startLength+=SLICE_BATCH_SIZE;}// eslint-disable-next-line prefer-spread\ntarget.push.apply(target,source.slice(startLength));}/**\n  @class RecordArrayManager\n  @internal\n*/class RecordArrayManager{constructor(options){this.store=options.store;this.isDestroying=false;this.isDestroyed=false;this._live=new Map();this._managed=new Set();this._pending=new Map();this._staged=new Map();this._keyedArrays=new Map();this._identifiers=new Map();this._set=new Map();this._visibilitySet=new Map();this._subscription=this.store.notifications.subscribe('document',(identifier,type)=>{if(type==='updated'&&this._keyedArrays.has(identifier.lid)){const array=this._keyedArrays.get(identifier.lid);this.dirtyArray(array,0,true);}});this._subscription=this.store.notifications.subscribe('resource',(identifier,type)=>{if(type==='added'){this._visibilitySet.set(identifier,true);this.identifierAdded(identifier);}else if(type==='removed'){this._visibilitySet.set(identifier,false);this.identifierRemoved(identifier);}else if(type==='state'){this.identifierChanged(identifier);}});}_syncArray(array){const pending=this._pending.get(array);const isRequestArray=isCollection(array);if(!isRequestArray&&!pending||this.isDestroying||this.isDestroyed){return;}// first flush any staged changes\nif(pending){sync(array,pending,this._set.get(array));this._pending.delete(array);}// then pull new state if required\nif(isRequestArray){const signal=array[_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__.A];// we only need to rebuild the array from cache if a full sync is required\n// due to notification that the cache has changed\nif(signal.value==='cache-sync'){const doc=this.store.cache.peek(array.identifier);(test=>{if(!test){throw new Error(`Expected to find a document for ${array.identifier.lid} but found none`);}})(doc);const data=!('data'in doc)||!Array.isArray(doc.data)?[]:doc.data;// TODO technically we should destroy here if\n// !('data' in doc) || !Array.isArray(doc.data)\n// is true.\nthis.populateManagedArray(array,data,null);}}}mutate(mutation){this.store.cache.mutate(mutation);}/**\n    Get the `RecordArray` for a modelName, which contains all loaded records of\n    given modelName.\n     @internal\n    @param {String} modelName\n    @return {RecordArray}\n  */liveArrayFor(type){let array=this._live.get(type);const identifiers=[];const staged=this._staged.get(type);if(staged){staged.forEach((value,key)=>{if(value==='add'){identifiers.push(key);}});this._staged.delete(type);}if(!array){array=new IdentifierArray({type,identifiers,store:this.store,allowMutation:false,manager:this});this._live.set(type,array);this._set.set(array,new Set(identifiers));}return array;}getCollection(config){if(config.identifier&&this._keyedArrays.has(config.identifier.lid)){return this._keyedArrays.get(config.identifier.lid);}const options={type:config.type,identifier:config.identifier||null,links:config.doc?.links||null,meta:config.doc?.meta||null,query:config.query||null,identifiers:config.identifiers||[],isLoaded:!!config.identifiers?.length,allowMutation:false,store:this.store,manager:this};const array=new Collection(options);this._managed.add(array);this._set.set(array,new Set(options.identifiers||[]));if(config.identifier){this._keyedArrays.set(config.identifier.lid,array);}if(config.identifiers){associate(this._identifiers,array,config.identifiers);}return array;}dirtyArray(array,delta,shouldSyncFromCache){if(array===FAKE_ARR){return;}const signal=array[_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__.A];if(!signal.isStale||delta>0){notifyInternalSignal(signal);// when the cache has updated for our array, we need to\n// do a full rebuild of the array\nsignal.value=shouldSyncFromCache?'cache-sync':'patch';}}_getPendingFor(identifier,includeManaged,isRemove){if(this.isDestroying||this.isDestroyed){return;}const liveArray=this._live.get(identifier.type);const allPending=this._pending;const pending=new Map();if(includeManaged){const managed=this._identifiers.get(identifier);if(managed){managed.forEach(arr=>{let changes=allPending.get(arr);if(!changes){changes=new Map();allPending.set(arr,changes);}pending.set(arr,changes);});}}// during unloadAll we can ignore removes since we've already\n// cleared the array.\nif(liveArray&&liveArray[SOURCE].length===0&&isRemove){const pendingLive=allPending.get(liveArray);if(!pendingLive||pendingLive.size===0){return pending;}}if(!liveArray){// start building a changeset for when we eventually\n// do have a live array\nlet changes=this._staged.get(identifier.type);if(!changes){changes=new Map();this._staged.set(identifier.type,changes);}pending.set(FAKE_ARR,changes);}else{let changes=allPending.get(liveArray);if(!changes){changes=new Map();allPending.set(liveArray,changes);}pending.set(liveArray,changes);}return pending;}populateManagedArray(array,identifiers,payload){this._pending.delete(array);const source=array[SOURCE];(test=>{if(!test){throw new Error(`The new state of the collection should not be using the same array reference as the original state.`);}})(source!==identifiers);const old=source.slice();source.length=0;fastPush(source,identifiers);this._set.set(array,new Set(identifiers));if(!isCollection(array)){notifyInternalSignal(array[_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__.A]);array.meta=payload?.meta||null;array.links=payload?.links||null;}array.isLoaded=true;disassociate(this._identifiers,array,old);associate(this._identifiers,array,identifiers);}identifierAdded(identifier){const changeSets=this._getPendingFor(identifier,false);if(changeSets){changeSets.forEach((changes,array)=>{const existing=changes.get(identifier);if(existing==='del'){changes.delete(identifier);}else{changes.set(identifier,'add');this.dirtyArray(array,changes.size,false);}});}}identifierRemoved(identifier){const changeSets=this._getPendingFor(identifier,true,true);if(changeSets){changeSets.forEach((changes,array)=>{const existing=changes.get(identifier);if(existing==='add'){changes.delete(identifier);}else{changes.set(identifier,'del');this.dirtyArray(array,changes.size,false);}});}}identifierChanged(identifier){const newState=this.store._instanceCache.recordIsLoaded(identifier,true);// if the change matches the most recent direct added/removed\n// state, then we can ignore it\nif(this._visibilitySet.get(identifier)===newState){return;}if(newState){this.identifierAdded(identifier);}else{this.identifierRemoved(identifier);}}clear(isClear=true){this._live.forEach(array=>array.destroy(isClear));this._managed.forEach(array=>array.destroy(isClear));this._managed.clear();this._identifiers.clear();this._pending.clear();this._set.forEach(set=>set.clear());this._visibilitySet.clear();}destroy(){this.isDestroying=true;this.clear(false);this._live.clear();this.isDestroyed=true;this.store.notifications.unsubscribe(this._subscription);}}function associate(ArraysCache,array,identifiers){for(let i=0;i<identifiers.length;i++){const identifier=identifiers[i];let cache=ArraysCache.get(identifier);if(!cache){cache=new Set();ArraysCache.set(identifier,cache);}cache.add(array);}}function disassociate(ArraysCache,array,identifiers){for(let i=0;i<identifiers.length;i++){disassociateIdentifier(ArraysCache,array,identifiers[i]);}}function disassociateIdentifier(ArraysCache,array,identifier){const cache=ArraysCache.get(identifier);if(cache){cache.delete(array);}}function sync(array,changes,arraySet){const state=array[SOURCE];const adds=[];const removes=[];changes.forEach((value,key)=>{if(value==='add'){// likely we want to keep a Set along-side\nif(arraySet.has(key)){return;}adds.push(key);arraySet.add(key);}else{if(arraySet.has(key)){removes.push(key);arraySet.delete(key);}}});if(removes.length){if(removes.length===state.length){state.length=0;// changing the reference breaks the Proxy\n// state = array[SOURCE] = [];\n}else{removes.forEach(i=>{const index=state.indexOf(i);if(index!==-1){state.splice(index,1);arraySet.delete(i);}});}}if(adds.length){fastPush(state,adds);// changing the reference breaks the Proxy\n// else we could do this\n/*\n    if (state.length === 0) {\n      array[SOURCE] = adds;\n    } else {\n      array[SOURCE] = state.concat(adds);\n    }\n    */}}function isCollection(array){return array.identifier!==null;}const Touching=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('Touching',Symbol('touching'));const RequestPromise=(0,_types_private_js__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('RequestPromise',Symbol('promise'));const EMPTY_ARR=Object.freeze([]);function hasRecordIdentifier(op){return'recordIdentifier'in op;}/**\n * The RequestStateService is used to track the state of requests\n * for fetching or updating known resource identifies that are inflight.\n *\n * @hideconstructor\n * @public\n */class RequestStateService{constructor(store){/** @internal */_defineProperty(this,\"_pending\",new Map());_defineProperty(this,\"_done\",new Map());_defineProperty(this,\"_subscriptions\",new Map());_defineProperty(this,\"_toFlush\",[]);_defineProperty(this,\"_store\",void 0);this._store=store;}/** @internal */_clearEntries(identifier){this._done.delete(identifier);}/** @internal */_enqueue(promise,queryRequest){const query=queryRequest.data[0];if(hasRecordIdentifier(query)){const identifier=query.recordIdentifier;const type=query.op==='saveRecord'?'mutation':'query';if(!this._pending.has(identifier)){this._pending.set(identifier,[]);}const request={state:'pending',request:queryRequest,type};request[Touching]=[query.recordIdentifier];request[RequestPromise]=promise;this._pending.get(identifier).push(request);this._triggerSubscriptions(request);return promise.then(result=>{this._dequeue(identifier,request);const finalizedRequest={state:'fulfilled',request:queryRequest,type,response:{data:result}};finalizedRequest[Touching]=request[Touching];this._addDone(finalizedRequest);this._triggerSubscriptions(finalizedRequest);return result;},error=>{this._dequeue(identifier,request);const finalizedRequest={state:'rejected',request:queryRequest,type,response:{data:error}};finalizedRequest[Touching]=request[Touching];this._addDone(finalizedRequest);this._triggerSubscriptions(finalizedRequest);throw error;});}(test=>{{throw new Error(`Expected a well formed  query`);}})();}_triggerSubscriptions(req){if(req.state==='pending'){this._flushRequest(req);return;}this._toFlush.push(req);if(this._toFlush.length===1){this._store.notifications._onNextFlush(()=>{this._flush();});}}_flush(){this._toFlush.forEach(req=>{this._flushRequest(req);});this._toFlush=[];}_flushRequest(req){req[Touching].forEach(identifier=>{const subscriptions=this._subscriptions.get(identifier);if(subscriptions){subscriptions.forEach(callback=>callback(req));}});}_dequeue(identifier,request){const pending=this._pending.get(identifier);this._pending.set(identifier,pending.filter(req=>req!==request));}_addDone(request){request[Touching].forEach(identifier=>{// TODO add support for multiple\nconst requestDataOp=request.request.data[0].op;let requests=this._done.get(identifier);if(requests){requests=requests.filter(req=>{// TODO add support for multiple\nlet data;if(Array.isArray(req.request.data)){data=req.request.data[0];}else{data=req.request.data;}return data.op!==requestDataOp;});}requests=requests||[];requests.push(request);this._done.set(identifier,requests);});}/**\n   * Subscribe to requests for a given resource identity.\n   *\n   * The callback will receive the current state of the request.\n   *\n   * ```ts\n   * interface RequestState {\n   *   state: 'pending' | 'fulfilled' | 'rejected';\n   *   type: 'query' | 'mutation';\n   *   request: Request;\n   *   response?: { data: unknown };\n   * }\n   * ```\n   *\n   * Note: It should be considered dangerous to use this API for more than simple\n   * state derivation or debugging. The `request` and `response` properties are poorly\n   * spec'd and may change unexpectedly when shifting what Handlers are in use or how\n   * requests are issued from the Store.\n   *\n   * We expect to revisit this API in the near future as we continue to refine the\n   * RequestManager ergonomics, as a simpler but more powerful direct integration\n   * with the RequestManager for these purposes is likely to be a better long-term\n   * design.\n   *\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @param {(state: RequestCacheRequestState) => void} callback\n   */subscribeForRecord(identifier,callback){let subscriptions=this._subscriptions.get(identifier);if(!subscriptions){subscriptions=[];this._subscriptions.set(identifier,subscriptions);}subscriptions.push(callback);}/**\n   * Retrieve all active requests for a given resource identity.\n   *\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {RequestCacheRequestState[]} an array of request states for any pending requests for the given identifier\n   */getPendingRequestsForRecord(identifier){return this._pending.get(identifier)||EMPTY_ARR;}/**\n   * Retrieve the last completed request for a given resource identity.\n   *\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {RequestCacheRequestState | null} the state of the most recent request for the given identifier\n   */getLastRequestForRecord(identifier){const requests=this._done.get(identifier);if(requests){return requests[requests.length-1];}return null;}}function isNonEmptyString(str){return Boolean(str&&typeof str==='string');}function constructResource(type,id,lid){if(typeof type==='object'&&type!==null){const resource=type;if(isStableIdentifier(resource)){return resource;}if('id'in resource){resource.id=coerceId(resource.id);}(test=>{if(!test){throw new Error('Expected either id or lid to be a valid string');}})('id'in resource&&isNonEmptyString(resource.id)||isNonEmptyString(resource.lid));(test=>{if(!test){throw new Error('if id is present, the type must be a string');}})(!('id'in resource)||typeof resource.type==='string');return resource;}else{const trueId=coerceId(id);if(!isNonEmptyString(trueId)){if(isNonEmptyString(lid)){return{lid};}throw new Error('Expected either id or lid to be a valid string');}(test=>{if(!test){throw new Error('type must be a string');}})(typeof type==='string');if(isNonEmptyString(lid)){return{type,id:trueId,lid};}return{type,id:trueId};}}// this import location is deprecated but breaks in 4.8 and older\n// @ts-expect-error adding to globalThis\nglobalThis.setWarpDriveLogging=_types_runtime_js__WEBPACK_IMPORTED_MODULE_2__.setLogging;// @ts-expect-error adding to globalThis\nglobalThis.getWarpDriveRuntimeConfig=_types_runtime_js__WEBPACK_IMPORTED_MODULE_2__.getRuntimeConfig;{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_METRIC_COUNTS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_METRIC_COUNTS){// @ts-expect-error adding to globalThis\n// eslint-disable-next-line\nglobalThis.__WarpDriveMetricCountData=globalThis.__WarpDriveMetricCountData||{};// @ts-expect-error adding to globalThis\nglobalThis.getWarpDriveMetricCounts=()=>{// @ts-expect-error\n// eslint-disable-next-line\nreturn structuredClone(globalThis.__WarpDriveMetricCountData);};// @ts-expect-error adding to globalThis\nglobalThis.resetWarpDriveMetricCounts=()=>{// @ts-expect-error\nglobalThis.__WarpDriveMetricCountData={};};{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.__INTERNAL_LOG_NATIVE_MAP_SET_COUNTS||globalThis.getWarpDriveRuntimeConfig().debug.__INTERNAL_LOG_NATIVE_MAP_SET_COUNTS){// @ts-expect-error adding to globalThis\nglobalThis.__primitiveInstanceId=0;function interceptAndLog(klassName,methodName){const klass=globalThis[klassName];if(methodName==='constructor'){const instantiationLabel=`new ${klassName}()`;// @ts-expect-error\nglobalThis[klassName]=class extends klass{// @ts-expect-error\nconstructor(...args){// eslint-disable-next-line\nsuper(...args);// @ts-expect-error\nconst instanceId=globalThis.__primitiveInstanceId++;// @ts-expect-error\n// eslint-disable-next-line\nglobalThis.__WarpDriveMetricCountData[instantiationLabel]=// @ts-expect-error\n// eslint-disable-next-line\n(globalThis.__WarpDriveMetricCountData[instantiationLabel]||0)+1;// @ts-expect-error\nthis.instanceName=`${klassName}:${instanceId} - ${new Error().stack?.split('\\n')[2]}`;}};}else{// @ts-expect-error\n// eslint-disable-next-line\nconst original=klass.prototype[methodName];const logName=`${klassName}.${methodName}`;// @ts-expect-error\nklass.prototype[methodName]=function(...args){// @ts-expect-error\n// eslint-disable-next-line\nglobalThis.__WarpDriveMetricCountData[logName]=(globalThis.__WarpDriveMetricCountData[logName]||0)+1;// @ts-expect-error\nconst{instanceName}=this;if(!instanceName){// @ts-expect-error\nconst instanceId=globalThis.__primitiveInstanceId++;// @ts-expect-error\nthis.instanceName=`${klassName}.${methodName}:${instanceId} - ${new Error().stack?.split('\\n')[2]}`;}const instanceLogName=`${logName} (${instanceName})`;// @ts-expect-error\n// eslint-disable-next-line\nglobalThis.__WarpDriveMetricCountData[instanceLogName]=// @ts-expect-error\n// eslint-disable-next-line\n(globalThis.__WarpDriveMetricCountData[instanceLogName]||0)+1;// eslint-disable-next-line\nreturn original.apply(this,args);};}}interceptAndLog('Set','constructor');interceptAndLog('Set','add');interceptAndLog('Set','delete');interceptAndLog('Set','has');interceptAndLog('Set','set');interceptAndLog('Set','get');interceptAndLog('Map','constructor');interceptAndLog('Map','set');interceptAndLog('Map','delete');interceptAndLog('Map','has');interceptAndLog('Map','add');interceptAndLog('Map','get');interceptAndLog('WeakSet','constructor');interceptAndLog('WeakSet','add');interceptAndLog('WeakSet','delete');interceptAndLog('WeakSet','has');interceptAndLog('WeakSet','set');interceptAndLog('WeakSet','get');interceptAndLog('WeakMap','constructor');interceptAndLog('WeakMap','set');interceptAndLog('WeakMap','delete');interceptAndLog('WeakMap','has');interceptAndLog('WeakMap','add');interceptAndLog('WeakMap','get');}}}}// `AwaitedKeys` is needed here to resolve any promise types like `PromiseBelongsTo`.\n/**\n * Currently only records that extend object can be created via\n * store.createRecord. This is a limitation of the current API,\n * but can be worked around by creating a new identifier, running\n * the cache.clientDidCreate method, and then peeking the record\n * for the identifier.\n *\n * To assign primary key to a record during creation, only `id` will\n * work correctly for `store.createRecord`, other primary key may be\n * handled by updating the record after creation or using the flow\n * described above.\n *\n * TODO: These are limitations we want to (and can) address. If you\n * have need of lifting these limitations, please open an issue.\n *\n */// eslint-disable-next-line @typescript-eslint/no-explicit-any\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nconst EmptyClass=class{// eslint-disable-next-line @typescript-eslint/no-useless-constructor\nconstructor(args){}};const _BaseClass=EmptyClass;const BaseClass=_BaseClass.default?_BaseClass.default:_BaseClass;if(BaseClass!==EmptyClass){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`The Store class extending from EmberObject is deprecated.\nPlease remove usage of EmberObject APIs and mark your class as not requiring it.\n\nTo mark the class as no longer extending from EmberObject, in ember-cli-build.js\nset the following config:\n\n\\`\\`\\`js\nconst app = new EmberApp(defaults, {\n  emberData: {\n    deprecations: {\n      DEPRECATE_STORE_EXTENDS_EMBER_OBJECT: false\n    }\n  }\n});\n\\`\\`\\`\n`,false,{id:'ember-data:deprecate-store-extends-ember-object',until:'6.0',for:'ember-data',url:'https://deprecations.emberjs.com/id/ember-data-deprecate-store-extends-ember-object',since:{available:'4.13',enabled:'5.4'}});}/**\n * ```ts\n * import { Store } from '@warp-drive/core';\n * ```\n *\n * The `Store` is the central piece of the ***Warp*Drive** experience. It connects\n * requests for data with schemas, caching and reactivity.\n *\n * While it's easy to use ***just*** ***Warp*Drive**'s request management, most projects will find they\n * require far more than basic fetch management. For this reason it's often best to start with a `Store`\n * even when you aren't sure yet.\n *\n * Most projects will only have a single `Store`, though using multiple distinct stores\n * is possible.\n *\n * @public\n * @hideconstructor\n */class Store extends BaseClass{/** @internal *//**\n   * Provides access to the NotificationManager associated\n   * with this Store instance.\n   *\n   * The NotificationManager can be used to subscribe to\n   * changes to the cache.\n   *\n   * @public\n   *//**\n   * Provides access to the SchemaService instance\n   * for this Store instance.\n   *\n   * The SchemaService can be used to query for\n   * information about the schema of a resource.\n   *\n   * @public\n   */get schema(){if(!this._schema){this._schema=this.createSchemaService();}return this._schema;}/** @internal *//**\n   * Provides access to the IdentifierCache instance\n   * for this store.\n   *\n   * The IdentifierCache can be used to generate or\n   * retrieve a stable unique identifier for any resource.\n   *\n   * @public\n   *//**\n   * Provides access to the requestManager instance associated\n   * with this Store instance.\n   *\n   * When using `ember-data` this property is automatically\n   * set to an instance of `RequestManager`. When not using `ember-data`\n   * you must configure this property yourself, either by declaring\n   * it as a service or by initializing it.\n   *\n   * ```ts\n   * import Store, { CacheHandler } from '@ember-data/store';\n   * import RequestManager from '@ember-data/request';\n   * import Fetch from '@ember-data/request/fetch';\n   *\n   * class extends Store {\n   *   requestManager = new RequestManager()\n   *    .use([Fetch])\n   *    .useCache(CacheHandler);\n   * }\n   * ```\n   *\n   * @public\n   *//**\n   * A Property which an App may set to provide a CachePolicy\n   * to control when a cached request becomes stale.\n   *\n   * Note, when defined, these methods will only be invoked if a\n   * cache key exists for the request, either because the request\n   * contains `cacheOptions.key` or because the [IdentifierCache](/ember-data/release/classes/IdentifierCache)\n   * was able to generate a key for the request using the configured\n   * [generation method](/ember-data/release/functions/@ember-data%2Fstore/setIdentifierGenerationMethod).\n   *\n   * `isSoftExpired` will only be invoked if `isHardExpired` returns `false`.\n   *\n   * ```ts\n   * store.lifetimes = {\n   *   // make the request and ignore the current cache state\n   *   isHardExpired(identifier: StableDocumentIdentifier): boolean {\n   *     return false;\n   *   }\n   *\n   *   // make the request in the background if true, return cache state\n   *   isSoftExpired(identifier: StableDocumentIdentifier): boolean {\n   *     return false;\n   *   }\n   * }\n   * ```\n   *\n   * @public\n   */// Private\n/** @internal *//** @internal *//** @internal *//** @internal *//** @internal *//**\n   * Async flush buffers notifications until flushed\n   * by finalization of a future configured by store.request\n   *\n   * This is useful for ensuring that notifications are delivered\n   * prior to the promise resolving but without risk of promise\n   * interleaving.\n   *\n   * @internal\n   */// DEBUG-only properties\n/** @internal *//** @internal *//** @internal *//** @internal */get isDestroying(){return this._isDestroying;}/** @internal */set isDestroying(value){this._isDestroying=value;}/** @internal */get isDestroyed(){return this._isDestroyed;}/** @internal */set isDestroyed(value){this._isDestroyed=value;}/**\n    @private\n  */constructor(createArgs){super(createArgs);Object.assign(this,createArgs);this.identifierCache=new IdentifierCache();this.notifications=new NotificationManager(this);// private but maybe useful to be here, somewhat intimate\nthis.recordArrayManager=new RecordArrayManager({store:this});// private\nthis._requestCache=new RequestStateService(this);this._instanceCache=new InstanceCache(this);this.isDestroying=false;this.isDestroyed=false;}/** @internal */_run(cb){(test=>{if(!test){throw new Error(`WarpDrive should never encounter a nested run`);}})(!this._cbs);const _cbs=this._cbs={};{try{cb();if(_cbs.coalesce){_cbs.coalesce();}if(_cbs.sync){_cbs.sync();}if(_cbs.notify){_cbs.notify();}}finally{this._cbs=null;}}}/**\n   * Executes the callback, ensurng that any work that calls\n   * store._schedule is executed after in the right order.\n   *\n   * When queues already exist, scheduled callbacks will\n   * join the existing queue.\n   *\n   * @internal\n   */_join(cb){if(this._cbs){cb();}else{this._run(cb);}}/** @internal */_schedule(name,cb){(test=>{if(!test){throw new Error(`WarpDrive expects to schedule only when there is an active run`);}})(!!this._cbs);(test=>{if(!test){throw new Error(`WarpDrive expects only one flush per queue name, cannot schedule ${name}`);}})(!this._cbs[name]);this._cbs[name]=cb;}/**\n   * Retrieve the RequestStateService instance\n   * associated with this Store.\n   *\n   * This can be used to query the status of requests\n   * that have been initiated for a given identifier.\n   *\n   * @return {RequestStateService}\n   * @public\n   */getRequestStateService(){return this._requestCache;}/** @internal */_getAllPending(){{const all=[];const pending=this._requestCache._pending;pending.forEach(requests=>{all.push(...requests.map(v=>v[RequestPromise]));});this.requestManager._pending.forEach(v=>all.push(v));const promise=Promise.allSettled(all);promise.length=all.length;return promise;}}/**\n   * ::: tip 💡 For a more complete overview see the [Request Guide](/guides/2-requests/1-overview)\n   * :::\n   *\n   * Issue a request via the configured {@link RequestManager},\n   * inserting the response into the {@link Store.cache | cache} and handing\n   * back a {@link Future} which resolves to a {@link ReactiveDocument | ReactiveDocument}\n   *\n   * #### Request Cache Keys\n   *\n   * Only {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods/GET | GET} requests with a url or requests with an explicit\n   * {@link CacheOptions.key | cache key} will have the request result\n   * and document cached.\n   *\n   * The cache key used is {@link RequestInfo.cacheOptions | RequestInfo.cacheOptions.key}\n   * if present, falling back to {@link RequestInfo.url}.\n   *\n   * Params are not serialized as part of the cache-key, so\n   * either ensure they are already in the url or utilize\n   * `requestConfig.cacheOptions.key`. For queries issued\n   * via the {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods/POST | POST} method `requestConfig.cacheOptions.key`\n   * MUST be supplied for the document to be cached.\n   *\n   * #### Requesting Without a Cache Key\n   *\n   * Resource data within the request is always updated in the cache,\n   * regardless of whether a cache key is present for the request.\n   *\n   * #### Fulfilling From Cache\n   *\n   * When a cache-key is determined, the request may fulfill\n   * from cache provided the cache is not stale.\n   *\n   * Cache staleness is determined by the configured {@link CachePolicy}\n   * with priority given to the  {@link CacheOptions.reload} and\n   * {@link CacheOptions.backgroundReload} on the request if present.\n   *\n   * If the cache data has soft expired or the request asks for a background\n   * reload, the request will fulfill from cache if possible and\n   * make a non-blocking request in the background to update the cache.\n   *\n   * If the cache data has hard expired or the request asks for a reload,\n   * the request will not fulfill from cache and will make a blocking\n   * request to update the cache.\n   *\n   * #### The Response\n   *\n   * The primary difference between {@link RequestManager.request} and `store.request`\n   * is that `store.request` will convert the response into a {@link ReactiveDocument}\n   * containing {@link Store.instantiateRecord | ReactiveResources}.\n   *\n   * @public\n   */request(requestConfig){// we lazily set the cache handler when we issue the first request\n// because constructor doesn't allow for this to run after\n// the user has had the chance to set the prop.\nconst opts={store:this,[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.EnableHydration]:requestConfig[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.EnableHydration]??true};if(requestConfig.records){const identifierCache=this.identifierCache;opts.records=requestConfig.records.map(r=>identifierCache.getOrCreateRecordIdentifier(r));}{if(this.DISABLE_WAITER){opts.disableTestWaiter=typeof requestConfig.disableTestWaiter==='boolean'?requestConfig.disableTestWaiter:true;}}{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_REQUESTS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_REQUESTS){let options;try{options=JSON.parse(JSON.stringify(requestConfig));}catch{options=requestConfig;}// eslint-disable-next-line no-console\nconsole.log(`request: [[START]] ${requestConfig.op&&!requestConfig.url?'(LEGACY) ':''}${requestConfig.op||'<unknown operation>'} ${requestConfig.url||'<empty url>'}  ${requestConfig.method||'<empty method>'}`,options);}}const request=Object.assign({},requestConfig,opts);const future=this.requestManager.request(request);future.onFinalize(()=>{{if((0,_embroider_macros_src_addon_runtime__WEBPACK_IMPORTED_MODULE_8__.getGlobalConfig)().WarpDrive.debug.LOG_REQUESTS||globalThis.getWarpDriveRuntimeConfig().debug.LOG_REQUESTS){// eslint-disable-next-line no-console\nconsole.log(`request: [[FINALIZE]] ${requestConfig.op&&!requestConfig.url?'(LEGACY) ':''}${requestConfig.op||'<unknown operation>'} ${requestConfig.url||'<empty url>'}  ${requestConfig.method||'<empty method>'}`);}}// skip flush for legacy belongsTo\nif(requestConfig.op==='findBelongsTo'&&!requestConfig.url){return;}this.notifications._flush();});return future;}/**\n    Returns the schema for a particular resource type (modelName).\n     When used with Model from @ember-data/model the return is the model class,\n    but this is not guaranteed.\n     If looking to query attribute or relationship information it is\n    recommended to use `getSchemaDefinitionService` instead. This method\n    should be considered legacy and exists primarily to continue to support\n    Adapter/Serializer APIs which expect it's return value in their method\n    signatures.\n     The class of a model might be useful if you want to get a list of all the\n    relationship names of the model, see\n    [`relationshipNames`](/ember-data/release/classes/Model?anchor=relationshipNames)\n    for example.\n     @public\n    @deprecated\n    @param {String} type\n    @return {ModelSchema}\n    */modelFor(type){// FIXME add deprecation and deprecation stripping\n// FIXME/TODO update RFC to remove this method\n{assertDestroyedStoreOnly(this,'modelFor');}(test=>{if(!test){throw new Error(`You need to pass <type> to the store's modelFor method`);}})(typeof type==='string'&&type.length);(test=>{if(!test){throw new Error(`No model was found for '${type}' and no schema handles the type`);}})(this.schema.hasResource({type}));return getShimClass(this,type);}/**\n    Create a new record in the current store. The properties passed\n    to this method are set on the newly created record.\n     To create a new instance of a `Post`:\n     ```js\n    store.createRecord('post', {\n      title: 'Ember is awesome!'\n    });\n    ```\n     To create a new instance of a `Post` that has a relationship with a `User` record:\n     ```js\n    let user = this.store.peekRecord('user', '1');\n    store.createRecord('post', {\n      title: 'Ember is awesome!',\n      user: user\n    });\n    ```\n     @public\n    @param {String} type the name of the resource\n    @param {Object} inputProperties a hash of properties to set on the\n      newly created record.\n    @return {Model} record\n  */createRecord(type,inputProperties){{assertDestroyingStore(this,'createRecord');}(test=>{if(!test){throw new Error(`You need to pass a model name to the store's createRecord method`);}})(type);(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${type}`);}})(typeof type==='string');// This is wrapped in a `run.join` so that in test environments users do not need to manually wrap\n//   calls to `createRecord`. The run loop usage here is because we batch the joining and updating\n//   of record-arrays via ember's run loop, not our own.\n//\n//   to remove this, we would need to move to a new `async` API.\nlet record;this._join(()=>{const normalizedModelName=normalizeModelName(type);const properties={...inputProperties};// If the passed properties do not include a primary key,\n// give the adapter an opportunity to generate one. Typically,\n// client-side ID generators will use something like uuid.js\n// to avoid conflicts.\nlet id=null;if(properties.id===null||properties.id===undefined){const adapter=this.adapterFor?.(normalizedModelName,true);if(adapter&&adapter.generateIdForRecord){id=properties.id=coerceId(adapter.generateIdForRecord(this,normalizedModelName,properties));}else{id=properties.id=null;}}else{id=properties.id=coerceId(properties.id);}const resource={type:normalizedModelName,id};if(resource.id){const identifier=this.identifierCache.peekRecordIdentifier(resource);(test=>{if(!test){throw new Error(`The id ${String(properties.id)} has already been used with another '${normalizedModelName}' record.`);}})(!identifier);}const identifier=this.identifierCache.createIdentifierForNewRecord(resource);const cache=this.cache;const createOptions=normalizeProperties(this,identifier,properties);const resultProps=cache.clientDidCreate(identifier,createOptions);record=this._instanceCache.getRecord(identifier,resultProps);});return record;}/**\n    For symmetry, a record can be deleted via the store.\n     Example\n     ```javascript\n    let post = store.createRecord('post', {\n      title: 'Ember is awesome!'\n    });\n     store.deleteRecord(post);\n    ```\n     @public\n    @param {unknown} record\n  */deleteRecord(record){{assertDestroyingStore(this,'deleteRecord');}const identifier=peekRecordIdentifier(record);const cache=this.cache;(test=>{if(!test){throw new Error(`expected the record to be connected to a cache`);}})(identifier);this._join(()=>{cache.setIsDeleted(identifier,true);if(cache.isNew(identifier)){this._instanceCache.unloadRecord(identifier);}});}/**\n    For symmetry, a record can be unloaded via the store.\n    This will cause the record to be destroyed and freed up for garbage collection.\n     Example\n     ```javascript\n    const { content: { data: post } } = await store.request(findRecord({ type: 'post', id: '1' }));\n    store.unloadRecord(post);\n    ```\n     @public\n    @param {Model} record\n  */unloadRecord(record){{assertDestroyingStore(this,'unloadRecord');}const identifier=peekRecordIdentifier(record);if(identifier){this._instanceCache.unloadRecord(identifier);}}/**\n    This method returns a record for a given identifier or type and id combination.\n     The `findRecord` method will always resolve its promise with the same\n    object for a given identifier or type and `id`.\n     The `findRecord` method will always return a **promise** that will be\n    resolved with the record.\n     **Example 1**\n     ```js [app/routes/post.js]\n    export default class PostRoute extends Route {\n      model({ post_id }) {\n        return this.store.findRecord('post', post_id);\n      }\n    }\n    ```\n     **Example 2**\n     `findRecord` can be called with a single identifier argument instead of the combination\n    of `type` (modelName) and `id` as separate arguments. You may recognize this combo as\n    the typical pairing from [JSON:API](https://jsonapi.org/format/#document-resource-object-identification)\n     ```js [app/routes/post.js]\n    export default class PostRoute extends Route {\n      model({ post_id: id }) {\n        return this.store.findRecord({ type: 'post', id });\n      }\n    }\n    ```\n     **Example 3**\n     If you have previously received an lid via an Identifier for this record, and the record\n    has already been assigned an id, you can find the record again using just the lid.\n     ```js [app/routes/post.js]\n    store.findRecord({ lid });\n    ```\n     If the record is not yet available, the store will ask the adapter's `findRecord`\n    method to retrieve and supply the necessary data. If the record is already present\n    in the store, it depends on the reload behavior _when_ the returned promise\n    resolves.\n     ### Preloading\n     You can optionally `preload` specific attributes and relationships that you know of\n    by passing them via the passed `options`.\n     For example, if your Ember route looks like `/posts/1/comments/2` and your API route\n    for the comment also looks like `/posts/1/comments/2` if you want to fetch the comment\n    without also fetching the post you can pass in the post to the `findRecord` call:\n     ```js [app/routes/post-comments.js]\n    export default class PostRoute extends Route {\n      model({ post_id, comment_id: id }) {\n        return this.store.findRecord({ type: 'comment', id, { preload: { post: post_id }} });\n      }\n    }\n    ```\n     In your adapter you can then access this id without triggering a network request via the\n    snapshot:\n     ```js [app/adapters/application.js]\n    export default class Adapter {\n       findRecord(store, schema, id, snapshot) {\n        let type = schema.modelName;\n         if (type === 'comment')\n          let postId = snapshot.belongsTo('post', { id: true });\n           return fetch(`./posts/${postId}/comments/${id}`)\n            .then(response => response.json())\n        }\n      }\n       static create() {\n        return new this();\n      }\n    }\n    ```\n     This could also be achieved by supplying the post id to the adapter via the adapterOptions\n    property on the options hash.\n     ```js [app/routes/post-comments.js]\n    export default class PostRoute extends Route {\n      model({ post_id, comment_id: id }) {\n        return this.store.findRecord({ type: 'comment', id, { adapterOptions: { post: post_id }} });\n      }\n    }\n    ```\n     ```js [app/adapters/application.js]\n    export default class Adapter {\n      findRecord(store, schema, id, snapshot) {\n        let type = schema.modelName;\n         if (type === 'comment')\n          let postId = snapshot.adapterOptions.post;\n           return fetch(`./posts/${postId}/comments/${id}`)\n            .then(response => response.json())\n        }\n      }\n       static create() {\n        return new this();\n      }\n    }\n    ```\n     If you have access to the post model you can also pass the model itself to preload:\n     ```javascript\n    let post = await store.findRecord('post', '1');\n    let comment = await store.findRecord('comment', '2', { post: myPostModel });\n    ```\n     ### Reloading\n     The reload behavior is configured either via the passed `options` hash or\n    the result of the adapter's `shouldReloadRecord`.\n     If `{ reload: true }` is passed or `adapter.shouldReloadRecord` evaluates\n    to `true`, then the returned promise resolves once the adapter returns\n    data, regardless if the requested record is already in the store:\n     ```js\n    store.push({\n      data: {\n        id: 1,\n        type: 'post',\n        revision: 1\n      }\n    });\n     // adapter#findRecord resolves with\n    // [\n    //   {\n    //     id: 1,\n    //     type: 'post',\n    //     revision: 2\n    //   }\n    // ]\n    store.findRecord('post', '1', { reload: true }).then(function(post) {\n      post.revision; // 2\n    });\n    ```\n     If no reload is indicated via the above mentioned ways, then the promise\n    immediately resolves with the cached version in the store.\n     ### Background Reloading\n     Optionally, if `adapter.shouldBackgroundReloadRecord` evaluates to `true`,\n    then a background reload is started, which updates the records' data, once\n    it is available:\n     ```js\n    // app/adapters/post.js\n    import ApplicationAdapter from \"./application\";\n     export default class PostAdapter extends ApplicationAdapter {\n      shouldReloadRecord(store, snapshot) {\n        return false;\n      },\n       shouldBackgroundReloadRecord(store, snapshot) {\n        return true;\n      }\n    });\n     // ...\n     store.push({\n      data: {\n        id: 1,\n        type: 'post',\n        revision: 1\n      }\n    });\n     let blogPost = store.findRecord('post', '1').then(function(post) {\n      post.revision; // 1\n    });\n     // later, once adapter#findRecord resolved with\n    // [\n    //   {\n    //     id: 1,\n    //     type: 'post',\n    //     revision: 2\n    //   }\n    // ]\n     blogPost.revision; // 2\n    ```\n     If you would like to force or prevent background reloading, you can set a\n    boolean value for `backgroundReload` in the options object for\n    `findRecord`.\n     ```js [app/routes/post/edit.js]\n    export default class PostEditRoute extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { backgroundReload: false });\n      }\n    }\n    ```\n     If you pass an object on the `adapterOptions` property of the options\n    argument it will be passed to your adapter via the snapshot\n     ```js [app/routes/post/edit.js]\n    export default class PostEditRoute extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, {\n          adapterOptions: { subscribe: false }\n        });\n      }\n    }\n    ```\n     ```js [app/adapters/post.js]\n    import MyCustomAdapter from './custom-adapter';\n     export default class PostAdapter extends MyCustomAdapter {\n      findRecord(store, type, id, snapshot) {\n        if (snapshot.adapterOptions.subscribe) {\n          // ...\n        }\n        // ...\n      }\n    }\n    ```\n     See [peekRecord](../methods/peekRecord?anchor=peekRecord) to get the cached version of a record.\n     ### Retrieving Related Model Records\n     If you use an adapter such as Ember's default\n    [`JSONAPIAdapter`](/ember-data/release/classes/JSONAPIAdapter)\n    that supports the [JSON API specification](http://jsonapi.org/) and if your server\n    endpoint supports the use of an\n    ['include' query parameter](http://jsonapi.org/format/#fetching-includes),\n    you can use `findRecord()` or `findAll()` to automatically retrieve additional records related to\n    the one you request by supplying an `include` parameter in the `options` object.\n     For example, given a `post` model that has a `hasMany` relationship with a `comment`\n    model, when we retrieve a specific post we can have the server also return that post's\n    comments in the same request:\n     ```js [app/routes/post.js]\n    export default class PostRoute extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { include: ['comments'] });\n      }\n    }\n    ```\n     ```js [app/adapters/application.js]\n    export default class Adapter {\n      findRecord(store, schema, id, snapshot) {\n        let type = schema.modelName;\n         if (type === 'post')\n          let includes = snapshot.adapterOptions.include;\n           return fetch(`./posts/${postId}?include=${includes}`)\n            .then(response => response.json())\n        }\n      }\n       static create() {\n        return new this();\n      }\n    }\n    ```\n     In this case, the post's comments would then be available in your template as\n    `model.comments`.\n     Multiple relationships can be requested using an `include` parameter consisting of a\n    list of relationship names, while nested relationships can be specified\n    using a dot-separated sequence of relationship names. So to request both the post's\n    comments and the authors of those comments the request would look like this:\n     ```js [app/routes/post.js]\n    export default class PostRoute extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { include: ['comments','comments.author'] });\n      }\n    }\n    ```\n     ### Retrieving Specific Fields by Type\n     If your server endpoint supports the use of a ['fields' query parameter](https://jsonapi.org/format/#fetching-sparse-fieldsets),\n    you can use pass those fields through to your server.  At this point in time, this requires a few manual steps on your part.\n     1. Implement `buildQuery` in your adapter.\n     ```js [app/adapters/application.js]\n    buildQuery(snapshot) {\n      let query = super.buildQuery(...arguments);\n       let { fields } = snapshot.adapterOptions;\n       if (fields) {\n        query.fields = fields;\n      }\n       return query;\n    }\n    ```\n     2. Then pass through the applicable fields to your `findRecord` request.\n     Given a `post` model with attributes body, title, publishDate and meta, you can retrieve a filtered list of attributes.\n     ```js [app/routes/post.js]\n    export default class extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { adapterOptions: { fields: { post: 'body,title' } });\n      }\n    }\n    ```\n     Moreover, you can filter attributes on related models as well. If a `post` has a `belongsTo` relationship to a user,\n    just include the relationship key and attributes.\n     ```js [app/routes/post.js]\n    export default class extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { adapterOptions: { fields: { post: 'body,title', user: 'name,email' } });\n      }\n    }\n    ```\n     @since 1.13.0\n    @public\n    @param {String|object} type - either a string representing the name of the resource or a ResourceIdentifier object containing both the type (a string) and the id (a string) for the record or an lid (a string) of an existing record\n    @param {(String|Integer|Object)} id - optional object with options for the request only if the first param is a ResourceIdentifier, else the string id of the record to be retrieved\n    @param {Object} [options] - if the first param is a string this will be the optional options for the request. See examples for available options.\n    @return {Promise} promise\n  */findRecord(resource,id,options){{assertDestroyingStore(this,'findRecord');}(test=>{if(!test){throw new Error(`You need to pass a modelName or resource identifier as the first argument to the store's findRecord method`);}})(resource);if(isMaybeIdentifier(resource)){options=id;}else{(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${resource}`);}})(typeof resource==='string');const type=normalizeModelName(resource);const normalizedId=ensureStringId(id);resource=constructResource(type,normalizedId);}const identifier=this.identifierCache.getOrCreateRecordIdentifier(resource);options=options||{};if(options.preload){// force reload if we preload to ensure we don't resolve the promise\n// until we are complete, else we will end up background-reloading\n// even for initial load.\nif(!this._instanceCache.recordIsLoaded(identifier)){options.reload=true;}this._join(()=>{preloadData(this,identifier,options.preload);});}const promise=this.request({op:'findRecord',data:{record:identifier,options},cacheOptions:{[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.SkipCache]:true}});return promise.then(document=>{return document.content;});}/**\n    Get the reference for the specified record.\n     Example\n     ```javascript\n    let userRef = store.getReference('user', '1');\n     // check if the user is loaded\n    let isLoaded = userRef.value() !== null;\n     // get the record of the reference (null if not yet available)\n    let user = userRef.value();\n     // get the identifier of the reference\n    if (userRef.remoteType() === 'id') {\n    let id = userRef.id();\n    }\n     // load user (via store.find)\n    userRef.load().then(...)\n     // or trigger a reload\n    userRef.reload().then(...)\n     // provide data for reference\n    userRef.push({ id: 1, username: '@user' }).then(function(user) {\n      userRef.value() === user;\n    });\n    ```\n     @public\n    @param {String|object} resource - modelName (string) or Identifier (object)\n    @param {String|Integer} id\n    @since 2.5.0\n    @return {RecordReference}\n  */// TODO @deprecate getReference (and references generally)\ngetReference(resource,id){{assertDestroyingStore(this,'getReference');}let resourceIdentifier;if(arguments.length===1&&isMaybeIdentifier(resource)){resourceIdentifier=resource;}else{const type=normalizeModelName(resource);const normalizedId=ensureStringId(id);resourceIdentifier=constructResource(type,normalizedId);}(test=>{if(!test){throw new Error('getReference expected to receive either a resource identifier or type and id as arguments');}})(isMaybeIdentifier(resourceIdentifier));const identifier=this.identifierCache.getOrCreateRecordIdentifier(resourceIdentifier);return this._instanceCache.getReference(identifier);}/**\n    Get a record by a given type and ID without triggering a fetch.\n     This method will synchronously return the record if it is available in the store,\n    otherwise it will return `null`. A record is available if it has been fetched earlier, or\n    pushed manually into the store.\n     See [findRecord](../methods/findRecord?anchor=findRecord) if you would like to request this record from the backend.\n     _Note: This is a synchronous method and does not return a promise._\n     **Example 1**\n     ```js\n    let post = store.peekRecord('post', '1');\n     post.id; // '1'\n    ```\n     `peekRecord` can be called with a single identifier argument instead of the combination\n    of `type` (modelName) and `id` as separate arguments. You may recognize this combo as\n    the typical pairing from [JSON:API](https://jsonapi.org/format/#document-resource-object-identification)\n     **Example 2**\n     ```js\n    let post = store.peekRecord({ type: 'post', id });\n    post.id; // '1'\n    ```\n     If you have previously received an lid from an Identifier for this record, you can lookup the record again using\n    just the lid.\n     **Example 3**\n     ```js\n    let post = store.peekRecord({ lid });\n    post.id; // '1'\n    ```\n      @since 1.13.0\n    @public\n    @param {String|object} modelName - either a string representing the modelName or a ResourceIdentifier object containing both the type (a string) and the id (a string) for the record or an lid (a string) of an existing record\n    @param {String|Integer} id - optional only if the first param is a ResourceIdentifier, else the string id of the record to be retrieved.\n    @return {Model|null} record\n  */peekRecord(identifier,id){if(arguments.length===1&&isMaybeIdentifier(identifier)){const stableIdentifier=this.identifierCache.peekRecordIdentifier(identifier);const isLoaded=stableIdentifier&&this._instanceCache.recordIsLoaded(stableIdentifier);// TODO come up with a better mechanism for determining if we have data and could peek.\n// this is basically an \"are we not empty\" query.\nreturn isLoaded?this._instanceCache.getRecord(stableIdentifier):null;}{assertDestroyingStore(this,'peekRecord');}(test=>{if(!test){throw new Error(`You need to pass a model name to the store's peekRecord method`);}})(identifier);(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${String(identifier)}`);}})(typeof identifier==='string');const type=normalizeModelName(identifier);const normalizedId=ensureStringId(id);const resource={type,id:normalizedId};const stableIdentifier=this.identifierCache.peekRecordIdentifier(resource);const isLoaded=stableIdentifier&&this._instanceCache.recordIsLoaded(stableIdentifier);return isLoaded?this._instanceCache.getRecord(stableIdentifier):null;}/**\n    This method delegates a query to the adapter. This is the one place where\n    adapter-level semantics are exposed to the application.\n     Each time this method is called a new request is made through the adapter.\n     Exposing queries this way seems preferable to creating an abstract query\n    language for all server-side queries, and then require all adapters to\n    implement them.\n     ---\n     If you do something like this:\n     ```javascript\n    store.query('person', { page: 1 });\n    ```\n     The request made to the server will look something like this:\n     ```\n    GET \"/api/v1/person?page=1\"\n    ```\n     ---\n     If you do something like this:\n     ```javascript\n    store.query('person', { ids: ['1', '2', '3'] });\n    ```\n     The request made to the server will look something like this:\n     ```\n    GET \"/api/v1/person?ids%5B%5D=1&ids%5B%5D=2&ids%5B%5D=3\"\n    decoded: \"/api/v1/person?ids[]=1&ids[]=2&ids[]=3\"\n    ```\n     This method returns a promise, which is resolved with a\n    [`Collection`](/ember-data/release/classes/Collection)\n    once the server returns.\n     @since 1.13.0\n    @public\n    @param {String} type the name of the resource\n    @param {Object} query a query to be used by the adapter\n    @param {Object} options optional, may include `adapterOptions` hash which will be passed to adapter.query\n    @return {Promise} promise\n  */query(type,query,options={}){{assertDestroyingStore(this,'query');}(test=>{if(!test){throw new Error(`You need to pass a model name to the store's query method`);}})(type);(test=>{if(!test){throw new Error(`You need to pass a query hash to the store's query method`);}})(query);(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${type}`);}})(typeof type==='string');const promise=this.request({op:'query',data:{type:normalizeModelName(type),query,options:options},cacheOptions:{[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.SkipCache]:true}});return promise.then(document=>document.content);}/**\n    This method makes a request for one record, where the `id` is not known\n    beforehand (if the `id` is known, use [`findRecord`](../methods/findRecord?anchor=findRecord)\n    instead).\n     This method can be used when it is certain that the server will return a\n    single object for the primary data.\n     Each time this method is called a new request is made through the adapter.\n     Let's assume our API provides an endpoint for the currently logged in user\n    via:\n     ```\n    // GET /api/current_user\n    {\n      user: {\n        id: 1234,\n        username: 'admin'\n      }\n    }\n    ```\n     Since the specific `id` of the `user` is not known beforehand, we can use\n    `queryRecord` to get the user:\n     ```javascript\n    store.queryRecord('user', {}).then(function(user) {\n      let username = user.username;\n      // do thing\n    });\n    ```\n     The request is made through the adapters' `queryRecord`:\n     ```js [app/adapters/user.js]\n    import Adapter from '@ember-data/adapter';\n    import $ from 'jquery';\n     export default class UserAdapter extends Adapter {\n      queryRecord(modelName, query) {\n        return $.getJSON('/api/current_user');\n      }\n    }\n    ```\n     Note: the primary use case for `store.queryRecord` is when a single record\n    is queried and the `id` is not known beforehand. In all other cases\n    `store.query` and using the first item of the array is likely the preferred\n    way:\n     ```\n    // GET /users?username=unique\n    {\n      data: [{\n        id: 1234,\n        type: 'user',\n        attributes: {\n          username: \"unique\"\n        }\n      }]\n    }\n    ```\n     ```javascript\n    store.query('user', { username: 'unique' }).then(function(users) {\n      return users.firstObject;\n    }).then(function(user) {\n      let id = user.id;\n    });\n    ```\n     This method returns a promise, which resolves with the found record.\n     If the adapter returns no data for the primary data of the payload, then\n    `queryRecord` resolves with `null`:\n     ```\n    // GET /users?username=unique\n    {\n      data: null\n    }\n    ```\n     ```javascript\n    store.queryRecord('user', { username: 'unique' }).then(function(user) {\n       // user is null\n    });\n    ```\n     @since 1.13.0\n    @public\n    @param {String} type\n    @param {Object} query an opaque query to be used by the adapter\n    @param {Object} options optional, may include `adapterOptions` hash which will be passed to adapter.queryRecord\n    @return {Promise} promise which resolves with the found record or `null`\n  */queryRecord(type,query,options){{assertDestroyingStore(this,'queryRecord');}(test=>{if(!test){throw new Error(`You need to pass a model name to the store's queryRecord method`);}})(type);(test=>{if(!test){throw new Error(`You need to pass a query hash to the store's queryRecord method`);}})(query);(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${type}`);}})(typeof type==='string');const promise=this.request({op:'queryRecord',data:{type:normalizeModelName(type),query,options:options||{}},cacheOptions:{[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.SkipCache]:true}});return promise.then(document=>document.content);}/**\n    `findAll` asks the adapter's `findAll` method to find the records for the\n    given type, and returns a promise which will resolve with all records of\n    this type present in the store, even if the adapter only returns a subset\n    of them.\n     ```js [app/routes/authors.js]\n    export default class AuthorsRoute extends Route {\n      model(params) {\n        return this.store.findAll('author');\n      }\n    }\n    ```\n     _When_ the returned promise resolves depends on the reload behavior,\n    configured via the passed `options` hash and the result of the adapter's\n    `shouldReloadAll` method.\n     ### Reloading\n     If `{ reload: true }` is passed or `adapter.shouldReloadAll` evaluates to\n    `true`, then the returned promise resolves once the adapter returns data,\n    regardless if there are already records in the store:\n     ```js\n    store.push({\n      data: {\n        id: 'first',\n        type: 'author'\n      }\n    });\n     // adapter#findAll resolves with\n    // [\n    //   {\n    //     id: 'second',\n    //     type: 'author'\n    //   }\n    // ]\n    store.findAll('author', { reload: true }).then(function(authors) {\n      authors.getEach('id'); // ['first', 'second']\n    });\n    ```\n     If no reload is indicated via the above mentioned ways, then the promise\n    immediately resolves with all the records currently loaded in the store.\n     ### Background Reloading\n     Optionally, if `adapter.shouldBackgroundReloadAll` evaluates to `true`,\n    then a background reload is started. Once this resolves, the array with\n    which the promise resolves, is updated automatically so it contains all the\n    records in the store:\n     ```js [app/adapters/application.js]\n    import Adapter from '@ember-data/adapter';\n     export default class ApplicationAdapter extends Adapter {\n      shouldReloadAll(store, snapshotsArray) {\n        return false;\n      },\n       shouldBackgroundReloadAll(store, snapshotsArray) {\n        return true;\n      }\n    });\n     // ...\n     store.push({\n      data: {\n        id: 'first',\n        type: 'author'\n      }\n    });\n     let allAuthors;\n    store.findAll('author').then(function(authors) {\n      authors.getEach('id'); // ['first']\n       allAuthors = authors;\n    });\n     // later, once adapter#findAll resolved with\n    // [\n    //   {\n    //     id: 'second',\n    //     type: 'author'\n    //   }\n    // ]\n     allAuthors.getEach('id'); // ['first', 'second']\n    ```\n     If you would like to force or prevent background reloading, you can set a\n    boolean value for `backgroundReload` in the options object for\n    `findAll`.\n     ```js [app/routes/post/edit.js]\n    export default class PostEditRoute extends Route {\n      model() {\n        return this.store.findAll('post', { backgroundReload: false });\n      }\n    }\n    ```\n     If you pass an object on the `adapterOptions` property of the options\n    argument it will be passed to you adapter via the `snapshotRecordArray`\n     ```js [app/routes/posts.js]\n    export default class PostsRoute extends Route {\n      model(params) {\n        return this.store.findAll('post', {\n          adapterOptions: { subscribe: false }\n        });\n      }\n    }\n    ```\n     ```js [app/adapters/post.js]\n    import MyCustomAdapter from './custom-adapter';\n     export default class UserAdapter extends MyCustomAdapter {\n      findAll(store, type, sinceToken, snapshotRecordArray) {\n        if (snapshotRecordArray.adapterOptions.subscribe) {\n          // ...\n        }\n        // ...\n      }\n    }\n    ```\n     See [peekAll](../methods/peekAll?anchor=peekAll) to get an array of current records in the\n    store, without waiting until a reload is finished.\n     ### Retrieving Related Model Records\n     If you use an adapter such as Ember's default\n    [`JSONAPIAdapter`](/ember-data/release/classes/JSONAPIAdapter)\n    that supports the [JSON API specification](http://jsonapi.org/) and if your server\n    endpoint supports the use of an\n    ['include' query parameter](http://jsonapi.org/format/#fetching-includes),\n    you can use `findAll()` to automatically retrieve additional records related to\n    those requested by supplying an `include` parameter in the `options` object.\n     For example, given a `post` model that has a `hasMany` relationship with a `comment`\n    model, when we retrieve all of the post records we can have the server also return\n    all of the posts' comments in the same request:\n     ```js [app/routes/posts.js]\n    export default class PostsRoute extends Route {\n      model() {\n        return this.store.findAll('post', { include: ['comments'] });\n      }\n    }\n    ```\n    Multiple relationships can be requested using an `include` parameter consisting of a\n    list or relationship names, while nested relationships can be specified\n    using a dot-separated sequence of relationship names. So to request both the posts'\n    comments and the authors of those comments the request would look like this:\n     ```js [app/routes/posts.js]\n    export default class PostsRoute extends Route {\n      model() {\n        return this.store.findAll('post', { include: ['comments','comments.author'] });\n      }\n    }\n    ```\n     See [query](../methods/query?anchor=query) to only get a subset of records from the server.\n     @since 1.13.0\n    @public\n    @param {String} type the name of the resource\n    @param {Object} options\n    @return {Promise} promise\n  */findAll(type,options={}){{assertDestroyingStore(this,'findAll');}(test=>{if(!test){throw new Error(`You need to pass a model name to the store's findAll method`);}})(type);(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${type}`);}})(typeof type==='string');const promise=this.request({op:'findAll',data:{type:normalizeModelName(type),options:options||{}},cacheOptions:{[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.SkipCache]:true}});return promise.then(document=>document.content);}/**\n    This method returns a filtered array that contains all of the\n    known records for a given type in the store.\n     Note that because it's just a filter, the result will contain any\n    locally created records of the type, however, it will not make a\n    request to the backend to retrieve additional records. If you\n    would like to request all the records from the backend please use\n    [store.findAll](../methods/findAll?anchor=findAll).\n     Also note that multiple calls to `peekAll` for a given type will always\n    return the same `RecordArray`.\n     Example\n     ```javascript\n    let localPosts = store.peekAll('post');\n    ```\n     @since 1.13.0\n    @public\n    @param {String} type the name of the resource\n    @return {RecordArray}\n  */peekAll(type){{assertDestroyingStore(this,'peekAll');}(test=>{if(!test){throw new Error(`You need to pass a model name to the store's peekAll method`);}})(type);(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${type}`);}})(typeof type==='string');return this.recordArrayManager.liveArrayFor(normalizeModelName(type));}/**\n    This method unloads all records in the store.\n    It schedules unloading to happen during the next run loop.\n     Optionally you can pass a type which unload all records for a given type.\n     ```javascript\n    store.unloadAll();\n    store.unloadAll('post');\n    ```\n     @param {String} type the name of the resource\n    @public\n  */unloadAll(type){{assertDestroyedStoreOnly(this,'unloadAll');}(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${String(type)}`);}})(!type||typeof type==='string');this._join(()=>{if(type===undefined){// destroy the graph before unloadAll\n// since then we avoid churning relationships\n// during unload\nthis._graph?.identifiers.clear();this.recordArrayManager.clear();this._instanceCache.clear();}else{this._instanceCache.clear(normalizeModelName(type));}});}/**\n    Push some data for a given type into the store.\n     This method expects normalized [JSON API](http://jsonapi.org/) document. This means you have to follow [JSON API specification](http://jsonapi.org/format/) with few minor adjustments:\n    - record's `type` should always be in singular, dasherized form\n    - members (properties) should be camelCased\n     [Your primary data should be wrapped inside `data` property](http://jsonapi.org/format/#document-top-level):\n     ```js\n    store.push({\n      data: {\n        // primary data for single record of type `Person`\n        id: '1',\n        type: 'person',\n        attributes: {\n          firstName: 'Daniel',\n          lastName: 'Kmak'\n        }\n      }\n    });\n    ```\n     [Demo.](http://ember-twiddle.com/fb99f18cd3b4d3e2a4c7)\n     `data` property can also hold an array (of records):\n     ```js\n    store.push({\n      data: [\n        // an array of records\n        {\n          id: '1',\n          type: 'person',\n          attributes: {\n            firstName: 'Daniel',\n            lastName: 'Kmak'\n          }\n        },\n        {\n          id: '2',\n          type: 'person',\n          attributes: {\n            firstName: 'Tom',\n            lastName: 'Dale'\n          }\n        }\n      ]\n    });\n    ```\n     [Demo.](http://ember-twiddle.com/69cdbeaa3702159dc355)\n     There are some typical properties for `JSONAPI` payload:\n    * `id` - mandatory, unique record's key\n    * `type` - mandatory string which matches `model`'s dasherized name in singular form\n    * `attributes` - object which holds data for record attributes - `attr`'s declared in model\n    * `relationships` - object which must contain any of the following properties under each relationships' respective key (example path is `relationships.achievements.data`):\n      - [`links`](http://jsonapi.org/format/#document-links)\n      - [`data`](http://jsonapi.org/format/#document-resource-object-linkage) - place for primary data\n      - [`meta`](http://jsonapi.org/format/#document-meta) - object which contains meta-information about relationship\n     For this model:\n     ```js [app/models/person.js]\n    import Model, { attr, hasMany } from '@ember-data/model';\n     export default class PersonRoute extends Route {\n      @attr('string') firstName;\n      @attr('string') lastName;\n       @hasMany('person') children;\n    }\n    ```\n     To represent the children as IDs:\n     ```js\n    {\n      data: {\n        id: '1',\n        type: 'person',\n        attributes: {\n          firstName: 'Tom',\n          lastName: 'Dale'\n        },\n        relationships: {\n          children: {\n            data: [\n              {\n                id: '2',\n                type: 'person'\n              },\n              {\n                id: '3',\n                type: 'person'\n              },\n              {\n                id: '4',\n                type: 'person'\n              }\n            ]\n          }\n        }\n      }\n    }\n    ```\n     [Demo.](http://ember-twiddle.com/343e1735e034091f5bde)\n     To represent the children relationship as a URL:\n     ```js\n    {\n      data: {\n        id: '1',\n        type: 'person',\n        attributes: {\n          firstName: 'Tom',\n          lastName: 'Dale'\n        },\n        relationships: {\n          children: {\n            links: {\n              related: '/people/1/children'\n            }\n          }\n        }\n      }\n    }\n    ```\n     If you're streaming data or implementing an adapter, make sure\n    that you have converted the incoming data into this form. The\n    store's [normalize](../methods/normalize?anchor=normalize) method is a convenience\n    helper for converting a json payload into the form Ember Data\n    expects.\n     ```js\n    store.push(store.normalize('person', data));\n    ```\n     This method can be used both to push in brand new\n    records, as well as to update existing records.\n     @public\n    @param {Object} data\n    @return the record(s) that was created or\n      updated.\n  */push(data){{assertDestroyingStore(this,'push');}const pushed=this._push(data,false);if(Array.isArray(pushed)){return pushed.map(identifier=>this._instanceCache.getRecord(identifier));}if(pushed===null){return null;}return this._instanceCache.getRecord(pushed);}/**\n    Push some data in the form of a json-api document into the store,\n    without creating materialized records.\n     @private\n    @param {Object} jsonApiDoc\n    @return {StableRecordIdentifier|Array<StableRecordIdentifier>|null} identifiers for the primary records that had data loaded\n  */_push(jsonApiDoc,asyncFlush){{assertDestroyingStore(this,'_push');}if(asyncFlush){this._enableAsyncFlush=true;}let ret;this._join(()=>{ret=this.cache.put({content:jsonApiDoc});});this._enableAsyncFlush=null;return'data'in ret?ret.data:null;}/**\n   * Trigger a save for a Record.\n   *\n   * Returns a promise resolving with the same record when the save is complete.\n   *\n   * @public\n   * @param {unknown} record\n   * @param options\n   * @return {Promise<record>}\n   */saveRecord(record,options={}){{assertDestroyingStore(this,'saveRecord');}(test=>{if(!test){throw new Error(`Unable to initiate save for a record in a disconnected state`);}})(storeFor(record));const identifier=recordIdentifierFor(record);const cache=this.cache;if(!identifier){// this commonly means we're disconnected\n// but just in case we reject here to prevent bad things.\nreturn Promise.reject(new Error(`Record Is Disconnected`));}(test=>{if(!test){throw new Error(`Cannot initiate a save request for an unloaded record: ${identifier.lid}`);}})(this._instanceCache.recordIsLoaded(identifier));if(resourceIsFullyDeleted(this._instanceCache,identifier)){return Promise.resolve(record);}if(!options){options={};}let operation='updateRecord';if(cache.isNew(identifier)){operation='createRecord';}else if(cache.isDeleted(identifier)){operation='deleteRecord';}const request={op:operation,data:{options,record:identifier},records:[identifier],cacheOptions:{[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.SkipCache]:true}};return this.request(request).then(document=>document.content);}/**\n   * Instantiation hook allowing applications or addons to configure the store\n   * to utilize a custom Cache implementation.\n   *\n   * This hook should not be called directly by consuming applications or libraries.\n   * Use `Store.cache` to access the Cache instance.\n   *\n   * @public\n   * @param storeWrapper\n   * @return {Cache}\n   *//**\n   * Returns the cache instance associated to this Store, instantiates the Cache\n   * if necessary via `Store.createCache`\n   *\n   * @property cache\n   * @type {Cache}\n   * @public\n   */get cache(){let{cache}=this._instanceCache;if(!cache){cache=this._instanceCache.cache=this.createCache(this._instanceCache._storeWrapper);{cache=new CacheManager(cache);}}return cache;}destroy(){if(this.isDestroyed){// @ember/test-helpers will call destroy multiple times\nreturn;}this.isDestroying=true;this._graph?.destroy();this._graph=undefined;this.notifications.destroy();this.recordArrayManager.destroy();this.identifierCache.destroy();this.unloadAll();this.isDestroyed=true;}static create(args){return new this(args);}}{Store.prototype.getSchemaDefinitionService=function(){(test=>{if(!test){throw new Error(`You must registerSchemaDefinitionService with the store to use custom model classes`);}})(this._schema);(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`Use \\`store.schema\\` instead of \\`store.getSchemaDefinitionService()\\``,false,{id:'ember-data:schema-service-updates',until:'6.0',for:'ember-data',since:{available:'4.13',enabled:'5.4'}});return this._schema;};Store.prototype.registerSchemaDefinitionService=function(schema){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`Use \\`store.createSchemaService\\` instead of \\`store.registerSchemaDefinitionService()\\``,false,{id:'ember-data:schema-service-updates',until:'6.0',for:'ember-data',since:{available:'4.13',enabled:'5.4'}});this._schema=schema;};Store.prototype.registerSchema=function(schema){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`Use \\`store.createSchemaService\\` instead of \\`store.registerSchema()\\``,false,{id:'ember-data:schema-service-updates',until:'6.0',for:'ember-data',since:{available:'4.13',enabled:'5.4'}});this._schema=schema;};}let assertDestroyingStore;let assertDestroyedStoreOnly;{// eslint-disable-next-line @typescript-eslint/no-shadow\nassertDestroyingStore=function assertDestroyingStore(store,method){(test=>{if(!test){throw new Error(`Attempted to call store.${method}(), but the store instance has already been destroyed.`);}})(!(store.isDestroying||store.isDestroyed));};// eslint-disable-next-line @typescript-eslint/no-shadow\nassertDestroyedStoreOnly=function assertDestroyedStoreOnly(store,method){(test=>{if(!test){throw new Error(`Attempted to call store.${method}(), but the store instance has already been destroyed.`);}})(!store.isDestroyed);};}function isMaybeIdentifier(maybeIdentifier){return Boolean(maybeIdentifier!==null&&typeof maybeIdentifier==='object'&&('id'in maybeIdentifier&&'type'in maybeIdentifier&&maybeIdentifier.id&&maybeIdentifier.type||maybeIdentifier.lid));}function normalizeProperties(store,identifier,properties){// assert here\nif(properties!==undefined){if('id'in properties){(test=>{if(!test){throw new Error(`expected id to be a string or null`);}})(properties.id!==undefined);}(test=>{if(!test){throw new Error(`You passed '${typeof properties}' as properties for record creation instead of an object.`);}})(typeof properties==='object'&&properties!==null);const{type}=identifier;// convert relationship Records to RecordDatas before passing to RecordData\nconst defs=store.schema.fields({type});if(defs.size){const keys=Object.keys(properties);for(let i=0;i<keys.length;i++){const prop=keys[i];const field=defs.get(prop);if(!field)continue;if(field.kind==='hasMany'){{assertRecordsPassedToHasMany(properties[prop]);}properties[prop]=extractIdentifiersFromRecords$1(properties[prop]);}else if(field.kind==='belongsTo'){properties[prop]=extractIdentifierFromRecord$1(properties[prop]);}}}}return properties;}function assertRecordsPassedToHasMany(records){(test=>{if(!test){throw new Error(`You must pass an array of records to set a hasMany relationship`);}})(Array.isArray(records));(test=>{if(!test){throw new Error(`All elements of a hasMany relationship must be instances of Model, you passed ${records.map(r=>`${typeof r}`).join(', ')}`);}})(function(){return records.every(record=>{try{recordIdentifierFor(record);return true;}catch{return false;}});}());}function extractIdentifiersFromRecords$1(records){return records.map(record=>extractIdentifierFromRecord$1(record));}function extractIdentifierFromRecord$1(recordOrPromiseRecord){if(!recordOrPromiseRecord){return null;}const extract=recordIdentifierFor;return extract(recordOrPromiseRecord);}function _MUTATE(target,receiver,prop,args,_SIGNAL){const collection=receiver;switch(prop){case'length 0':{Reflect.set(target,'length',0);mutateReplaceRelatedRecords(collection,[],_SIGNAL);return true;}case'replace cell':{const[index,prior,value]=args;target[index]=value;mutateReplaceRelatedRecord(collection,{value,prior,index},_SIGNAL);return true;}case'push':{const newValues=extractIdentifiersFromRecords(args);assertNoDuplicates(collection,target,currentState=>currentState.push(...newValues),`Cannot push duplicates to a hasMany's state.`);{// dedupe\nconst seen=new Set(target);const unique=new Set();args.forEach(item=>{const identifier=recordIdentifierFor(item);if(!seen.has(identifier)){seen.add(identifier);unique.add(item);}});const newArgs=Array.from(unique);const result=Reflect.apply(target[prop],receiver,newArgs);if(newArgs.length){mutateAddToRelatedRecords(collection,{value:extractIdentifiersFromRecords(newArgs)},_SIGNAL);}return result;}// else, no dedupe, error on duplicates\n// removed by dead control flow\n// removed by dead control flow\n// removed by dead control flow\n}case'pop':{const result=Reflect.apply(target[prop],receiver,args);if(result){mutateRemoveFromRelatedRecords(collection,{value:recordIdentifierFor(result)},_SIGNAL);}return result;}case'unshift':{const newValues=extractIdentifiersFromRecords(args);assertNoDuplicates(collection,target,currentState=>currentState.unshift(...newValues),`Cannot unshift duplicates to a hasMany's state.`);{// dedupe\nconst seen=new Set(target);const unique=new Set();args.forEach(item=>{const identifier=recordIdentifierFor(item);if(!seen.has(identifier)){seen.add(identifier);unique.add(item);}});const newArgs=Array.from(unique);const result=Reflect.apply(target[prop],receiver,newArgs);if(newArgs.length){mutateAddToRelatedRecords(collection,{value:extractIdentifiersFromRecords(newArgs),index:0},_SIGNAL);}return result;}// else, no dedupe, error on duplicates\n// removed by dead control flow\n// removed by dead control flow\n// removed by dead control flow\n}case'shift':{const result=Reflect.apply(target[prop],receiver,args);if(result){mutateRemoveFromRelatedRecords(collection,{value:recordIdentifierFor(result),index:0},_SIGNAL);}return result;}case'sort':{const result=Reflect.apply(target[prop],receiver,args);mutateSortRelatedRecords(collection,result.map(recordIdentifierFor),_SIGNAL);return result;}case'splice':{const[start,deleteCount,...adds]=args;// detect a full replace\nif(start===0&&deleteCount===collection[SOURCE].length){const newValues=extractIdentifiersFromRecords(adds);assertNoDuplicates(collection,target,currentState=>currentState.splice(start,deleteCount,...newValues),`Cannot replace a hasMany's state with a new state that contains duplicates.`);{// dedupe\nconst current=new Set(adds);const unique=Array.from(current);const newArgs=[start,deleteCount].concat(unique);const result=Reflect.apply(target[prop],receiver,newArgs);mutateReplaceRelatedRecords(collection,extractIdentifiersFromRecords(unique),_SIGNAL);return result;}// else, no dedupe, error on duplicates\n// removed by dead control flow\n// removed by dead control flow\n// removed by dead control flow\n}const newValues=extractIdentifiersFromRecords(adds);assertNoDuplicates(collection,target,currentState=>currentState.splice(start,deleteCount,...newValues),`Cannot splice a hasMany's state with a new state that contains duplicates.`);{// dedupe\nconst currentState=target.slice();currentState.splice(start,deleteCount);const seen=new Set(currentState);const unique=[];adds.forEach(item=>{const identifier=recordIdentifierFor(item);if(!seen.has(identifier)){seen.add(identifier);unique.push(item);}});const newArgs=[start,deleteCount,...unique];const result=Reflect.apply(target[prop],receiver,newArgs);if(deleteCount>0){mutateRemoveFromRelatedRecords(collection,{value:result.map(recordIdentifierFor),index:start},_SIGNAL);}if(unique.length>0){mutateAddToRelatedRecords(collection,{value:extractIdentifiersFromRecords(unique),index:start},_SIGNAL);}return result;}// else, no dedupe, error on duplicates\n// removed by dead control flow\n// removed by dead control flow\n// removed by dead control flow\n// removed by dead control flow\n}default:(test=>{{throw new Error(`unable to convert ${prop} into a transaction that updates the cache state for this record array`);}})();}}/**\n  A `ManyArray` is a `MutableArray` that represents the contents of a has-many\n  relationship.\n\n  The `ManyArray` is instantiated lazily the first time the relationship is\n  requested.\n\n  This class is not intended to be directly instantiated by consuming applications.\n\n  ### Inverses\n\n  Often, the relationships in Ember Data applications will have\n  an inverse. For example, imagine the following models are\n  defined:\n\n  ```js [app/models/post.js]\n  import Model, { hasMany } from '@ember-data/model';\n\n  export default class PostModel extends Model {\n    @hasMany('comment') comments;\n  }\n  ```\n\n  ```js [app/models/comment.js]\n  import { Model, belongsTo } from '@warp-drive/legacy/model';\n\n  export default class CommentModel extends Model {\n    @belongsTo('post') post;\n  }\n  ```\n\n  If you created a new instance of `Post` and added\n  a `Comment` record to its `comments` has-many\n  relationship, you would expect the comment's `post`\n  property to be set to the post that contained\n  the has-many.\n\n  We call the record to which a relationship belongs-to the\n  relationship's _owner_.\n\n  @class ManyArray\n  @public\n*/class RelatedCollection extends IdentifierArray{/**\n    The loading state of this array\n     @property isLoaded\n    @type {Boolean}\n    @public\n    *//**\n    `true` if the relationship is polymorphic, `false` otherwise.\n     @property isPolymorphic\n    @type {Boolean}\n    @private\n    *//**\n    Metadata associated with the request for async hasMany relationships.\n     Example\n     Given that the server returns the following JSON payload when fetching a\n    hasMany relationship:\n     ```js\n    {\n      \"comments\": [{\n        \"id\": 1,\n        \"comment\": \"This is the first comment\",\n      }, {\n    // ...\n      }],\n       \"meta\": {\n        \"page\": 1,\n        \"total\": 5\n      }\n    }\n    ```\n     You can then access the meta data via the `meta` property:\n     ```js\n    let comments = await post.comments;\n    let meta = comments.meta;\n     // meta.page => 1\n    // meta.total => 5\n    ```\n     @property meta\n    @type {Object | null}\n    @public\n    *//**\n     * Retrieve the links for this relationship\n     *\n     @property links\n     @type {Object | null}\n     @public\n     */constructor(options){options[MUTATE]=_MUTATE;super(options);this.isLoaded=options.isLoaded||false;this.isAsync=options.isAsync||false;this.isPolymorphic=options.isPolymorphic||false;this.identifier=options.identifier;this.key=options.key;}notify(){notifyInternalSignal(this[_configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_6__.A]);}/**\n    Reloads all of the records in the manyArray. If the manyArray\n    holds a relationship that was originally fetched using a links url\n    WarpDrive will revisit the original links url to repopulate the\n    relationship.\n     If the ManyArray holds the result of a `store.query()` reload will\n    re-run the original query.\n     Example\n     ```javascript\n    let user = store.peekRecord('user', '1')\n    await login(user);\n     let permissions = await user.permissions;\n    await permissions.reload();\n    ```\n     @public\n  */reload(options){(test=>{if(!test){throw new Error(`Expected the manager for ManyArray to implement reloadHasMany`);}})(typeof this._manager.reloadHasMany==='function');// TODO this is odd, we don't ask the store for anything else like this?\nreturn this._manager.reloadHasMany(this.key,options);}/**\n    Create a child record within the owner\n     @public\n    @param {Object} hash\n    @return {Model} record\n  */createRecord(hash){const{store}=this;(test=>{if(!test){throw new Error(`Expected modelName to be set`);}})(this.modelName);const record=store.createRecord(this.modelName,hash);this.push(record);return record;}/**\n    Saves all of the records in the `ManyArray`.\n     Note: this API can only be used in legacy mode with a configured Adapter.\n     Example\n     ```javascript\n    const { content: { data: inbox } } = await store.request(findRecord({ type: 'inbox', id: '1' }));\n     let messages = await inbox.messages;\n    messages.forEach((message) => {\n      message.isRead = true;\n    });\n    messages.save();\n    ```\n     @public\n    @return {PromiseArray} promise\n  *//** @internal */destroy(){super.destroy(false);}}RelatedCollection.prototype.isAsync=false;RelatedCollection.prototype.isPolymorphic=false;RelatedCollection.prototype.identifier=null;RelatedCollection.prototype.cache=null;RelatedCollection.prototype._inverseIsAsync=false;RelatedCollection.prototype.key='';RelatedCollection.prototype.DEPRECATED_CLASS_NAME='ManyArray';function assertRecordPassedToHasMany(record){(test=>{if(!test){throw new Error(`All elements of a hasMany relationship must be instances of Model, you passed ${typeof record}`);}})(function(){try{recordIdentifierFor(record);return true;}catch{return false;}}());}function extractIdentifiersFromRecords(records){return records.map(extractIdentifierFromRecord);}function extractIdentifierFromRecord(recordOrPromiseRecord){assertRecordPassedToHasMany(recordOrPromiseRecord);return recordIdentifierFor(recordOrPromiseRecord);}function assertNoDuplicates(collection,target,callback,reason){const state=target.slice();callback(state);if(state.length!==new Set(state).size){const duplicates=state.filter((currentValue,currentIndex)=>state.indexOf(currentValue)!==currentIndex);{(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`${reason} This behavior is deprecated. Found duplicates for the following records within the new state provided to \\`<${collection.identifier.type}:${collection.identifier.id||collection.identifier.lid}>.${collection.key}\\`\\n\\t- ${Array.from(new Set(duplicates)).map(r=>isStableIdentifier(r)?r.lid:recordIdentifierFor(r).lid).sort((a,b)=>a.localeCompare(b)).join('\\n\\t- ')}`,false,{id:'ember-data:deprecate-many-array-duplicates',for:'ember-data',until:'6.0',since:{enabled:'5.3',available:'4.13'}});}}}function mutateAddToRelatedRecords(collection,operationInfo,_SIGNAL){mutate(collection,{op:'add',record:collection.identifier,field:collection.key,...operationInfo},_SIGNAL);}function mutateRemoveFromRelatedRecords(collection,operationInfo,_SIGNAL){mutate(collection,{op:'remove',record:collection.identifier,field:collection.key,...operationInfo},_SIGNAL);}function mutateReplaceRelatedRecord(collection,operationInfo,_SIGNAL){mutate(collection,{op:'replaceRelatedRecord',record:collection.identifier,field:collection.key,...operationInfo},_SIGNAL);}function mutateReplaceRelatedRecords(collection,value,_SIGNAL){mutate(collection,{op:'replaceRelatedRecords',record:collection.identifier,field:collection.key,value},_SIGNAL);}function mutateSortRelatedRecords(collection,value,_SIGNAL){mutate(collection,{op:'sortRelatedRecords',record:collection.identifier,field:collection.key,value},_SIGNAL);}function mutate(collection,mutation,_SIGNAL){(test=>{if(!test){throw new Error(`Expected the manager for ManyArray to implement mutate`);}})(typeof collection._manager.mutate==='function');collection._manager.mutate(mutation);notifyInternalSignal(_SIGNAL);}const PromiseCache=new WeakMap();/**\n * The state of a promise in the \"pending\"\n * state. This is the default initial state.\n *\n *//**\n * The state of a promise in the \"fulfilled\" state.\n * This is the state of a promise that has resolved\n * successfully.\n *\n *//**\n * The state of a promise in the \"rejected\" state.\n * This is the state of a promise that has rejected\n * with an error.\n *\n *//**\n * The state of a promise. This is the type that is returned\n * from `getPromiseState`.\n *\n * See also:\n * - {@link PendingPromise}\n * - {@link ResolvedPromise}\n * - {@link RejectedPromise}\n *\n */const PromiseStateProto={};// TODO introduce a new mechanism for defining multiple properties\n// that share a common signal\ndefineSignal(PromiseStateProto,'reason',null);defineSignal(PromiseStateProto,'value',null);defineSignal(PromiseStateProto,'result',null);defineSignal(PromiseStateProto,'error',null);defineSignal(PromiseStateProto,'status','pending');defineSignal(PromiseStateProto,'isPending',true);defineSignal(PromiseStateProto,'isLoading',true);defineSignal(PromiseStateProto,'isSuccess',false);defineSignal(PromiseStateProto,'isError',false);function createPromiseState(promise){const state=(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_7__.g)(promise);const promiseState=Object.create(PromiseStateProto);if(state){if(state.isError){promiseState.error=state.result;promiseState.reason=state.result;promiseState.status='rejected';promiseState.isError=true;promiseState.isPending=false;promiseState.isLoading=false;}else{promiseState.result=state.result;promiseState.value=state.result;promiseState.status='fulfilled';promiseState.isSuccess=true;promiseState.isPending=false;promiseState.isLoading=false;}}else{void promise.then(result=>{(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_7__.s)(promise,{isError:false,result});promiseState.result=result;promiseState.value=result;promiseState.status='fulfilled';promiseState.isSuccess=true;promiseState.isPending=false;promiseState.isLoading=false;},error=>{(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_7__.s)(promise,{isError:true,result:error});promiseState.error=error;promiseState.reason=error;promiseState.status='rejected';promiseState.isError=true;promiseState.isPending=false;promiseState.isLoading=false;});}return promiseState;}const LegacyPromiseProxy=Symbol.for('LegacyPromiseProxy');function isLegacyAwaitable(promise){return LegacyPromiseProxy in promise&&'promise'in promise&&promise[LegacyPromiseProxy]===true;}function getPromise(promise){return isLegacyAwaitable(promise)?promise.promise:promise;}/**\n * Returns a reactive state-machine for the provided promise or awaitable.\n *\n * Repeat calls to `getPromiseState` with the same promise will return the same state object\n * making is safe and easy to use in templates and JavaScript code to produce reactive\n * behaviors around promises.\n *\n * `getPromiseState` can be used in both JavaScript and Template contexts.\n *\n * ```ts\n * import { getPromiseState } from '@warp-drive/ember';\n *\n * const state = getPromiseState(promise);\n * ```\n *\n * For instance, we could write a getter on a component that updates whenever\n * the promise state advances or the promise changes, by combining the function\n * with the use of `@cached`\n *\n * ```ts\n * class Component {\n *   @cached\n *   get title() {\n *     const state = getPromiseState(this.args.request);\n *     if (state.isPending) {\n *       return 'loading...';\n *     }\n *     if (state.isError) { return null; }\n *     return state.result.title;\n *   }\n * }\n * ```\n *\n * Or in a template as a helper:\n *\n * ```gjs\n * import { getPromiseState } from '@warp-drive/ember';\n *\n * <template>\n *   {{#let (getPromiseState @request) as |state|}}\n *     {{#if state.isPending}} <Spinner />\n *     {{else if state.isError}} <ErrorForm @error={{state.error}} />\n *     {{else}}\n *       <h1>{{state.result.title}}</h1>\n *     {{/if}}\n *   {{/let}}\n * </template>\n * ```\n *\n * If looking to use in a template, consider also the `<Await />` component.\n *\n */function getPromiseState(promise){(test=>{if(!test){throw new Error(`getPromiseState expects to be called with a promise: called with ${String(promise)}`);}})(promise);const _promise=getPromise(promise);let state=PromiseCache.get(_promise);if(!state){state=createPromiseState(_promise);PromiseCache.set(_promise,state);}return state;}function decorateMethodV2(prototype,prop,decorators){const origDesc=Object.getOwnPropertyDescriptor(prototype,prop);let desc={...origDesc};for(let decorator of decorators){desc=decorator(prototype,prop,desc)||desc;}if(desc.initializer!==void 0){desc.value=desc.initializer?desc.initializer.call(prototype):void 0;desc.initializer=void 0;}Object.defineProperty(prototype,prop,desc);}const DEFAULT_DEADLINE=30_000;const DISPOSE=Symbol.dispose||Symbol.for('dispose');function isNeverString(val){return val;}// eslint-disable-next-line @typescript-eslint/no-unused-vars\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n/**\n * A reactive class\n *\n * @hideconstructor\n */class RequestSubscription{/**\n   * Whether the browser reports that the network is online.\n   *//**\n   * Whether the browser reports that the tab is hidden.\n   *//**\n   * Whether the component is currently refreshing the request.\n   *//**\n   * The most recent blocking request that was made, typically\n   * the result of a reload.\n   *\n   * This will never be the original request passed as an arg to\n   * the component.\n   *\n   * @internal\n   *//**\n   * The most recent request that was made, typically due to either a\n   * reload or a refresh.\n   *\n   * This will never be the original request passed as an arg to\n   * the component.\n   *\n   * @internal\n   *//**\n   * The time at which the network was reported as offline.\n   *\n   * @internal\n   *//** @internal *//** @internal *//** @internal *//** @internal *//** @internal *//**\n   * The event listener for network status changes,\n   * cached to use the reference for removal.\n   *\n   * @internal\n   *//**\n   * The event listener for visibility status changes,\n   * cached to use the reference for removal.\n   *\n   * @internal\n   *//**\n   * The last request passed as an arg to the component,\n   * cached for comparison.\n   *\n   * @internal\n   *//**\n   * The last query passed as an arg to the component,\n   * cached for comparison.\n   *\n   * @internal\n   *//** @internal *//** @internal *//** @internal *//** @internal */constructor(store,args){/**\n   * Retry the request, reloading it from the server.\n   */_defineProperty(this,\"retry\",async()=>{this._maybeUpdate('reload');await this._localRequest;});/**\n   * Refresh the request, updating it in the background.\n   */_defineProperty(this,\"refresh\",async()=>{this._maybeUpdate('refresh');await this._latestRequest;});this._args=args;this.store=store;this._subscribedTo=null;this._subscription=null;this._intervalStart=null;this._invalidated=false;this._nextInterval=null;this.isDestroyed=false;this[DISPOSE]=_DISPOSE;this._installListeners();void this._beginPolling();}/**\n   * @internal\n   */async _beginPolling(){// await the initial request\ntry{if(!this.isIdle){await this.request;}}catch{// ignore errors here, we just want to wait for the request to finish\n}finally{if(!this.isDestroyed){void this._scheduleInterval();}}}get isIdle(){const{request,query}=this._args;return Boolean(!request&&!query);}get autorefreshTypes(){const{autorefresh}=this._args;let types;if(autorefresh===true){types=['online','invalid'];}else if(typeof autorefresh==='string'){types=autorefresh.split(',');}else{types=[];}return new Set(types);}// we only run this function on component creation\n// and when an update is triggered, so it does not\n// react to changes in the autorefreshThreshold\n// or autorefresh args.\n//\n// if we need to react to those changes, we can\n// use a modifier or internal component or some\n// such to trigger a re-run of this function.\nasync _scheduleInterval(){const{autorefreshThreshold}=this._args;const hasValidThreshold=typeof autorefreshThreshold==='number'&&autorefreshThreshold>0;if(// dont schedule in SSR\ntypeof window==='undefined'||// dont schedule without a threshold\n!hasValidThreshold||// dont schedule if we weren't told to\n!this.autorefreshTypes.has('interval')||// dont schedule if we're already scheduled\nthis._intervalStart!==null){return;}// if we have a current request, wait for it to finish\n// before scheduling the next one\nif(this._latestRequest){try{await this._latestRequest;}catch{// ignore errors here, we just want to wait for the request to finish\n}if(this.isDestroyed){return;}}// setup the next interval\nthis._intervalStart=Date.now();this._nextInterval=setTimeout(()=>{this._maybeUpdate();},autorefreshThreshold);}_clearInterval(){if(this._nextInterval){clearTimeout(this._nextInterval);this._intervalStart=null;}}/**\n   * @internal\n   */_updateSubscriptions(){if(this.isIdle){return;}const requestId=this._request.lid;// if we're already subscribed to this request, we don't need to do anything\nif(this._subscribedTo===requestId){return;}// if we're subscribed to a different request, we need to unsubscribe\nthis._removeSubscriptions();// if we have a request, we need to subscribe to it\nconst{store}=this;if(requestId&&isStore(store)){this._subscribedTo=requestId;this._subscription=store.notifications.subscribe(requestId,(_id,op)=>{// ignore subscription events that occur while our own component's request\n// is ocurring\nif(this._isUpdating){return;}switch(op){case'invalidated':{// if we're subscribed to invalidations, we need to update\nif(this.autorefreshTypes.has('invalid')){this._invalidated=true;this._maybeUpdate();}break;}case'state':{const latest=store.requestManager._deduped.get(requestId);const priority=latest?.priority;const state=this.reqState;if(!priority){// if there is no priority, we have completed whatever request\n// was occurring and so we are no longer refreshing (if we were)\nthis.isRefreshing=false;}else if(priority.blocking&&!state.isLoading){// if we are blocking, there is an active request for this identity\n// that MUST be fulfilled from network (not cache).\n// Thus this is not \"refreshing\" because we should clear out and\n// block on this request.\n//\n// we receive state notifications when either a request initiates\n// or completes.\n//\n// In the completes case: we may receive the state notification\n// slightly before the request is finalized because the NotificationManager\n// may sync flush it (and thus deliver it before the microtask completes)\n//\n// In the initiates case: we aren't supposed to receive one unless there\n// is no other request in flight for this identity.\n//\n// However, there is a race condition here where the completed\n// notification can trigger an update that generates a new request\n// thus giving us an initiated notification before the older request\n// finalizes.\n//\n// When this occurs, if the triggered update happens to have caused\n// a new request to be made for the same identity AND that request\n// is the one passed into this component as the @request arg, then\n// getRequestState will return the state of the new request.\n// We can detect this by checking if the request state is \"loading\"\n// as outside of this case we would have a completed request.\n//\n// That is the reason for the `&& !state.isLoading` check above.\n// TODO should we just treat this as refreshing?\nthis.isRefreshing=false;this._maybeUpdate('policy',true);}else{this.isRefreshing=true;}}}});}}/**\n   * @internal\n   */_removeSubscriptions(){if(this._subscription&&isStore(this.store)){this.store.notifications.unsubscribe(this._subscription);this._subscribedTo=null;this._subscription=null;}}/**\n   * Install the event listeners for network and visibility changes.\n   * This is only done in browser environments with a global `window`.\n   *\n   * @internal\n   */_installListeners(){if(typeof window==='undefined'){return;}this.isOnline=window.navigator.onLine;this._unavailableStart=this.isOnline?null:Date.now();this.isHidden=document.visibilityState==='hidden';this._onlineChanged=event=>{this.isOnline=event.type==='online';if(event.type==='offline'&&this._unavailableStart===null){this._unavailableStart=Date.now();}this._maybeUpdate();};this._backgroundChanged=()=>{const isHidden=document.visibilityState==='hidden';this.isHidden=isHidden;if(isHidden&&this._unavailableStart===null){this._unavailableStart=Date.now();}this._maybeUpdate();};window.addEventListener('online',this._onlineChanged,{passive:true,capture:true});window.addEventListener('offline',this._onlineChanged,{passive:true,capture:true});document.addEventListener('visibilitychange',this._backgroundChanged,{passive:true,capture:true});}/**\n   * If the network is online and the tab is visible, either reload or refresh the request\n   * based on the component's configuration and the requested update mode.\n   *\n   * Valid modes are:\n   *\n   * - `'reload'`: Force a reload of the request.\n   * - `'refresh'`: Refresh the request in the background.\n   * - `'policy'`: Make the request, letting the store's configured CachePolicy decide whether to reload, refresh, or do nothing.\n   * - `undefined`: Make the request using the component's autorefreshBehavior setting if the autorefreshThreshold has passed.\n   *\n   * @internal\n   */_maybeUpdate(mode,silent){if(this.isIdle){return;}const canAttempt=Boolean(this.isOnline&&!this.isHidden&&(mode||this.autorefreshTypes.size));if(!canAttempt){if(!silent&&mode&&mode!=='_invalidated'){throw new Error(`Reload not available: the network is not online or the tab is hidden`);}return;}const{autorefreshTypes}=this;let shouldAttempt=this._invalidated||Boolean(mode);if(!shouldAttempt&&autorefreshTypes.has('online')){const{_unavailableStart}=this;const{autorefreshThreshold}=this._args;const deadline=typeof autorefreshThreshold==='number'?autorefreshThreshold:DEFAULT_DEADLINE;shouldAttempt=Boolean(_unavailableStart&&Date.now()-_unavailableStart>deadline);}if(!shouldAttempt&&autorefreshTypes.has('interval')){const{_intervalStart}=this;const{autorefreshThreshold}=this._args;if(_intervalStart&&typeof autorefreshThreshold==='number'&&autorefreshThreshold>0){shouldAttempt=Boolean(Date.now()-_intervalStart>=autorefreshThreshold);}}this._unavailableStart=null;this._invalidated=false;if(shouldAttempt){this._clearInterval();const request=Object.assign({},this.reqState.request);const realMode=mode==='_invalidated'?null:mode;const val=realMode??this._args.autorefreshBehavior??'policy';switch(val){case'reload':request.cacheOptions=Object.assign({},request.cacheOptions,{reload:true});break;case'refresh':request.cacheOptions=Object.assign({},request.cacheOptions,{backgroundReload:true});break;case'policy':break;default:throw new Error(`Invalid ${mode?'update mode':'@autorefreshBehavior'} for <Request />: ${isNeverString(val)}`);}const wasStoreRequest=request[_types_request_js__WEBPACK_IMPORTED_MODULE_0__.EnableHydration]===true;(test=>{if(!test){throw new Error(`Cannot supply a different store than was used to create the request`);}})(!request.store||request.store===this.store);const store=request.store||this.store;const requester=wasStoreRequest&&'requestManager'in store?store.requestManager:store;this._isUpdating=true;this._latestRequest=requester.request(request);if(val!=='refresh'){this._localRequest=this._latestRequest;}void this._scheduleInterval();void this._latestRequest.finally(()=>{this._isUpdating=false;});}}/**\n   * features to yield to the error slot of a component\n   */get errorFeatures(){return{isHidden:this.isHidden,isOnline:this.isOnline,retry:this.retry};}/**\n   * features to yield to the content slot of a component\n   */get contentFeatures(){const feat={isHidden:this.isHidden,isOnline:this.isOnline,reload:this.retry,refresh:this.refresh,isRefreshing:this.isRefreshing,latestRequest:this._latestRequest};if(feat.isRefreshing){feat.abort=()=>{this._latestRequest?.abort();};}return feat;}/**\n   * @internal\n   */get _request(){const{request,query}=this._args;(test=>{if(!test){throw new Error(`Cannot use both @request and @query args with the <Request> component`);}})(!request||!query);const{_localRequest,_originalRequest,_originalQuery}=this;const isOriginalRequest=request===_originalRequest&&query===_originalQuery;if(_localRequest&&isOriginalRequest){return _localRequest;}// update state checks for the next time\nthis._originalQuery=query;this._originalRequest=request;if(request){return request;}(test=>{if(!test){throw new Error(`You must provide either @request or an @query arg with the <Request> component`);}})(query);// @ts-expect-error TODO investigate this\nreturn this.store.request(query);}get request(){{try{const request=this._request;this._updateSubscriptions();return request;}catch(e){// eslint-disable-next-line no-console\nconsole.log(e);throw new Error(`Unable to initialize the request`,{cause:e});}}}get reqState(){return getRequestState(this.request);}get result(){return this.reqState.result;}}_RequestSubscription=RequestSubscription;decorateMethodV2(_RequestSubscription.prototype,\"isIdle\",[memoized]);decorateMethodV2(_RequestSubscription.prototype,\"autorefreshTypes\",[memoized]);decorateMethodV2(_RequestSubscription.prototype,\"errorFeatures\",[memoized]);decorateMethodV2(_RequestSubscription.prototype,\"contentFeatures\",[memoized]);decorateMethodV2(_RequestSubscription.prototype,\"_request\",[memoized]);decorateMethodV2(_RequestSubscription.prototype,\"request\",[memoized]);defineSignal(RequestSubscription.prototype,'isOnline',true);defineSignal(RequestSubscription.prototype,'isHidden',false);defineSignal(RequestSubscription.prototype,'isRefreshing',false);defineSignal(RequestSubscription.prototype,'_localRequest',undefined);defineSignal(RequestSubscription.prototype,'_latestRequest',undefined);function isStore(store){return'requestManager'in store;}function createRequestSubscription(store,args){return new RequestSubscription(store,args);}function upgradeSubscription(sub){return sub;}function _DISPOSE(){const self=upgradeSubscription(this);self.isDestroyed=true;self._removeSubscriptions();if(typeof window==='undefined'){return;}self._clearInterval();window.removeEventListener('online',self._onlineChanged,{passive:true,capture:true});window.removeEventListener('offline',self._onlineChanged,{passive:true,capture:true});document.removeEventListener('visibilitychange',self._backgroundChanged,{passive:true,capture:true});}const RequestCache=new WeakMap();function isAbortError(error){return error instanceof DOMException&&error.name==='AbortError';}function upgradeLoadingState(state){return state;}async function watchStream(stream,loadingState){const state=upgradeLoadingState(loadingState);const reader=stream.getReader();let bytesLoaded=0;let shouldForward=state._stream!==null&&state._stream.readable.locked;let isForwarding=shouldForward;let writer=state._stream?.writable.getWriter();const buffer=[];state._isPending=false;state._isStarted=true;state._startTime=performance.now();while(true){const{value,done}=await reader.read();if(done){break;}bytesLoaded+=value.byteLength;state._bytesLoaded=bytesLoaded;state._lastPacketTime=performance.now();shouldForward=shouldForward||state._stream!==null&&state._stream.readable.locked;if(shouldForward){if(!isForwarding){isForwarding=true;writer=state._stream.writable.getWriter();for(const item of buffer){await writer.ready;await writer.write(item);}buffer.length=0;}await writer.ready;await writer.write(value);}else{buffer.push(value);}}// if we are still forwarding, we need to close the writer\nif(isForwarding){await writer.ready;await writer.close();}else if(state._stream){// if we are not forwarding, we need to cancel the stream\nawait state._stream.readable.cancel('The Stream Has Already Ended');state._stream=null;}const endTime=performance.now();state._endTime=endTime;state._isComplete=true;state._isStarted=false;}/**\n * Lazily consumes the stream of a request, providing a number of\n * reactive properties that can be used to build UIs that respond\n * to the progress of a request.\n *\n */class RequestLoadingState{_trigger(){if(this._triggered){return;}this._triggered=true;const future=this._future;const promise=future.getStream();if(promise.sizeHint){this._sizeHint=promise.sizeHint;}this.promise=promise.then(stream=>{if(!stream){this._isPending=false;this._isComplete=true;return;}return watchStream(stream,this);},error=>{this._isPending=false;this._isStarted=false;if(isAbortError(error)){this._isCancelled=true;this._isComplete=true;}this._isErrored=true;this._error=error;});}get isPending(){this._trigger();return this._isPending;}get sizeHint(){this._trigger();return this._sizeHint;}get stream(){this._trigger();if(!this._stream){if(this._isComplete||this._isCancelled||this._isErrored){return null;}this._stream=new TransformStream();}return this._stream.readable;}get isStarted(){this._trigger();return this._isStarted;}get bytesLoaded(){this._trigger();return this._bytesLoaded;}get startTime(){this._trigger();return this._startTime;}get endTime(){this._trigger();return this._endTime;}get lastPacketTime(){this._trigger();return this._lastPacketTime;}get isComplete(){this._trigger();return this._isComplete;}get isCancelled(){this._trigger();return this._isCancelled;}get isErrored(){this._trigger();return this._isErrored;}get error(){this._trigger();return this._error;}get elapsedTime(){return(this.endTime||this.lastPacketTime)-this.startTime;}get completedRatio(){return this.sizeHint?this.bytesLoaded/this.sizeHint:0;}get remainingRatio(){return 1-this.completedRatio;}get duration(){return this.endTime-this.startTime;}get speed(){// bytes per second\nreturn this.bytesLoaded/(this.elapsedTime/1000);}constructor(future){_defineProperty(this,\"_stream\",null);_defineProperty(this,\"_future\",void 0);_defineProperty(this,\"_triggered\",false);_defineProperty(this,\"promise\",null);_defineProperty(this,\"abort\",()=>{this._future.abort();});this._future=future;}}defineNonEnumerableSignal(RequestLoadingState.prototype,'_isPending',true);defineNonEnumerableSignal(RequestLoadingState.prototype,'_isStarted',false);defineNonEnumerableSignal(RequestLoadingState.prototype,'_isComplete',false);defineNonEnumerableSignal(RequestLoadingState.prototype,'_isCancelled',false);defineNonEnumerableSignal(RequestLoadingState.prototype,'_isErrored',false);defineNonEnumerableSignal(RequestLoadingState.prototype,'_error',null);defineNonEnumerableSignal(RequestLoadingState.prototype,'_sizeHint',0);defineNonEnumerableSignal(RequestLoadingState.prototype,'_bytesLoaded',0);defineNonEnumerableSignal(RequestLoadingState.prototype,'_startTime',0);defineNonEnumerableSignal(RequestLoadingState.prototype,'_endTime',0);defineNonEnumerableSignal(RequestLoadingState.prototype,'_lastPacketTime',0);/**\n * The state of a request in the \"pending\"\n * state. This is the default initial state.\n *\n * Extends the {@link PendingPromise} interface.\n *\n *//**\n * The state of a request in the \"fulfilled\" state.\n * This is the state of a request that has resolved\n * successfully.\n *\n * Extends the {@link ResolvedPromise} interface.\n *\n *//**\n * The state of a request in the \"rejected\" state.\n * This is the state of a request that has rejected\n * with an error.\n *\n * Extends the {@link RejectedPromise} interface.\n *\n *//**\n * The state of a request in the \"cancelled\" state.\n * This is the state of a promise that has been\n * cancelled.\n *\n *//**\n * RequestState extends the concept of PromiseState to provide a reactive\n * wrapper for a request `Future` which allows you write declarative code\n * around a Future's control flow.\n *\n * It is useful in both Template and JavaScript contexts, allowing you\n * to quickly derive behaviors and data from pending, error and success\n * states.\n *\n * The key difference between a Promise and a Future is that Futures provide\n * access to a stream of their content, the identity of the request (if any)\n * as well as the ability to attempt to abort the request.\n *\n * ```ts\n * interface Future<T> extends Promise<T>> {\n *   getStream(): Promise<ReadableStream>;\n *   abort(): void;\n *   lid: StableDocumentIdentifier | null;\n * }\n * ```\n *\n * These additional APIs allow us to craft even richer state experiences.\n *\n * To get the state of a request, use `getRequestState`.\n *\n * See also:\n * - {@link PendingRequest}\n * - {@link ResolvedRequest}\n * - {@link RejectedRequest}\n * - {@link CancelledRequest}\n *\n */const RequestStateProto={};// TODO introduce a new mechanism for defining multiple properties\n// that share a common signal\ndefineSignal(RequestStateProto,'reason',null);defineSignal(RequestStateProto,'value',null);defineSignal(RequestStateProto,'result',null);defineSignal(RequestStateProto,'error',null);defineSignal(RequestStateProto,'status','pending');defineSignal(RequestStateProto,'isPending',true);defineSignal(RequestStateProto,'isLoading',true);defineSignal(RequestStateProto,'isSuccess',false);defineSignal(RequestStateProto,'isError',false);defineSignal(RequestStateProto,'request',null);defineSignal(RequestStateProto,'response',null);Object.defineProperty(RequestStateProto,'isCancelled',{get(){return this.isError&&isAbortError(this.reason);}});Object.defineProperty(RequestStateProto,'loadingState',{get(){if(!this._loadingState){this._loadingState=new RequestLoadingState(this._request);}return this._loadingState;}});function createRequestState(future){const state=(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_7__.g)(future);const promiseState=Object.create(RequestStateProto);promiseState._request=future;if(state){if(state.isError){promiseState.error=state.result;promiseState.reason=state.result;promiseState.status='rejected';promiseState.isError=true;promiseState.isPending=false;promiseState.isLoading=false;promiseState.request=state.result.request;promiseState.response=state.result.response;}else{promiseState.result=state.result.content;promiseState.value=state.result.content;promiseState.status='fulfilled';promiseState.isSuccess=true;promiseState.isPending=false;promiseState.isLoading=false;promiseState.request=state.result.request;promiseState.response=state.result.response;}}else{void future.then(result=>{(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_7__.s)(future,{isError:false,result});promiseState.result=result.content;promiseState.value=result.content;promiseState.status='fulfilled';promiseState.isSuccess=true;promiseState.isPending=false;promiseState.isLoading=false;promiseState.request=result.request;promiseState.response=result.response;},error=>{(0,_context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_7__.s)(future,{isError:true,result:error});promiseState.error=error;promiseState.reason=error;promiseState.status='rejected';promiseState.isError=true;promiseState.isPending=false;promiseState.isLoading=false;promiseState.request=error.request;promiseState.response=error.response;});}return promiseState;}/**\n * `getRequestState` can be used in both JavaScript and Template contexts.\n *\n * ```ts\n * import { getRequestState } from '@warp-drive/ember';\n *\n * const state = getRequestState(future);\n * ```\n *\n * For instance, we could write a getter on a component that updates whenever\n * the request state advances or the future changes, by combining the function\n * with the use of `@cached`\n *\n * ```ts\n * class Component {\n *   @cached\n *   get title() {\n *     const state = getRequestState(this.args.request);\n *     if (state.isPending) {\n *       return 'loading...';\n *     }\n *     if (state.isError) { return null; }\n *     return state.result.title;\n *   }\n * }\n * ```\n *\n * Or in a template as a helper:\n *\n * ```gjs\n * import { getRequestState } from '@warp-drive/ember';\n *\n * <template>\n *   {{#let (getRequestState @request) as |state|}}\n *     {{#if state.isPending}}\n *       <Spinner />\n *     {{else if state.isError}}\n *       <ErrorForm @error={{state.error}} />\n *     {{else}}\n *       <h1>{{state.result.title}}</h1>\n *     {{/if}}\n *   {{/let}}\n * </template>\n * ```\n *\n * If looking to use in a template, consider also the `<Request />` component\n * which offers a numbe of additional capabilities for requests *beyond* what\n * `RequestState` provides.\n *\n */function getRequestState(future){let state=RequestCache.get(future);if(!state){state=createRequestState(future);RequestCache.set(future,state);}return state;}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/request-state-CjLph1LP.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/request.js":
/*!*******************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/request.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDeferred: () => (/* reexport safe */ _context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   getPromiseResult: () => (/* reexport safe */ _context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   setPromiseResult: () => (/* reexport safe */ _context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_0__.s)\n/* harmony export */ });\n/* harmony import */ var _context_COmAnXUQ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context-COmAnXUQ.js */ \"./node_modules/@warp-drive/core/dist/context-COmAnXUQ.js\");\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/request.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/store/-private.js":
/*!**************************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/store/-private.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ARRAY_SIGNAL: () => (/* reexport safe */ _configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_2__.A),\n/* harmony export */   CacheHandler: () => (/* reexport safe */ _handler_C2T_IyJK_js__WEBPACK_IMPORTED_MODULE_1__.C),\n/* harmony export */   CollectionRecordArray: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   DISPOSE: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   LiveArray: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   MUTATE: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   OBJECT_SIGNAL: () => (/* reexport safe */ _configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_2__.O),\n/* harmony export */   RecordArrayManager: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.R),\n/* harmony export */   RelatedCollection: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   SOURCE: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   Signals: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   Store: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   StoreMap: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   _clearCaches: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   _deprecatingNormalize: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   coerceId: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   constructResource: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   consumeInternalSignal: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   createMemo: () => (/* reexport safe */ _configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_2__.c),\n/* harmony export */   createRequestSubscription: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   defineNonEnumerableSignal: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   defineSignal: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   ensureStringId: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   entangleSignal: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   fastPush: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   gate: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   getOrCreateInternalSignal: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.H),\n/* harmony export */   getPromiseState: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   getRequestState: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   isDocumentIdentifier: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   isStableIdentifier: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   log: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   logGroup: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   memoized: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   notifyInternalSignal: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   peekCache: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   peekInternalSignal: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.B),\n/* harmony export */   recordIdentifierFor: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   removeRecordDataFor: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   setCacheFor: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   setRecordIdentifier: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   storeFor: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   waitFor: () => (/* reexport safe */ _configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_2__.w),\n/* harmony export */   withSignalStore: () => (/* reexport safe */ _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__.E)\n/* harmony export */ });\n/* harmony import */ var _request_state_CjLph1LP_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../request-state-CjLph1LP.js */ \"./node_modules/@warp-drive/core/dist/request-state-CjLph1LP.js\");\n/* harmony import */ var _handler_C2T_IyJK_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../handler-C2T-IyJK.js */ \"./node_modules/@warp-drive/core/dist/handler-C2T-IyJK.js\");\n/* harmony import */ var _configure_B48bFHOl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../configure-B48bFHOl.js */ \"./node_modules/@warp-drive/core/dist/configure-B48bFHOl.js\");\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/store/-private.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/types/-private.js":
/*!**************************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/types/-private.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getOrSetGlobal: () => (/* binding */ getOrSetGlobal),\n/* harmony export */   getOrSetUniversal: () => (/* binding */ getOrSetUniversal),\n/* harmony export */   peekTransient: () => (/* binding */ peekTransient),\n/* harmony export */   peekUniversalTransient: () => (/* binding */ peekUniversalTransient),\n/* harmony export */   setTransient: () => (/* binding */ setTransient),\n/* harmony export */   setUniversalTransient: () => (/* binding */ setUniversalTransient)\n/* harmony export */ });\nconst name=\"@warp-drive/core\";const version=\"5.6.0\";// in testing mode, we utilize globals to ensure only one copy exists of\n// these maps, due to bugs in ember-auto-import\nconst GlobalRef=globalThis;const UniversalCache=GlobalRef.__warpDrive_universalCache=GlobalRef.__warpDrive_universalCache??{};// in order to support mirror packages, we ensure that each\n// unique package name has its own global cache\nGlobalRef[name]=GlobalRef[name]??{__version:version};const GlobalSink=GlobalRef[name];{if(GlobalSink.__version!==version){throw new Error('Multiple versions of WarpDrive detected, the application will malfunction.');}}const ModuleScopedCaches=GlobalSink.__warpDrive_ModuleScopedCaches??{};{if(!GlobalSink.__warpDrive_ModuleScopedCaches){GlobalSink.__warpDrive_ModuleScopedCaches=ModuleScopedCaches;}else{// eslint-disable-next-line no-console\nconsole.warn(`\nMultiple copies of WarpDrive have been detected. This may be due to a bug in ember-auto-import\n  in which test assets get their own copy of some v2-addons. This can cause the application to\n  malfunction as each copy will maintain its own separate state.`);}}function getOrSetGlobal(key,value){{const existing=ModuleScopedCaches[key];if(existing===undefined){return ModuleScopedCaches[key]=value;}else{return existing;}}}function peekTransient(key){const globalKey=`(transient) ${key}`;return ModuleScopedCaches[globalKey]??null;}function setTransient(key,value){const globalKey=`(transient) ${key}`;return ModuleScopedCaches[globalKey]=value;}function getOrSetUniversal(key,value){{const existing=UniversalCache[key];if(existing===undefined){return UniversalCache[key]=value;}else{return existing;}}}function peekUniversalTransient(key){const globalKey=`(transient) ${key}`;return UniversalCache[globalKey]??null;}function setUniversalTransient(key,value){const globalKey=`(transient) ${key}`;return UniversalCache[globalKey]=value;}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/types/-private.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/types/identifier.js":
/*!****************************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/types/identifier.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CACHE_OWNER: () => (/* binding */ CACHE_OWNER),\n/* harmony export */   DEBUG_CLIENT_ORIGINATED: () => (/* binding */ DEBUG_CLIENT_ORIGINATED),\n/* harmony export */   DEBUG_IDENTIFIER_BUCKET: () => (/* binding */ DEBUG_IDENTIFIER_BUCKET),\n/* harmony export */   DEBUG_STALE_CACHE_OWNER: () => (/* binding */ DEBUG_STALE_CACHE_OWNER)\n/* harmony export */ });\n// provided for additional debuggability\nconst DEBUG_CLIENT_ORIGINATED=Symbol('record-originated-on-client');const DEBUG_IDENTIFIER_BUCKET=Symbol('identifier-bucket');const DEBUG_STALE_CACHE_OWNER=Symbol('warpDriveStaleCache');function ProdSymbol(str,debugStr){return Symbol(debugStr);}// also present in production\nconst CACHE_OWNER=ProdSymbol('__$co','CACHE_OWNER');/**\n * An Identifier specific to a record which may or may not\n * be present in the cache.\n *\n * The absence of an `id` DOES NOT indicate that this\n * Identifier is for a new client-created record as it\n * may also indicate that it was generated for a secondary\n * index and the primary `id` index is not yet known.\n *\n * @internal\n *//**\n * Used when an Identifier is known to be the stable version\n *\n * @internal\n *//**\n * Used when a StableRecordIdentifier was not created locally as part\n * of a call to store.createRecord\n *\n * Distinguishing between this Identifier and one for a client created\n * record that was created with an ID is generally speaking not possible\n * at runtime, so anything with an ID typically narrows to this.\n *\n * @internal\n *//**\n * Used when a StableRecordIdentifier was created locally\n * (by a call to store.createRecord).\n *\n * It is possible in rare circumstances to have a StableRecordIdentifier\n * that is not for a new record but does not have an ID. This would\n * happen if a user intentionally created one for use with a secondary-index\n * prior to the record having been fully loaded.\n *\n * @internal\n *//**\n * A referentially stable object with a unique string (lid) that can be used\n * as a reference to data in the cache.\n *\n * Every record instance has a unique identifier, and identifiers may refer\n * to data that has never been loaded (for instance, in an async relationship).\n *\n * @class StableRecordIdentifier\n * @public\n *//**\n * A string representing a unique identity.\n *\n * @property lid\n * @type {String}\n * @public\n *//**\n * the primary resource `type` or `modelName` this identity belongs to.\n *\n * @property type\n * @type {String}\n * @public\n *//**\n * the primary id for the record this identity belongs to. `null`\n * if not yet assigned an id.\n *\n * @property id\n * @type {String | null}\n * @public\n */\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/types/identifier.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/types/request.js":
/*!*************************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/types/request.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnableHydration: () => (/* binding */ EnableHydration),\n/* harmony export */   IS_FUTURE: () => (/* binding */ IS_FUTURE),\n/* harmony export */   STRUCTURED: () => (/* binding */ STRUCTURED),\n/* harmony export */   SkipCache: () => (/* binding */ SkipCache),\n/* harmony export */   withBrand: () => (/* binding */ withBrand)\n/* harmony export */ });\n/* harmony import */ var _private_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./-private.js */ \"./node_modules/@warp-drive/core/dist/types/-private.js\");\nconst SkipCache=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetUniversal)('SkipCache',Symbol.for('wd:skip-cache'));const EnableHydration=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetUniversal)('EnableHydration',Symbol.for('wd:enable-hydration'));const IS_FUTURE=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('IS_FUTURE',Symbol('IS_FUTURE'));const STRUCTURED=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('DOC',Symbol('DOC'));/**\n * Use these options to adjust CacheHandler behavior for a request.\n *\n *//**\n * JavaScript's native Request class.\n *\n * WarpDrive provides our own typings due to incompleteness in the native typings.\n *\n *//**\n * Extends JavaScript's native {@link Request} object with additional\n * properties specific to the RequestManager's capabilities.\n *\n *//**\n * Immutable version of {@link RequestInfo}. This is what is passed to handlers.\n *\n */function withBrand(obj){return obj;}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/types/request.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/types/runtime.js":
/*!*************************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/types/runtime.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getRuntimeConfig: () => (/* binding */ getRuntimeConfig),\n/* harmony export */   setLogging: () => (/* binding */ setLogging)\n/* harmony export */ });\n/* harmony import */ var _private_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./-private.js */ \"./node_modules/@warp-drive/core/dist/types/-private.js\");\nconst RuntimeConfig=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetUniversal)('WarpDriveRuntimeConfig',{debug:{}});function trySessionStorage(){// This works even when sessionStorage is not available.\n// See https://github.com/emberjs/data/issues/9784\ntry{return globalThis.sessionStorage;}catch{return undefined;}}const storage=trySessionStorage();const settings=storage?.getItem('WarpDriveRuntimeConfig');if(settings){Object.assign(RuntimeConfig,JSON.parse(settings));}function getRuntimeConfig(){return RuntimeConfig;}/**\n * Upserts the specified logging configuration into the runtime\n * config.\n *\n * globalThis.setWarpDriveLogging({ LOG_CACHE: true } });\n *\n */function setLogging(config){Object.assign(RuntimeConfig.debug,config);storage?.setItem('WarpDriveRuntimeConfig',JSON.stringify(RuntimeConfig));}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/types/runtime.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/types/symbols.js":
/*!*************************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/types/symbols.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RecordStore: () => (/* binding */ RecordStore),\n/* harmony export */   RequestSignature: () => (/* binding */ RequestSignature),\n/* harmony export */   ResourceType: () => (/* binding */ ResourceType),\n/* harmony export */   TransformName: () => (/* binding */ TransformName),\n/* harmony export */   Type: () => (/* binding */ Type)\n/* harmony export */ });\n/* harmony import */ var _private_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./-private.js */ \"./node_modules/@warp-drive/core/dist/types/-private.js\");\nconst RecordStore=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('Store',Symbol('Store'));/**\n * Symbol for the name of a resource, transformation\n * or derivation.\n *\n * ### With Resources\n *\n * This is an optional feature that can be used by\n * record implementations to provide a typescript\n * hint for the type of the resource.\n *\n * When used, EmberData/WarpDrive APIs can\n * take advantage of this to provide better type\n * safety and intellisense.\n *\n * ### With Derivations\n *\n * Required for derivations registered with\n * `store.registerDerivation(derivation)`.\n *\n * ```ts\n * function concat(record: object, options: ObjectValue | null, prop: string): string {}\n * concat[Name] = 'concat';\n * ```\n *\n * ### With Transforms\n *\n * Required for new-style transformations registered\n * with `store.registerTransform(transform)`.\n *\n * For legacy transforms, if not used,\n * `attr<Transform>('name')` will allow any string name.\n * `attr('name')` will always allow any string name.\n *\n * If used, `attr<Transform>('name')` will enforce\n * that the name is the same as the transform name.\n *\n * @type {Symbol}\n */const Type=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('$type',Symbol('$type'));/**\n * Symbol for the type of a resource.\n *\n * This is an optional feature that can be used by\n * record implementations to provide a typescript\n * hint for the type of the resource.\n *\n * When used, EmberData/WarpDrive APIs can\n * take advantage of this to provide better type\n * safety and intellisense.\n *\n * @type {Symbol}\n */const ResourceType=Type;/**\n * Symbol for the name of a transform.\n *\n * This is an optional feature that can be used by\n * transform implementations to provide a typescript\n * hint for the name of the transform.\n *\n * If not used, `attr<Transform>('name')` will\n * allow any string name. `attr('name')` will always\n * allow any string name.\n *\n * If used, `attr<Transform>('name')` will enforce\n * that the name is the same as the transform name.\n *\n * @type {Symbol}\n */const TransformName=Type;/**\n * Symbol for use by builders to indicate the return type\n * generic to use for store.request()\n *\n * @type {Symbol}\n */const RequestSignature=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('RequestSignature',Symbol('RequestSignature'));\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/types/symbols.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/core/dist/utils/string.js":
/*!************************************************************!*\
  !*** ./node_modules/@warp-drive/core/dist/utils/string.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LRUCache: () => (/* binding */ LRUCache),\n/* harmony export */   STRING_DASHERIZE_CACHE: () => (/* binding */ STRING_DASHERIZE_CACHE),\n/* harmony export */   dasherize: () => (/* binding */ dasherize)\n/* harmony export */ });\nconst DEFAULT_MAX_CACHE_SIZE=10_000;/**\n * An LRUCache implementation with upsert semantics.\n *\n * This implementation is *not* generic, but focuses on\n * performance tuning for the string transformation cases\n * where the key maps to the value very simply.\n *\n * It takes a work function that should generate a new value\n * for a given key when called. It will be called when the key\n * is not found in the cache.\n *\n * It keeps track of the number of hits, misses, and ejections\n * in DEBUG envs, which is useful for tuning the cache size.\n *\n * This is an internal utility class for use by this module\n * and by `@warp-drive/utilities/string`. It is not intended\n * for use outside of these modules at this time.\n *\n * @internal\n */class LRUCache{// debug stats\nconstructor(doWork,size){this.size=size||DEFAULT_MAX_CACHE_SIZE;this.state=new Map();this.doWork=doWork;{this._hits=0;this._misses=0;this._ejected=0;}}get(key){const value=this.state.get(key);if(value){{this._hits++;}this.state.delete(key);this.state.set(key,value);return value;}{this._misses++;}const newValue=this.doWork(key);this.set(key,newValue);return newValue;}set(key,value){if(this.state.size===this.size){for(const[k]of this.state){{this._ejected++;}this.state.delete(k);break;}}this.state.set(key,value);}clear(){this.state.clear();{this._hits=0;this._misses=0;this._ejected=0;}}}const STRING_DASHERIZE_REGEXP=/[ _]/g;const STRING_DECAMELIZE_REGEXP=/([a-z\\d])([A-Z])/g;const STRING_DASHERIZE_CACHE=new LRUCache(key=>key.replace(STRING_DECAMELIZE_REGEXP,'$1_$2').toLowerCase().replace(STRING_DASHERIZE_REGEXP,'-'));/**\n * This is an internal utility function that converts a string\n * to a dasherized format. Library consumers should use the\n * re-exported version from `@warp-drive/utilities/string` instead.\n *\n * This version is only in this location to support a deprecated\n * behavior in the core package and will be removed in a future.\n *\n * @internal\n */function dasherize(str){return STRING_DASHERIZE_CACHE.get(str);}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core/dist/utils/string.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/legacy/dist/-private-CKrP0ogQ.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@warp-drive/legacy/dist/-private-CKrP0ogQ.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   F: () => (/* binding */ FetchManager),\n/* harmony export */   S: () => (/* binding */ SaveOp),\n/* harmony export */   a: () => (/* binding */ assertIdentifierHasId),\n/* harmony export */   b: () => (/* binding */ SnapshotRecordArray),\n/* harmony export */   c: () => (/* binding */ Snapshot),\n/* harmony export */   i: () => (/* binding */ iterateData),\n/* harmony export */   n: () => (/* binding */ normalizeResponseHelper),\n/* harmony export */   p: () => (/* binding */ payloadIsNotBlank),\n/* harmony export */   u: () => (/* binding */ upgradeStore)\n/* harmony export */ });\n/* harmony import */ var _warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @warp-drive/core/store/-private */ \"./node_modules/@warp-drive/core/dist/store/-private.js\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _warp_drive_core_request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @warp-drive/core/request */ \"./node_modules/@warp-drive/core/dist/request.js\");\n/* harmony import */ var _warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @warp-drive/core/types/-private */ \"./node_modules/@warp-drive/core/dist/types/-private.js\");\n/**\n  SnapshotRecordArray is not directly instantiable.\n  Instances are provided to consuming application's\n  adapters for certain `findAll` requests.\n\n  @class SnapshotRecordArray\n  @public\n*/class SnapshotRecordArray{/**\n    SnapshotRecordArray is not directly instantiable.\n    Instances are provided to consuming application's\n    adapters and serializers for certain requests.\n     @private\n    @constructor\n    @param {Store} store\n    @param {String} type\n    @param options\n   */constructor(store,type,options={}){this.__store=store;/**\n      An array of snapshots\n      @private\n      @property _snapshots\n      @type {Array}\n    */this._snapshots=null;/**\n    The modelName of the underlying records for the snapshots in the array, as a Model\n    @property modelName\n    @public\n    @type {Model}\n    */this.modelName=type;/**\n      A hash of adapter options passed into the store method for this request.\n       Example\n       ```js [app/adapters/post.js]\n      import MyCustomAdapter from './custom-adapter';\n       export default class PostAdapter extends MyCustomAdapter {\n        findAll(store, type, sinceToken, snapshotRecordArray) {\n          if (snapshotRecordArray.adapterOptions.subscribe) {\n            // ...\n          }\n          // ...\n        }\n      }\n      ```\n       @property adapterOptions\n      @public\n      @type {Object}\n    */this.adapterOptions=options.adapterOptions;/**\n      The relationships to include for this request.\n       Example\n       ```js [app/adapters/application.js]\n      import Adapter from '@ember-data/adapter';\n       export default class ApplicationAdapter extends Adapter {\n        findAll(store, type, snapshotRecordArray) {\n          let url = `/${type.modelName}?include=${encodeURIComponent(snapshotRecordArray.include)}`;\n           return fetch(url).then((response) => response.json())\n        }\n      }\n      ```\n       @property include\n      @public\n      @type {String|Array}\n    */this.include=options.include;}/**\n    An array of records\n     @property _recordArray\n    @private\n    @type {Array}\n  */get _recordArray(){return this.__store.peekAll(this.modelName);}/**\n      Number of records in the array\n       Example\n       ```js [app/adapters/post.js]\n      import JSONAPIAdapter from '@ember-data/adapter/json-api';\n       export default class PostAdapter extends JSONAPIAdapter {\n        shouldReloadAll(store, snapshotRecordArray) {\n          return !snapshotRecordArray.length;\n        }\n      });\n      ```\n       @property length\n      @public\n      @type {Number}\n    */get length(){return this._recordArray.length;}/**\n    Get snapshots of the underlying record array\n     Example\n     ```js [app/adapters/post.js]\n    import JSONAPIAdapter from '@ember-data/adapter/json-api';\n     export default class PostAdapter extends JSONAPIAdapter {\n      shouldReloadAll(store, snapshotArray) {\n        let snapshots = snapshotArray.snapshots();\n         return snapshots.any(function(ticketSnapshot) {\n          let timeDiff = moment().diff(ticketSnapshot.attr('lastAccessedAt'), 'minutes');\n          if (timeDiff > 20) {\n            return true;\n          } else {\n            return false;\n          }\n        });\n      }\n    }\n    ```\n     @public\n    @return Array of snapshots\n  */snapshots(){if(this._snapshots!==null){return this._snapshots;}upgradeStore(this.__store);const{_fetchManager}=this.__store;this._snapshots=this._recordArray[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.SOURCE].map(identifier=>_fetchManager.createSnapshot(identifier));return this._snapshots;}}function assertIdentifierHasId(identifier){(test=>{if(!test){throw new Error(`Attempted to schedule a fetch for a record without an id.`);}})(identifier&&identifier.id!==null);}function iterateData(data,fn){if(Array.isArray(data)){return data.map(fn);}else{return fn(data,0);}}function payloadIsNotBlank(adapterPayload){if(Array.isArray(adapterPayload)){return true;}else{return Object.keys(adapterPayload||{}).length!==0;}}/**\n  This is a helper method that validates a JSON API top-level document\n\n  The format of a document is described here:\n  http://jsonapi.org/format/#document-top-level\n\n  @internal\n*/function validateDocumentStructure(doc){{const errors=[];if(!doc||typeof doc!=='object'){errors.push('Top level of a JSON API document must be an object');}else{if(!('data'in doc)&&!('errors'in doc)&&!('meta'in doc)){errors.push('One or more of the following keys must be present: \"data\", \"errors\", \"meta\".');}else{if('data'in doc&&'errors'in doc){errors.push('Top level keys \"errors\" and \"data\" cannot both be present in a JSON API document');}}if('data'in doc){if(!(doc.data===null||Array.isArray(doc.data)||typeof doc.data==='object')){errors.push('data must be null, an object, or an array');}}if('meta'in doc){if(typeof doc.meta!=='object'){errors.push('meta must be an object');}}if('errors'in doc){if(!Array.isArray(doc.errors)){errors.push('errors must be an array');}}if('links'in doc){if(typeof doc.links!=='object'){errors.push('links must be an object');}}if('jsonapi'in doc){if(typeof doc.jsonapi!=='object'){errors.push('jsonapi must be an object');}}if('included'in doc){if(typeof doc.included!=='object'){errors.push('included must be an array');}}}(test=>{if(!test){throw new Error(`Response must be normalized to a valid JSON API document:\\n\\t* ${errors.join('\\n\\t* ')}`);}})(errors.length===0);}}function normalizeResponseHelper(serializer,store,modelClass,payload,id,requestType){const normalizedResponse=serializer?serializer.normalizeResponse(store,modelClass,payload,id,requestType):payload;validateDocumentStructure(normalizedResponse);return normalizedResponse;}/**\n  Snapshot is not directly instantiable.\n  Instances are provided to a consuming application's\n  adapters and serializers for certain requests.\n\n  Snapshots are only available when using `@ember-data/legacy-compat`\n  for legacy compatibility with adapters and serializers.\n\n  @class Snapshot\n  @public\n*/class Snapshot{/**\n   * @constructor\n   * @private\n   * @param options\n   * @param identifier\n   * @param _store\n   */constructor(options,identifier,store){this._store=store;this.__attributes=null;this._belongsToRelationships=Object.create(null);this._belongsToIds=Object.create(null);this._hasManyRelationships=Object.create(null);this._hasManyIds=Object.create(null);const hasRecord=!!store._instanceCache.peek(identifier);this.modelName=identifier.type;/**\n      The unique RecordIdentifier associated with this Snapshot.\n       @property identifier\n      @public\n      @type {StableRecordIdentifier}\n    */this.identifier=identifier;/*\n      If the we do not yet have a record, then we are\n      likely a snapshot being provided to a find request, so we\n      populate __attributes lazily. Else, to preserve the \"moment\n      in time\" in which a snapshot is created, we greedily grab\n      the values.\n     */if(hasRecord){// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nthis._attributes;}/**\n     The id of the snapshot's underlying record\n      Example\n      ```javascript\n     // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\n     postSnapshot.id; // => '1'\n     ```\n      @property id\n     @type {String}\n     @public\n     */this.id=identifier.id;/**\n     A hash of adapter options\n     @property adapterOptions\n     @type {Object}\n     @public\n     */this.adapterOptions=options.adapterOptions;/**\n     If `include` was passed to the options hash for the request, the value\n     would be available here.\n      @property include\n     @type {String|Array}\n     @public\n     */this.include=options.include;/**\n     The name of the type of the underlying record for this snapshot, as a string.\n      @property modelName\n     @type {String}\n     @public\n     */this.modelName=identifier.type;if(hasRecord){const cache=this._store.cache;this._changedAttributes=cache.changedAttrs(identifier);}}/**\n   The underlying record for this snapshot. Can be used to access methods and\n   properties defined on the record.\n    Example\n    ```javascript\n   let json = snapshot.record.toJSON();\n   ```\n    @property record\n   @type {Model}\n   @public\n   */get record(){const record=this._store.peekRecord(this.identifier);(test=>{if(!test){throw new Error(`Record ${this.identifier.type} ${this.identifier.id} (${this.identifier.lid}) is not yet loaded and thus cannot be accessed from the Snapshot during serialization`);}})(record!==null);return record;}get _attributes(){if(this.__attributes!==null){return this.__attributes;}const attributes=this.__attributes=Object.create(null);const{identifier}=this;const attrs=this._store.schema.fields(identifier);const cache=this._store.cache;attrs.forEach((field,keyName)=>{if(field.kind==='attribute'){attributes[keyName]=cache.getAttr(identifier,keyName);}});return attributes;}get isNew(){const cache=this._store.cache;return cache?.isNew(this.identifier)||false;}/**\n   Returns the value of an attribute.\n    Example\n    ```javascript\n   // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\n   postSnapshot.attr('author'); // => 'Tomster'\n   postSnapshot.attr('title'); // => 'Ember.js rocks'\n   ```\n    Note: Values are loaded eagerly and cached when the snapshot is created.\n    @param {String} keyName\n   @return {Object} The attribute value or undefined\n   @public\n   */attr(keyName){if(keyName in this._attributes){return this._attributes[keyName];}(test=>{{throw new Error(`Model '${this.identifier.lid}' has no attribute named '${keyName}' defined.`);}})();}/**\n   Returns all attributes and their corresponding values.\n    Example\n    ```javascript\n   // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\n   postSnapshot.attributes(); // => { author: 'Tomster', title: 'Ember.js rocks' }\n   ```\n    @return {Object} All attributes of the current snapshot\n   @public\n   */attributes(){return{...this._attributes};}/**\n   Returns all changed attributes and their old and new values.\n    Example\n    ```javascript\n   // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\n   postModel.set('title', 'Ember.js rocks!');\n   postSnapshot.changedAttributes(); // => { title: ['Ember.js rocks', 'Ember.js rocks!'] }\n   ```\n    @return {Object} All changed attributes of the current snapshot\n   @public\n   */changedAttributes(){const changedAttributes=Object.create(null);if(!this._changedAttributes){return changedAttributes;}const changedAttributeKeys=Object.keys(this._changedAttributes);for(let i=0,length=changedAttributeKeys.length;i<length;i++){const key=changedAttributeKeys[i];changedAttributes[key]=this._changedAttributes[key].slice();}return changedAttributes;}/**\n   Returns the current value of a belongsTo relationship.\n    `belongsTo` takes an optional hash of options as a second parameter,\n   currently supported options are:\n    - `id`: set to `true` if you only want the ID of the related record to be\n   returned.\n    Example\n    ```javascript\n   // store.push('post', { id: 1, title: 'Hello World' });\n   // store.createRecord('comment', { body: 'Lorem ipsum', post: post });\n   commentSnapshot.belongsTo('post'); // => Snapshot\n   commentSnapshot.belongsTo('post', { id: true }); // => '1'\n    // store.push('comment', { id: 1, body: 'Lorem ipsum' });\n   commentSnapshot.belongsTo('post'); // => undefined\n   ```\n    Calling `belongsTo` will return a new Snapshot as long as there's any known\n   data for the relationship available, such as an ID. If the relationship is\n   known but unset, `belongsTo` will return `null`. If the contents of the\n   relationship is unknown `belongsTo` will return `undefined`.\n    Note: Relationships are loaded lazily and cached upon first access.\n    @param {String} keyName\n   @param {Object} [options]\n   @public\n   @return {(Snapshot|String|null|undefined)} A snapshot or ID of a known\n   relationship or null if the relationship is known but unset. undefined\n   will be returned if the contents of the relationship is unknown.\n   */belongsTo(keyName,options){const returnModeIsId=!!(options&&options.id);let result;const store=this._store;if(returnModeIsId===true&&keyName in this._belongsToIds){return this._belongsToIds[keyName];}if(returnModeIsId===false&&keyName in this._belongsToRelationships){return this._belongsToRelationships[keyName];}const relationshipMeta=store.schema.fields({type:this.modelName}).get(keyName);(test=>{if(!test){throw new Error(`Model '${this.identifier.lid}' has no belongsTo relationship named '${keyName}' defined.`);}})(relationshipMeta&&relationshipMeta.kind==='belongsTo');(test=>{if(!test){throw new Error(`snapshot.belongsTo only supported when using a cache that supports the graph`);}})(this._store._graph);const{identifier}=this;{const relationship=this._store.schema.fields(identifier)?.get(keyName);(test=>{if(!test){throw new Error(`You looked up the ${keyName} belongsTo relationship for { type: ${identifier.type}, id: ${identifier.id||''}, lid: ${identifier.lid} but no such relationship was found.`);}})(relationship);(test=>{if(!test){throw new Error(`You looked up the ${keyName} belongsTo relationship for { type: ${identifier.type}, id: ${identifier.id||''}, lid: ${identifier.lid} but that relationship is a hasMany.`);}})(relationship.kind==='belongsTo');}const value=this._store.cache.getRelationship(identifier,keyName);const data=value&&value.data;const inverseIdentifier=data?store.identifierCache.getOrCreateRecordIdentifier(data):null;if(value&&value.data!==undefined){const cache=store.cache;if(inverseIdentifier&&!cache.isDeleted(inverseIdentifier)){if(returnModeIsId){result=inverseIdentifier.id;}else{result=store._fetchManager.createSnapshot(inverseIdentifier);}}else{result=null;}}if(returnModeIsId){this._belongsToIds[keyName]=result;}else{this._belongsToRelationships[keyName]=result;}return result;}/**\n   Returns the current value of a hasMany relationship.\n    `hasMany` takes an optional hash of options as a second parameter,\n   currently supported options are:\n    - `ids`: set to `true` if you only want the IDs of the related records to be\n   returned.\n    Example\n    ```javascript\n   // store.push('post', { id: 1, title: 'Hello World', comments: [2, 3] });\n   postSnapshot.hasMany('comments'); // => [Snapshot, Snapshot]\n   postSnapshot.hasMany('comments', { ids: true }); // => ['2', '3']\n    // store.push('post', { id: 1, title: 'Hello World' });\n   postSnapshot.hasMany('comments'); // => undefined\n   ```\n    Note: Relationships are loaded lazily and cached upon first access.\n    @param {String} keyName\n   @param {Object} [options]\n   @public\n   @return {(Array|undefined)} An array of snapshots or IDs of a known\n   relationship or an empty array if the relationship is known but unset.\n   undefined will be returned if the contents of the relationship is unknown.\n   */hasMany(keyName,options){const returnModeIsIds=!!(options&&options.ids);let results;const cachedIds=this._hasManyIds[keyName];const cachedSnapshots=this._hasManyRelationships[keyName];if(returnModeIsIds===true&&keyName in this._hasManyIds){return cachedIds;}if(returnModeIsIds===false&&keyName in this._hasManyRelationships){return cachedSnapshots;}const store=this._store;const relationshipMeta=store.schema.fields({type:this.modelName}).get(keyName);(test=>{if(!test){throw new Error(`Model '${this.identifier.lid}' has no hasMany relationship named '${keyName}' defined.`);}})(relationshipMeta&&relationshipMeta.kind==='hasMany');// TODO @runspired it seems this code branch would not work with CUSTOM_MODEL_CLASSes\n// this check is not a regression in behavior because relationships don't currently\n// function without access to intimate API contracts between RecordData and Model.\n// This is a requirement we should fix as soon as the relationship layer does not require\n// this intimate API usage.\n(test=>{if(!test){throw new Error(`snapshot.hasMany only supported when using a cache that supports the graph`);}})(this._store._graph);const{identifier}=this;{const relationship=this._store.schema.fields(identifier)?.get(keyName);(test=>{if(!test){throw new Error(`You looked up the ${keyName} hasMany relationship for { type: ${identifier.type}, id: ${identifier.id||''}, lid: ${identifier.lid} but no such relationship was found.`);}})(relationship);(test=>{if(!test){throw new Error(`You looked up the ${keyName} hasMany relationship for { type: ${identifier.type}, id: ${identifier.id||''}, lid: ${identifier.lid} but that relationship is a belongsTo.`);}})(relationship.kind==='hasMany');}const value=this._store.cache.getRelationship(identifier,keyName);if(value.data){results=[];value.data.forEach(member=>{const inverseIdentifier=store.identifierCache.getOrCreateRecordIdentifier(member);const cache=store.cache;if(!cache.isDeleted(inverseIdentifier)){if(returnModeIsIds){results.push(inverseIdentifier.id);}else{results.push(store._fetchManager.createSnapshot(inverseIdentifier));}}});}// we assign even if `undefined` so that we don't reprocess the relationship\n// on next access. This works with the `keyName in` checks above.\nif(returnModeIsIds){this._hasManyIds[keyName]=results;}else{this._hasManyRelationships[keyName]=results;}return results;}/**\n    Iterates through all the attributes of the model, calling the passed\n    function on each attribute.\n     Example\n     ```javascript\n    snapshot.eachAttribute(function(name, meta) {\n      // ...\n    });\n    ```\n     @param {Function} callback the callback to execute\n    @param {Object} [binding] the value to which the callback's `this` should be bound\n    @public\n  */eachAttribute(callback,binding){const fields=this._store.schema.fields(this.identifier);fields.forEach((field,key)=>{if(field.kind==='attribute'){callback.call(binding,key,field);}});}/**\n    Iterates through all the relationships of the model, calling the passed\n    function on each relationship.\n     Example\n     ```javascript\n    snapshot.eachRelationship(function(name, relationship) {\n      // ...\n    });\n    ```\n     @param {Function} callback the callback to execute\n    @param {Object} [binding] the value to which the callback's `this` should be bound\n    @public\n  */eachRelationship(callback,binding){const fields=this._store.schema.fields(this.identifier);fields.forEach((field,key)=>{if(field.kind==='belongsTo'||field.kind==='hasMany'){callback.call(binding,key,field);}});}/**\n    Serializes the snapshot using the serializer for the model.\n     Example\n     ```js [app/adapters/application.js]\n    import Adapter from '@ember-data/adapter';\n     export default Adapter.extend({\n      createRecord(store, type, snapshot) {\n        let data = snapshot.serialize({ includeId: true });\n        let url = `/${type.modelName}`;\n         return fetch(url, {\n          method: 'POST',\n          body: data,\n        }).then((response) => response.json())\n      }\n    });\n    ```\n     @param {Object} options\n    @return {Object} an object whose values are primitive JSON values only\n    @public\n   */serialize(options){upgradeStore(this._store);const serializer=this._store.serializerFor(this.modelName);(test=>{if(!test){throw new Error(`Cannot serialize record, no serializer found`);}})(serializer);return serializer.serialize(this,options);}}const SaveOp=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('SaveOp',Symbol('SaveOp'));class FetchManager{// fetches pending in the runloop, waiting to be coalesced\nconstructor(store){this._store=store;// used to keep track of all the find requests that need to be coalesced\nthis._pendingFetch=new Map();this.requestCache=store.getRequestStateService();this.isDestroyed=false;}createSnapshot(identifier,options={}){return new Snapshot(options,identifier,this._store);}/**\n    This method is called by `record.save`, and gets passed a\n    resolver for the promise that `record.save` returns.\n     It schedules saving to happen at the end of the run loop.\n     @internal\n  */scheduleSave(identifier,options){const resolver=(0,_warp_drive_core_request__WEBPACK_IMPORTED_MODULE_2__.createDeferred)();const query={op:'saveRecord',recordIdentifier:identifier,options};const queryRequest={data:[query]};const snapshot=this.createSnapshot(identifier,options);const pendingSaveItem={snapshot:snapshot,resolver:resolver,identifier,options,queryRequest};const monitored=this.requestCache._enqueue(resolver.promise,pendingSaveItem.queryRequest);_flushPendingSave(this._store,pendingSaveItem);return monitored;}scheduleFetch(identifier,options,request){const query={op:'findRecord',recordIdentifier:identifier,options};const queryRequest={data:[query]};const pendingFetch=this.getPendingFetch(identifier,options);if(pendingFetch){return pendingFetch;}const modelName=identifier.type;const resolver=(0,_warp_drive_core_request__WEBPACK_IMPORTED_MODULE_2__.createDeferred)();const pendingFetchItem={identifier,resolver,options,queryRequest};const resolverPromise=resolver.promise;const store=this._store;const isInitialLoad=!store._instanceCache.recordIsLoaded(identifier);// we don't use isLoading directly because we are the request\nconst monitored=this.requestCache._enqueue(resolverPromise,pendingFetchItem.queryRequest);let promise=monitored.then(payload=>{// ensure that regardless of id returned we assign to the correct record\nif(payload.data&&!Array.isArray(payload.data)){payload.data.lid=identifier.lid;}// additional data received in the payload\n// may result in the merging of identifiers (and thus records)\nconst potentiallyNewIm=store._push(payload,options.reload);if(potentiallyNewIm&&!Array.isArray(potentiallyNewIm)){return potentiallyNewIm;}return identifier;},error=>{(test=>{if(!test){throw new Error(`Async Leak Detected: Expected the store to not be destroyed`);}})(!store.isDestroyed);const cache=store.cache;if(!cache||cache.isEmpty(identifier)||isInitialLoad){let isReleasable=true;if(store._graph){const graph=store._graph;if(!cache){isReleasable=graph.isReleasable(identifier);if(!isReleasable){graph.unload(identifier,true);}}}if(cache||isReleasable){store._enableAsyncFlush=true;store._instanceCache.unloadRecord(identifier);store._enableAsyncFlush=null;}}throw error;});if(this._pendingFetch.size===0){void new Promise(resolve=>setTimeout(resolve,0)).then(()=>{this.flushAllPendingFetches();});}const fetchesByType=this._pendingFetch;let fetchesById=fetchesByType.get(modelName);if(!fetchesById){fetchesById=new Map();fetchesByType.set(modelName,fetchesById);}let requestsForIdentifier=fetchesById.get(identifier);if(!requestsForIdentifier){requestsForIdentifier=[];fetchesById.set(identifier,requestsForIdentifier);}requestsForIdentifier.push(pendingFetchItem);{if(!request.disableTestWaiter){promise=(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.waitFor)(promise);}}pendingFetchItem.promise=promise;return promise;}getPendingFetch(identifier,options){const pendingFetches=this._pendingFetch.get(identifier.type)?.get(identifier);// We already have a pending fetch for this\nif(pendingFetches){const matchingPendingFetch=pendingFetches.find(fetch=>isSameRequest(options,fetch.options));if(matchingPendingFetch){return matchingPendingFetch.promise;}}}flushAllPendingFetches(){if(this.isDestroyed){return;}const store=this._store;this._pendingFetch.forEach((fetchItem,type)=>_flushPendingFetchForType(store,fetchItem,type));this._pendingFetch.clear();}fetchDataIfNeededForIdentifier(identifier,options={},request){// pre-loading will change the isEmpty value\nconst isEmpty=_isEmpty(this._store._instanceCache,identifier);const isLoading=_isLoading(this._store._instanceCache,identifier);let promise;if(isEmpty){assertIdentifierHasId(identifier);{promise=this.scheduleFetch(identifier,Object.assign({},options,{reload:true}),request);}}else if(isLoading){promise=this.getPendingFetch(identifier,options);(test=>{if(!test){throw new Error(`Expected to find a pending request for a record in the loading state, but found none`);}})(promise);}else{promise=Promise.resolve(identifier);}return promise;}destroy(){this.isDestroyed=true;}}function _isEmpty(instanceCache,identifier){const cache=instanceCache.cache;if(!cache){return true;}const isNew=cache.isNew(identifier);const isDeleted=cache.isDeleted(identifier);const isEmpty=cache.isEmpty(identifier);return(!isNew||isDeleted)&&isEmpty;}function _isLoading(cache,identifier){const req=cache.store.getRequestStateService();// const fulfilled = req.getLastRequestForRecord(identifier);\nconst isLoaded=cache.recordIsLoaded(identifier);return!isLoaded&&// fulfilled === null &&\nreq.getPendingRequestsForRecord(identifier).some(r=>r.type==='query');}function includesSatisfies(current,existing){// if we have no includes we are good\nif(!current?.length){return true;}// if we are here we have includes,\n// and if existing has no includes then we will need a new request\nif(!existing?.length){return false;}const arrCurrent=(Array.isArray(current)?current:current.split(',')).sort();const arrExisting=(Array.isArray(existing)?existing:existing.split(',')).sort();// includes are identical\nif(arrCurrent.join(',')===arrExisting.join(',')){return true;}// if all of current includes are in existing includes then we are good\n// so if we find one that is not in existing then we need a new request\nfor(let i=0;i<arrCurrent.length;i++){if(!arrExisting.includes(arrCurrent[i])){return false;}}return true;}function optionsSatisfies(current,existing){return!current||current===existing||Object.keys(current).length===0;}// this function helps resolve whether we have a pending request that we should use instead\nfunction isSameRequest(options={},existingOptions={}){return optionsSatisfies(options.adapterOptions,existingOptions.adapterOptions)&&includesSatisfies(options.include,existingOptions.include);}function _findMany(store,adapter,modelName,snapshots){const modelClass=store.modelFor(modelName);// `adapter.findMany` gets the modelClass still\nconst promise=Promise.resolve().then(()=>{const ids=snapshots.map(s=>s.id);(test=>{if(!test){throw new Error(`Cannot fetch a record without an id`);}})(ids.every(v=>v!==null));// eslint-disable-next-line @typescript-eslint/unbound-method\n(test=>{if(!test){throw new Error(`Expected this adapter to implement findMany for coalescing`);}})(adapter.findMany);const ret=adapter.findMany(store,modelClass,ids,snapshots);(test=>{if(!test){throw new Error('adapter.findMany returned undefined, this was very likely a mistake');}})(ret!==undefined);return ret;});return promise.then(adapterPayload=>{(test=>{if(!test){throw new Error(`You made a 'findMany' request for '${modelName}' records with ids '[${snapshots.map(s=>s.id).join(',')}]', but the adapter's response did not have any data`);}})(!!payloadIsNotBlank(adapterPayload));const serializer=store.serializerFor(modelName);const payload=normalizeResponseHelper(serializer,store,modelClass,adapterPayload,null,'findMany');return payload;});}function rejectFetchedItems(fetchMap,snapshots,error){for(let i=0,l=snapshots.length;i<l;i++){const snapshot=snapshots[i];const pair=fetchMap.get(snapshot);if(pair){pair.resolver.reject(error||new Error(`Expected: '<${snapshot.modelName}:${snapshot.id}>' to be present in the adapter provided payload, but it was not found.`));}}}function handleFoundRecords(store,fetchMap,snapshots,coalescedPayload){/*\n    It is possible that the same ID is included multiple times\n    via multiple snapshots. This happens when more than one\n    options hash was supplied, each of which must be uniquely\n    accounted for.\n     However, since we can't map from response to a specific\n    options object, we resolve all snapshots by id with\n    the first response we see.\n  */const snapshotsById=new Map();for(let i=0;i<snapshots.length;i++){const id=snapshots[i].id;let snapshotGroup=snapshotsById.get(id);if(!snapshotGroup){snapshotGroup=[];snapshotsById.set(id,snapshotGroup);}snapshotGroup.push(snapshots[i]);}const included=Array.isArray(coalescedPayload.included)?coalescedPayload.included:[];// resolve found records\nconst resources=coalescedPayload.data;for(let i=0,l=resources.length;i<l;i++){const resource=resources[i];const snapshotGroup=snapshotsById.get(resource.id);snapshotsById.delete(resource.id);if(!snapshotGroup){// TODO consider whether this should be a deprecation/assertion\nincluded.push(resource);}else{snapshotGroup.forEach(snapshot=>{const pair=fetchMap.get(snapshot);const resolver=pair.resolver;resolver.resolve({data:resource});});}}if(included.length>0){store._push({data:null,included},true);}if(snapshotsById.size===0){return;}// reject missing records\nconst rejected=[];snapshotsById.forEach(snapshotArray=>{rejected.push(...snapshotArray);});(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.warn)('Ember Data expected to find records with the following ids in the adapter response from findMany but they were missing: [ \"'+[...snapshotsById.values()].map(r=>r[0].id).join('\", \"')+'\" ]',{id:'ds.store.missing-records-from-adapter'});rejectFetchedItems(fetchMap,rejected);}function _fetchRecord(store,adapter,fetchItem){const identifier=fetchItem.identifier;const modelName=identifier.type;(test=>{if(!test){throw new Error(`You tried to find a record but you have no adapter (for ${modelName})`);}})(adapter);(test=>{if(!test){throw new Error(`You tried to find a record but your adapter (for ${modelName}) does not implement 'findRecord'`);}})(typeof adapter.findRecord==='function');const snapshot=store._fetchManager.createSnapshot(identifier,fetchItem.options);const klass=store.modelFor(identifier.type);const id=identifier.id;let promise=Promise.resolve().then(()=>{return adapter.findRecord(store,klass,identifier.id,snapshot);});promise=promise.then(adapterPayload=>{(test=>{if(!test){throw new Error(`Async Leak Detected: Expected the store to not be destroyed`);}})(!(store.isDestroyed||store.isDestroying));(test=>{if(!test){throw new Error(`You made a 'findRecord' request for a '${modelName}' with id '${id}', but the adapter's response did not have any data`);}})(!!payloadIsNotBlank(adapterPayload));const serializer=store.serializerFor(modelName);const payload=normalizeResponseHelper(serializer,store,klass,adapterPayload,id,'findRecord');(test=>{if(!test){throw new Error(`Ember Data expected the primary data returned from a 'findRecord' response to be an object but instead it found an array.`);}})(!Array.isArray(payload.data));(test=>{if(!test){throw new Error(`The 'findRecord' request for ${modelName}:${id} resolved indicating success but contained no primary data. To indicate a 404 not found you should either reject the promise returned by the adapter's findRecord method or throw a NotFoundError.`);}})('data'in payload&&payload.data!==null&&typeof payload.data==='object');(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.warn)(`You requested a record of type '${modelName}' with id '${id}' but the adapter returned a payload with primary data having an id of '${payload.data.id}'. Use 'store.findRecord()' when the requested id is the same as the one returned by the adapter. In other cases use 'store.queryRecord()' instead.`,(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.coerceId)(payload.data.id)===(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.coerceId)(id),{id:'ds.store.findRecord.id-mismatch'});return payload;});fetchItem.resolver.resolve(promise);}function _processCoalescedGroup(store,fetchMap,group,adapter,modelName){if(group.length>1){_findMany(store,adapter,modelName,group).then(payloads=>{handleFoundRecords(store,fetchMap,group,payloads);}).catch(error=>{rejectFetchedItems(fetchMap,group,error);});}else if(group.length===1){_fetchRecord(store,adapter,fetchMap.get(group[0]));}else{(test=>{{throw new Error(\"You cannot return an empty array from adapter's method groupRecordsForFindMany\");}})();}}function _flushPendingFetchForType(store,pendingFetchMap,modelName){const adapter=store.adapterFor(modelName);const shouldCoalesce=!!adapter.findMany&&adapter.coalesceFindRequests;if(shouldCoalesce){const pendingFetchItems=[];pendingFetchMap.forEach((requestsForIdentifier,identifier)=>{if(requestsForIdentifier.length>1){return;}// remove this entry from the map so it's not processed again\npendingFetchMap.delete(identifier);pendingFetchItems.push(requestsForIdentifier[0]);});const totalItems=pendingFetchItems.length;if(totalItems>1){const snapshots=new Array(totalItems);const fetchMap=new Map();for(let i=0;i<totalItems;i++){const fetchItem=pendingFetchItems[i];snapshots[i]=store._fetchManager.createSnapshot(fetchItem.identifier,fetchItem.options);fetchMap.set(snapshots[i],fetchItem);}let groups;if(adapter.groupRecordsForFindMany){groups=adapter.groupRecordsForFindMany(store,snapshots);}else{groups=[snapshots];}for(let i=0,l=groups.length;i<l;i++){_processCoalescedGroup(store,fetchMap,groups[i],adapter,modelName);}}else if(totalItems===1){_fetchRecord(store,adapter,pendingFetchItems[0]);}}pendingFetchMap.forEach(pendingFetchItems=>{pendingFetchItems.forEach(pendingFetchItem=>{_fetchRecord(store,adapter,pendingFetchItem);});});}function _flushPendingSave(store,pending){const{snapshot,resolver,identifier,options}=pending;const adapter=store.adapterFor(identifier.type);const operation=options[SaveOp];const modelName=snapshot.modelName;const modelClass=store.modelFor(modelName);(test=>{if(!test){throw new Error(`You tried to update a record but you have no adapter (for ${modelName})`);}})(adapter);(test=>{if(!test){throw new Error(`You tried to update a record but your adapter (for ${modelName}) does not implement '${operation}'`);}})(typeof adapter[operation]==='function');let promise=Promise.resolve().then(()=>adapter[operation](store,modelClass,snapshot));const serializer=store.serializerFor(modelName);(test=>{if(!test){throw new Error(`Your adapter's '${operation}' method must return a value, but it returned 'undefined'`);}})(promise!==undefined);promise=promise.then(adapterPayload=>{if(adapterPayload){return normalizeResponseHelper(serializer,store,modelClass,adapterPayload,snapshot.id,operation);}});resolver.resolve(promise);}/**\n * Utilities - often temporary - for maintaining backwards compatibility with\n * older parts of EmberData.\n *\n  @module\n*/function upgradeStore(store){}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/legacy/dist/-private-CKrP0ogQ.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/legacy/dist/errors-BX5wowuz.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@warp-drive/legacy/dist/errors-BX5wowuz.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ Errors),\n/* harmony export */   L: () => (/* binding */ LEGACY_SUPPORT),\n/* harmony export */   P: () => (/* binding */ PromiseBelongsTo),\n/* harmony export */   a: () => (/* binding */ PromiseManyArray),\n/* harmony export */   l: () => (/* binding */ lookupLegacySupport)\n/* harmony export */ });\n/* harmony import */ var _warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @warp-drive/core/store/-private */ \"./node_modules/@warp-drive/core/dist/store/-private.js\");\n/* harmony import */ var _warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @warp-drive/core/types/-private */ \"./node_modules/@warp-drive/core/dist/types/-private.js\");\n/* harmony import */ var _warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @warp-drive/core/types/request */ \"./node_modules/@warp-drive/core/dist/types/request.js\");\n/* harmony import */ var _private_CKrP0ogQ_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./-private-CKrP0ogQ.js */ \"./node_modules/@warp-drive/legacy/dist/-private-CKrP0ogQ.js\");\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ember/object */ \"@ember/object\");\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_ember_object__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _ember_object_promise_proxy_mixin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ember/object/promise-proxy-mixin */ \"@ember/object/promise-proxy-mixin\");\n/* harmony import */ var _ember_object_promise_proxy_mixin__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_ember_object_promise_proxy_mixin__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _ember_object_proxy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ember/object/proxy */ \"@ember/object/proxy\");\n/* harmony import */ var _ember_object_proxy__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_ember_object_proxy__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./runtime-BPCpkOf1-BKOwiRJp.js */ \"./node_modules/@warp-drive/legacy/dist/runtime-BPCpkOf1-BKOwiRJp.js\");\n/* harmony import */ var _ember_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ember/array */ \"@ember/array\");\n/* harmony import */ var _ember_array__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_ember_array__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _ember_array_proxy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ember/array/proxy */ \"@ember/array/proxy\");\n/* harmony import */ var _ember_array_proxy__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_ember_array_proxy__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _ember_object_computed__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ember/object/computed */ \"@ember/object/computed\");\n/* harmony import */ var _ember_object_computed__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_ember_object_computed__WEBPACK_IMPORTED_MODULE_10__);\nvar _PromiseBelongsTo,_PromiseManyArray,_HasManyReference,_BelongsToReference,_Errors;function _classPrivateFieldInitSpec(e,t,a){_checkPrivateRedeclaration(e,t),t.set(e,a);}function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError(\"Cannot initialize the same private elements twice on an object\");}function _defineProperty(e,r,t){return(r=_toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\";}function _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}const PromiseObject=_ember_object_proxy__WEBPACK_IMPORTED_MODULE_6___default().extend((_ember_object_promise_proxy_mixin__WEBPACK_IMPORTED_MODULE_5___default()));const LegacyPromiseProxy=Symbol.for('LegacyPromiseProxy');// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-extraneous-class\nconst Extended=PromiseObject;// eslint-disable-next-line @typescript-eslint/no-unused-vars\n/**\n  A PromiseBelongsTo is a PromiseObject that also proxies certain method calls\n  to the underlying belongsTo model.\n  Right now we proxy:\n    * `reload()`\n  @class PromiseBelongsTo\n  @private\n*/class PromiseBelongsTo extends Extended{get id(){const{key,legacySupport}=this._belongsToState;const ref=legacySupport.referenceFor('belongsTo',key);return ref.id();}// we don't proxy meta because we would need to proxy it to the relationship state container\n//  however, meta on relationships does not trigger change notifications.\n//  if you need relationship meta, you should do `record.belongsTo(relationshipName).meta()`\nget meta(){// eslint-disable-next-line no-constant-condition\n{(test=>{{throw new Error('You attempted to access meta on the promise for the async belongsTo relationship '+`${this._belongsToState.modelName}:${this._belongsToState.key}'.`+'\\nUse `record.belongsTo(relationshipName).meta()` instead.');}})();}return;}async reload(options){(test=>{if(!test){throw new Error('You are trying to reload an async belongsTo before it has been created');}})(this.content!==undefined);const{key,legacySupport}=this._belongsToState;await legacySupport.reloadBelongsTo(key,options);return this;}}_PromiseBelongsTo=PromiseBelongsTo;(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.d)(_PromiseBelongsTo.prototype,\"id\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.d)(_PromiseBelongsTo.prototype,\"meta\",[(0,_ember_object__WEBPACK_IMPORTED_MODULE_4__.computed)()]);PromiseBelongsTo.prototype[LegacyPromiseProxy]=true;/**\n  This class is returned as the result of accessing an async hasMany relationship\n  on an instance of a Model extending from `@ember-data/model`.\n\n  A PromiseManyArray is an iterable proxy that allows templates to consume related\n  ManyArrays and update once their contents are no longer pending.\n\n  In your JS code you should resolve the promise first.\n\n  ```js\n  const comments = await post.comments;\n  ```\n\n  @class PromiseManyArray\n  @public\n*/class PromiseManyArray{constructor(promise,content){this._update(promise,content);this.isDestroyed=false;this[LegacyPromiseProxy]=true;}/**\n   * Retrieve the length of the content\n   * @property length\n   * @public\n   */get length(){// shouldn't be needed, but ends up being needed\n// for computed chains even in 4.x\n{// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nthis['[]'];}return this.content?this.content.length:0;}// this will error if someone tries to call\n// A(identifierArray) since it is not configurable\n// which is preferrable to the `meta` override we used\n// before which required importing all of Ember\nget'[]'(){// ember-source < 3.23 (e.g. 3.20 lts)\n// requires that the tag `'[]'` be notified\n// on the ArrayProxy in order for `{{#each}}`\n// to recompute. We entangle content.\nreturn this.content?.length&&this.content;}/**\n   * Iterate the proxied content. Called by the glimmer iterator in #each\n   * We do not guarantee that forEach will always be available. This\n   * may eventually be made to use Symbol.Iterator once glimmer supports it.\n   *\n   * @param cb\n   * @return\n   * @private\n   */forEach(cb){if(this.content&&this.length){this.content.forEach(cb);}}/**\n   * Reload the relationship\n   * @public\n   * @param options\n   * @return\n   */reload(options){(test=>{if(!test){throw new Error('You are trying to reload an async manyArray before it has been created');}})(this.content);void this.content.reload(options);return this;}//----  Properties/Methods from the PromiseProxyMixin that we will keep as our API\n/**\n   * Whether the loading promise is still pending\n   *\n   * @property isPending\n   * @type {Boolean}\n   * @public\n   *//**\n   * Whether the loading promise rejected\n   *\n   * @property isRejected\n   * @type {Boolean}\n   * @public\n   *//**\n   * Whether the loading promise succeeded\n   *\n   * @property isFulfilled\n   * @type {Boolean}\n   * @public\n   *//**\n   * Whether the loading promise completed (resolved or rejected)\n   *\n   * @property isSettled\n   * @type {Boolean}\n   * @public\n   *//**\n   * chain this promise\n   *\n   * @public\n   */then(success,rejected){return this.promise.then(success,rejected);}/**\n   * catch errors thrown by this promise\n   * @public\n   * @param callback\n   * @return {Promise}\n   */catch(cb){return this.promise.catch(cb);}/**\n   * run cleanup after this promise completes\n   *\n   * @public\n   * @param callback\n   * @return {Promise}\n   */finally(cb){return this.promise.finally(cb);}//---- Methods on EmberObject that we should keep\ndestroy(){this.isDestroyed=true;this.content=null;this.promise=null;}//---- Methods/Properties on ManyArray that we own and proxy to\n/**\n   * Retrieve the links for this relationship\n   * @property links\n   * @public\n   */get links(){return this.content?this.content.links:undefined;}/**\n   * Retrieve the meta for this relationship\n   * @property meta\n   * @public\n   */get meta(){return this.content?this.content.meta:undefined;}//---- Our own stuff\n/** @internal */_update(promise,content){if(content!==undefined){this.content=content;}this.promise=tapPromise(this,promise);}static create({promise,content}){return new this(promise,content);}}_PromiseManyArray=PromiseManyArray;(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.d)(_PromiseManyArray.prototype,\"length\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.d)(_PromiseManyArray.prototype,'[]',[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.d)(_PromiseManyArray.prototype,\"links\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.d)(_PromiseManyArray.prototype,\"meta\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.memoized]);(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.defineSignal)(PromiseManyArray.prototype,'content',null);(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.defineSignal)(PromiseManyArray.prototype,'isPending',false);(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.defineSignal)(PromiseManyArray.prototype,'isRejected',false);(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.defineSignal)(PromiseManyArray.prototype,'isFulfilled',false);(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.defineSignal)(PromiseManyArray.prototype,'isSettled',false);function tapPromise(proxy,promise){proxy.isPending=true;proxy.isSettled=false;proxy.isFulfilled=false;proxy.isRejected=false;return Promise.resolve(promise).then(content=>{proxy.isPending=false;proxy.isFulfilled=true;proxy.isSettled=true;proxy.content=content;return content;},error=>{proxy.isPending=false;proxy.isFulfilled=false;proxy.isRejected=true;proxy.isSettled=true;throw error;});}/*\n  Assert that `addedRecord` has a valid type so it can be added to the\n  relationship of the `record`.\n\n  The assert basically checks if the `addedRecord` can be added to the\n  relationship (specified via `relationshipMeta`) of the `record`.\n\n  This utility should only be used internally, as both record parameters must\n  be stable record identifiers and the `relationshipMeta` needs to be the meta\n  information about the relationship, retrieved via\n  `record.relationshipFor(key)`.\n*/let assertPolymorphicType;{// eslint-disable-next-line @typescript-eslint/no-shadow\nassertPolymorphicType=function assertPolymorphicType(parentIdentifier,parentDefinition,addedIdentifier,store){if(parentDefinition.inverseIsImplicit){return;}if(parentDefinition.isPolymorphic){const meta=store.schema.fields(addedIdentifier)?.get(parentDefinition.inverseKey);if(meta){(test=>{if(!test){throw new Error(`Expected the schema for the field ${parentDefinition.inverseKey} on ${addedIdentifier.type} to be for a legacy relationship`);}})(meta.kind==='belongsTo'||meta.kind==='hasMany');(test=>{if(!test){throw new Error(`The schema for the relationship '${parentDefinition.inverseKey}' on '${addedIdentifier.type}' type does not implement '${parentDefinition.type}' and thus cannot be assigned to the '${parentDefinition.key}' relationship in '${parentIdentifier.type}'. The definition should specify 'as: \"${parentDefinition.type}\"' in options.`);}})(meta?.options?.as===parentDefinition.type);}}};}function isResourceIdentiferWithRelatedLinks$1(value){return Boolean(value&&value.links&&value.links.related);}/**\n A `HasManyReference` is a low-level API that allows access\n and manipulation of a hasMany relationship.\n\n It is especially useful when you're dealing with `async` relationships\n from `@ember-data/model` as it allows synchronous access to\n the relationship data if loaded, as well as APIs for loading, reloading\n the data or accessing available information without triggering a load.\n\n It may also be useful when using `sync` relationships with `@ember-data/model`\n that need to be loaded/reloaded with more precise timing than marking the\n relationship as `async` and relying on autofetch would have allowed.\n\n However,keep in mind that marking a relationship as `async: false` will introduce\n bugs into your application if the data is not always guaranteed to be available\n by the time the relationship is accessed. Ergo, it is recommended when using this\n approach to utilize `links` for unloaded relationship state instead of identifiers.\n\n Reference APIs are entangled with the relationship's underlying state,\n thus any getters or cached properties that utilize these will properly\n invalidate if the relationship state changes.\n\n References are \"stable\", meaning that multiple calls to retrieve the reference\n  for a given relationship will always return the same HasManyReference.\n\n @class HasManyReference\n @public\n */class HasManyReference{constructor(store,graph,parentIdentifier,hasManyRelationship,key){/**\n   * The field name on the parent record for this has-many relationship.\n   *\n   * @property key\n   * @type {String}\n   * @public\n   *//**\n   * The type of resource this relationship will contain.\n   *\n   * @property type\n   * @type {String}\n   * @public\n   */// unsubscribe tokens given to us by the notification manager\n_defineProperty(this,\"___token\",void 0);_defineProperty(this,\"___identifier\",void 0);_defineProperty(this,\"___relatedTokenMap\",void 0);this.graph=graph;this.key=key;this.hasManyRelationship=hasManyRelationship;this.type=hasManyRelationship.definition.type;this.store=store;this.___identifier=parentIdentifier;this.___token=store.notifications.subscribe(parentIdentifier,(_,bucket,notifiedKey)=>{if(bucket==='relationships'&&notifiedKey===key){this._ref++;}});this.___relatedTokenMap=new Map();// TODO inverse\n}/**\n   * This method should never be called by user code.\n   *\n   * @internal\n   */destroy(){this.store.notifications.unsubscribe(this.___token);this.___relatedTokenMap.forEach(token=>{this.store.notifications.unsubscribe(token);});this.___relatedTokenMap.clear();}/**\n   * An array of identifiers for the records that this reference refers to.\n   *\n   * @property identifiers\n   * @type {StableRecordIdentifier[]}\n   * @public\n   */get identifiers(){ensureRefCanSubscribe(this);// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nthis._ref;const resource=this._resource();const map=this.___relatedTokenMap;this.___relatedTokenMap=new Map();if(resource&&resource.data){return resource.data.map(resourceIdentifier=>{const identifier=this.store.identifierCache.getOrCreateRecordIdentifier(resourceIdentifier);let token=map.get(identifier);if(token){map.delete(identifier);}else{token=this.store.notifications.subscribe(identifier,(_,bucket,notifiedKey)=>{if(bucket==='identity'||bucket==='attributes'&&notifiedKey==='id'){this._ref++;}});}this.___relatedTokenMap.set(identifier,token);return identifier;});}map.forEach(token=>{this.store.notifications.unsubscribe(token);});map.clear();return[];}_resource(){const cache=this.store.cache;return cache.getRelationship(this.___identifier,this.key);}/**\n   This returns a string that represents how the reference will be\n   looked up when it is loaded. If the relationship has a link it will\n   use the \"link\" otherwise it defaults to \"id\".\n    Example\n    ```js [app/models/post.js]\n   import { Model, hasMany } from '@warp-drive/legacy/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    ```javascript\n   let post = store.push({\n     data: {\n       type: 'post',\n       id: 1,\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: 1 }]\n         }\n       }\n     }\n   });\n    let commentsRef = post.hasMany('comments');\n    // get the identifier of the reference\n   if (commentsRef.remoteType() === \"ids\") {\n     let ids = commentsRef.ids();\n   } else if (commentsRef.remoteType() === \"link\") {\n     let link = commentsRef.link();\n   }\n   ```\n    @public\n   @return {String} The name of the remote type. This should either be `link` or `ids`\n   */remoteType(){const value=this._resource();if(value&&value.links&&value.links.related){return'link';}return'ids';}/**\n   `ids()` returns an array of the record IDs in this relationship.\n    Example\n    ```js [app/models/post.js]\n   import { Model, hasMany } from '@warp-drive/legacy/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    ```javascript\n   let post = store.push({\n     data: {\n       type: 'post',\n       id: 1,\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: 1 }]\n         }\n       }\n     }\n   });\n    let commentsRef = post.hasMany('comments');\n    commentsRef.ids(); // ['1']\n   ```\n     @public\n   @return {Array} The ids in this has-many relationship\n   */ids(){return this.identifiers.map(identifier=>identifier.id);}/**\n   The link Ember Data will use to fetch or reload this belongs-to\n   relationship. By default it uses only the \"related\" resource linkage.\n    Example\n    ```javascript\n   // models/blog.js\n   import { Model, belongsTo } from '@warp-drive/legacy/model';\n   export default Model.extend({\n      user: belongsTo('user', { async: true, inverse: null })\n    });\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            links: {\n              related: '/articles/1/author'\n            }\n          }\n        }\n      }\n    });\n   let userRef = blog.belongsTo('user');\n    // get the identifier of the reference\n   if (userRef.remoteType() === \"link\") {\n      let link = userRef.link();\n    }\n   ```\n    @public\n   @return {String} The link Ember Data will use to fetch or reload this belongs-to relationship.\n   */link(){const resource=this._resource();if(isResourceIdentiferWithRelatedLinks$1(resource)){if(resource.links){const related=resource.links.related;return!related||typeof related==='string'?related:related.href;}}return null;}/**\n   * any links that have been received for this relationship\n   *\n   * @public\n   * @return\n   */links(){const resource=this._resource();return resource&&resource.links?resource.links:null;}/**\n   The meta data for the has-many relationship.\n    Example\n    ```javascript\n   // models/blog.js\n   import { Model, hasMany } from '@warp-drive/legacy/model';\n   export default Model.extend({\n      users: hasMany('user', { async: true, inverse: null })\n    });\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          users: {\n            links: {\n              related: {\n                href: '/articles/1/authors'\n              },\n            },\n            meta: {\n              lastUpdated: 1458014400000\n            }\n          }\n        }\n      }\n    });\n    let usersRef = blog.hasMany('user');\n    usersRef.meta() // { lastUpdated: 1458014400000 }\n   ```\n   @public\n  @return {Object|null} The meta information for the belongs-to relationship.\n  */meta(){let meta=null;const resource=this._resource();if(resource&&resource.meta&&typeof resource.meta==='object'){meta=resource.meta;}return meta;}/**\n   `push` can be used to update the data in the relationship and EmberData\n   will treat the new data as the canonical value of this relationship on\n   the backend. An empty array will signify the canonical value should be\n   empty.\n    Example model\n    ```js [app/models/post.js]\n   import { Model, hasMany } from '@warp-drive/legacy/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    Setup some initial state, note we haven't loaded the comments yet:\n    ```js\n   const post = store.push({\n     data: {\n       type: 'post',\n       id: '1',\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: '1' }]\n         }\n       }\n     }\n   });\n    const commentsRef = post.hasMany('comments');\n   commentsRef.ids(); // ['1']\n   ```\n    Update the state using `push`, note we can do this even without\n   having loaded these comments yet by providing resource identifiers.\n    Both full resources and resource identifiers are supported.\n    ```js\n   await commentsRef.push({\n    data: [\n     { type: 'comment', id: '2' },\n     { type: 'comment', id: '3' },\n    ]\n   });\n    commentsRef.ids(); // ['2', '3']\n   ```\n    For convenience, you can also pass in an array of resources or resource identifiers\n   without wrapping them in the `data` property:\n    ```js\n   await commentsRef.push([\n     { type: 'comment', id: '4' },\n     { type: 'comment', id: '5' },\n   ]);\n    commentsRef.ids(); // ['4', '5']\n   ```\n    When using the `data` property, you may also include other resource data via included,\n   as well as provide new links and meta to the relationship.\n    ```js\n   await commentsRef.push({\n     links: {\n       related: '/posts/1/comments'\n     },\n     meta: {\n       total: 2\n     },\n     data: [\n       { type: 'comment', id: '4' },\n       { type: 'comment', id: '5' },\n     ],\n     included: [\n       { type: 'other-thing', id: '1', attributes: { foo: 'bar' },\n     ]\n   });\n   ```\n    By default, the store will attempt to fetch any unloaded records before resolving\n   the returned promise with the ManyArray.\n    Alternatively, pass `true` as the second argument to avoid fetching unloaded records\n   and instead the promise will resolve with void without attempting to fetch. This is\n   particularly useful if you want to update the state of the relationship without\n   forcing the load of all of the associated records.\n    @public\n   @param {Array|Object} doc a JSONAPI document object describing the new value of this relationship.\n   @param {Boolean} [skipFetch] if `true`, do not attempt to fetch unloaded records\n   @return {Promise<ManyArray | void>}\n  */async push(doc,skipFetch){const{store}=this;const dataDoc=Array.isArray(doc)?{data:doc}:doc;const isResourceData=Array.isArray(dataDoc.data)&&dataDoc.data.length>0&&isMaybeResource(dataDoc.data[0]);// enforce that one of links, meta or data is present\n(test=>{if(!test){throw new Error(`You must provide at least one of 'links', 'meta' or 'data' when calling hasManyReference.push`);}})('links'in dataDoc||'meta'in dataDoc||'data'in dataDoc);const identifiers=!Array.isArray(dataDoc.data)?[]:isResourceData?store._push(dataDoc,true):dataDoc.data.map(i=>store.identifierCache.getOrCreateRecordIdentifier(i));const{identifier}=this.hasManyRelationship;{const relationshipMeta=this.hasManyRelationship.definition;identifiers.forEach(added=>{assertPolymorphicType(identifier,relationshipMeta,added,store);});}const newData={};// only set data if it was passed in\nif(Array.isArray(dataDoc.data)){newData.data=identifiers;}if('links'in dataDoc){newData.links=dataDoc.links;}if('meta'in dataDoc){newData.meta=dataDoc.meta;}store._join(()=>{this.graph.push({op:'updateRelationship',record:identifier,field:this.key,value:newData});});if(!skipFetch)return this.load();}_isLoaded(){const hasRelationshipDataProperty=this.hasManyRelationship.state.hasReceivedData;if(!hasRelationshipDataProperty){return false;}const relationship=this.graph.getData(this.hasManyRelationship.identifier,this.key);return relationship.data?relationship.data.every(identifier=>{return this.store._instanceCache.recordIsLoaded(identifier,true)===true;}):false;}/**\n   `value()` synchronously returns the current value of the has-many\n   relationship. Unlike `record.relationshipName`, calling\n   `value()` on a reference does not trigger a fetch if the async\n   relationship is not yet loaded. If the relationship is not loaded\n   it will always return `null`.\n    Example\n    ```js [app/models/post.js]\n   import { Model, hasMany } from '@warp-drive/legacy/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    ```javascript\n   let post = store.push({\n     data: {\n       type: 'post',\n       id: 1,\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: 1 }]\n         }\n       }\n     }\n   });\n    let commentsRef = post.hasMany('comments');\n    post.comments.then(function(comments) {\n     commentsRef.value() === comments\n   })\n   ```\n     @public\n   @return {ManyArray}\n   */value(){const support=LEGACY_SUPPORT.get(this.___identifier);if(!ensureRefCanSubscribe(this)){// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nthis._ref;return null;}return support.getManyArray(this.key);}/**\n   Loads the relationship if it is not already loaded.  If the\n   relationship is already loaded this method does not trigger a new\n   load. This causes a request to the specified\n   relationship link or reloads all items currently in the relationship.\n    Example\n    ```js [app/models/post.js]\n   import { Model, hasMany } from '@warp-drive/legacy/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    ```javascript\n   let post = store.push({\n     data: {\n       type: 'post',\n       id: 1,\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: 1 }]\n         }\n       }\n     }\n   });\n    let commentsRef = post.hasMany('comments');\n    commentsRef.load().then(function(comments) {\n     //...\n   });\n   ```\n    You may also pass in an options object whose properties will be\n   fed forward. This enables you to pass `adapterOptions` into the\n   request given to the adapter via the reference.\n    Example\n    ```javascript\n   commentsRef.load({ adapterOptions: { isPrivate: true } })\n     .then(function(comments) {\n       //...\n     });\n   ```\n    ```js [app/adapters/comment.js]\n   export default ApplicationAdapter.extend({\n     findMany(store, type, id, snapshots) {\n       // In the adapter you will have access to adapterOptions.\n       let adapterOptions = snapshots[0].adapterOptions;\n     }\n   });\n   ```\n    @public\n   @param {Object} options the options to pass in.\n   @return {Promise} a promise that resolves with the ManyArray in\n   this has-many relationship.\n   */async load(options){const support=LEGACY_SUPPORT.get(this.___identifier);const fetchSyncRel=!this.hasManyRelationship.definition.isAsync&&!areAllInverseRecordsLoaded(this.store,this._resource());return fetchSyncRel?support.reloadHasMany(this.key,options):// we cast to fix the return type since typescript and eslint don't understand async functions\n// properly\nsupport.getHasMany(this.key,options);}/**\n   Reloads this has-many relationship. This causes a request to the specified\n   relationship link or reloads all items currently in the relationship.\n    Example\n    ```js [app/models/post.js]\n   import { Model, hasMany } from '@warp-drive/legacy/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    ```javascript\n   let post = store.push({\n     data: {\n       type: 'post',\n       id: 1,\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: 1 }]\n         }\n       }\n     }\n   });\n    let commentsRef = post.hasMany('comments');\n    commentsRef.reload().then(function(comments) {\n     //...\n   });\n   ```\n    You may also pass in an options object whose properties will be\n   fed forward. This enables you to pass `adapterOptions` into the\n   request given to the adapter via the reference. A full example\n   can be found in the `load` method.\n    Example\n    ```javascript\n   commentsRef.reload({ adapterOptions: { isPrivate: true } })\n   ```\n     @public\n   @param {Object} options the options to pass in.\n   @return {Promise} a promise that resolves with the ManyArray in this has-many relationship.\n   */reload(options){const support=LEGACY_SUPPORT.get(this.___identifier);return support.reloadHasMany(this.key,options);}}_HasManyReference=HasManyReference;(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.d)(_HasManyReference.prototype,\"identifiers\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.memoized]);(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.defineNonEnumerableSignal)(HasManyReference.prototype,'_ref',0);function isMaybeResource(object){const keys=Object.keys(object).filter(k=>k!=='id'&&k!=='type'&&k!=='lid');return keys.length>0;}function ensureRefCanSubscribe(rel){const loaded=rel._isLoaded();if(!loaded){// subscribe to changes\n// for when we are not loaded yet\n//\n// because the graph optimizes the case where a relationship has never been subscribed,\n// we force accessed to be true here. When we make the graph public we should create a\n// subscribe/unsubscribe API\nconst edge=rel.graph.get(rel.___identifier,rel.key);(test=>{if(!test){throw new Error(`Expected a hasMany relationship for ${rel.___identifier.type}:${rel.key}`);}})('accessed'in edge);edge.accessed=true;return false;}return true;}function isResourceIdentiferWithRelatedLinks(value){return Boolean(value&&value.links&&value.links.related);}/**\n A `BelongsToReference` is a low-level API that allows access\n and manipulation of a belongsTo relationship.\n\n It is especially useful when you're dealing with `async` relationships\n from `@ember-data/model` as it allows synchronous access to\n the relationship data if loaded, as well as APIs for loading, reloading\n the data or accessing available information without triggering a load.\n\n It may also be useful when using `sync` relationships with `@ember-data/model`\n that need to be loaded/reloaded with more precise timing than marking the\n relationship as `async` and relying on autofetch would have allowed.\n\n However,keep in mind that marking a relationship as `async: false` will introduce\n bugs into your application if the data is not always guaranteed to be available\n by the time the relationship is accessed. Ergo, it is recommended when using this\n approach to utilize `links` for unloaded relationship state instead of identifiers.\n\n Reference APIs are entangled with the relationship's underlying state,\n thus any getters or cached properties that utilize these will properly\n invalidate if the relationship state changes.\n\n References are \"stable\", meaning that multiple calls to retrieve the reference\n  for a given relationship will always return the same HasManyReference.\n\n @class BelongsToReference\n @public\n */class BelongsToReference{/**\n   * The field name on the parent record for this has-many relationship.\n   *\n   * @property key\n   * @type {String}\n   * @public\n   *//**\n   * The type of resource this relationship will contain.\n   *\n   * @property type\n   * @type {String}\n   * @public\n   */// unsubscribe tokens given to us by the notification manager\nconstructor(store,graph,parentIdentifier,belongsToRelationship,key){this.graph=graph;this.key=key;this.belongsToRelationship=belongsToRelationship;this.type=belongsToRelationship.definition.type;this.store=store;this.___identifier=parentIdentifier;this.___relatedToken=null;this.___token=store.notifications.subscribe(parentIdentifier,(_,bucket,notifiedKey)=>{if(bucket==='relationships'&&notifiedKey===key){this._ref++;}});// TODO inverse\n}destroy(){// TODO @feature we need the notification manager often enough\n// we should potentially just expose it fully public\nthis.store.notifications.unsubscribe(this.___token);this.___token=null;if(this.___relatedToken){this.store.notifications.unsubscribe(this.___relatedToken);this.___relatedToken=null;}}/**\n   * The identifier of the record that this reference refers to.\n   * `null` if no related record is known.\n   *\n   * @property identifier\n   * @type {StableRecordIdentifier | null}\n   * @public\n   */get identifier(){if(this.___relatedToken){this.store.notifications.unsubscribe(this.___relatedToken);this.___relatedToken=null;}const resource=this._resource();if(resource&&resource.data){const identifier=this.store.identifierCache.getOrCreateRecordIdentifier(resource.data);this.___relatedToken=this.store.notifications.subscribe(identifier,(_,bucket,notifiedKey)=>{if(bucket==='identity'||bucket==='attributes'&&notifiedKey==='id'){this._ref++;}});return identifier;}return null;}/**\n   The `id` of the record that this reference refers to. Together, the\n   `type()` and `id()` methods form a composite key for the identity\n   map. This can be used to access the id of an async relationship\n   without triggering a fetch that would normally happen if you\n   attempted to use `record.relationship.id`.\n    Example\n    ```javascript\n   // models/blog.js\n   import { Model, belongsTo } from '@warp-drive/legacy/model';\n    export default class BlogModel extends Model {\n    @belongsTo('user', { async: true, inverse: null }) user;\n   }\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            data: { type: 'user', id: 1 }\n          }\n        }\n      }\n    });\n   let userRef = blog.belongsTo('user');\n    // get the identifier of the reference\n   if (userRef.remoteType() === \"id\") {\n      let id = userRef.id();\n    }\n   ```\n    @public\n   @return {String} The id of the record in this belongsTo relationship.\n   */id(){return this.identifier?.id||null;}/**\n   The link Ember Data will use to fetch or reload this belongs-to\n   relationship. By default it uses only the \"related\" resource linkage.\n    Example\n    ```javascript\n   // models/blog.js\n   import { Model, belongsTo } from '@warp-drive/legacy/model';\n   export default Model.extend({\n      user: belongsTo('user', { async: true, inverse: null })\n    });\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            links: {\n              related: '/articles/1/author'\n            }\n          }\n        }\n      }\n    });\n   let userRef = blog.belongsTo('user');\n    // get the identifier of the reference\n   if (userRef.remoteType() === \"link\") {\n      let link = userRef.link();\n    }\n   ```\n    @public\n   @return {String} The link Ember Data will use to fetch or reload this belongs-to relationship.\n   */link(){const resource=this._resource();if(isResourceIdentiferWithRelatedLinks(resource)){if(resource.links){const related=resource.links.related;return!related||typeof related==='string'?related:related.href;}}return null;}/**\n   * any links that have been received for this relationship\n   *\n   * @public\n   * @return\n   */links(){const resource=this._resource();return resource&&resource.links?resource.links:null;}/**\n   The meta data for the belongs-to relationship.\n    Example\n    ```javascript\n   // models/blog.js\n   import { Model, belongsTo } from '@warp-drive/legacy/model';\n   export default Model.extend({\n      user: belongsTo('user', { async: true, inverse: null })\n    });\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            links: {\n              related: {\n                href: '/articles/1/author'\n              },\n            },\n            meta: {\n              lastUpdated: 1458014400000\n            }\n          }\n        }\n      }\n    });\n    let userRef = blog.belongsTo('user');\n    userRef.meta() // { lastUpdated: 1458014400000 }\n   ```\n     @public\n   @return {Object} The meta information for the belongs-to relationship.\n   */meta(){let meta=null;const resource=this._resource();if(resource&&resource.meta&&typeof resource.meta==='object'){meta=resource.meta;}return meta;}_resource(){// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nthis._ref;// subscribe\nconst cache=this.store.cache;return cache.getRelationship(this.___identifier,this.key);}/**\n   This returns a string that represents how the reference will be\n   looked up when it is loaded. If the relationship has a link it will\n   use the \"link\" otherwise it defaults to \"id\".\n    Example\n    ```js [app/models/post.js]\n   import Model, { hasMany } from '@ember-data/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    ```javascript\n   let post = store.push({\n     data: {\n       type: 'post',\n       id: 1,\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: 1 }]\n         }\n       }\n     }\n   });\n    let commentsRef = post.hasMany('comments');\n    // get the identifier of the reference\n   if (commentsRef.remoteType() === \"ids\") {\n     let ids = commentsRef.ids();\n   } else if (commentsRef.remoteType() === \"link\") {\n     let link = commentsRef.link();\n   }\n   ```\n    @public\n   @return {String} The name of the remote type. This should either be `link` or `id`\n   */remoteType(){const value=this._resource();if(isResourceIdentiferWithRelatedLinks(value)){return'link';}return'id';}/**\n   `push` can be used to update the data in the relationship and EmberData\n   will treat the new data as the canonical value of this relationship on\n   the backend. A value of `null` (e.g. `{ data: null }`) can be passed to\n   clear the relationship.\n    Example model\n    ```js [app/models/blog.js]\n   import { Model, belongsTo } from '@warp-drive/legacy/model';\n    export default class BlogModel extends Model {\n      @belongsTo('user', { async: true, inverse: null }) user;\n    }\n   ```\n    Setup some initial state, note we haven't loaded the user yet:\n    ```js\n   const blog = store.push({\n      data: {\n        type: 'blog',\n        id: '1',\n        relationships: {\n          user: {\n            data: { type: 'user', id: '1' }\n          }\n        }\n      }\n   });\n    const userRef = blog.belongsTo('user');\n   userRef.id(); // '1'\n   ```\n    Update the state using `push`, note we can do this even without\n   having loaded the user yet by providing a resource-identifier.\n    Both full a resource and a resource-identifier are supported.\n    ```js\n   await userRef.push({\n      data: {\n        type: 'user',\n        id: '2',\n      }\n    });\n     userRef.id(); // '2'\n   ```\n    You may also pass in links and meta fore the relationship, and sideload\n   additional resources that might be required.\n    ```js\n    await userRef.push({\n        data: {\n          type: 'user',\n          id: '2',\n        },\n        links: {\n          related: '/articles/1/author'\n        },\n        meta: {\n          lastUpdated: Date.now()\n        },\n        included: [\n          {\n            type: 'user-preview',\n            id: '2',\n            attributes: {\n              username: '@runspired'\n            }\n          }\n        ]\n      });\n    ```\n    By default, the store will attempt to fetch the record if it is not loaded or its\n   resource data is not included in the call to `push` before resolving the returned\n   promise with the new state..\n    Alternatively, pass `true` as the second argument to avoid fetching unloaded records\n   and instead the promise will resolve with void without attempting to fetch. This is\n   particularly useful if you want to update the state of the relationship without\n   forcing the load of all of the associated record.\n    @public\n   @param {Object} doc a JSONAPI document object describing the new value of this relationship.\n   @param {Boolean} [skipFetch] if `true`, do not attempt to fetch unloaded records\n   @return {Promise<OpaqueRecordInstance | null | void>}\n  */async push(doc,skipFetch){const{store}=this;const isResourceData=doc.data&&isMaybeResource(doc.data);const added=isResourceData?store._push(doc,true):doc.data?store.identifierCache.getOrCreateRecordIdentifier(doc.data):null;const{identifier}=this.belongsToRelationship;{if(added){assertPolymorphicType(identifier,this.belongsToRelationship.definition,added,store);}}const newData={};// only set data if it was passed in\nif(doc.data||doc.data===null){newData.data=added;}if('links'in doc){newData.links=doc.links;}if('meta'in doc){newData.meta=doc.meta;}store._join(()=>{this.graph.push({op:'updateRelationship',record:identifier,field:this.key,value:newData});});if(!skipFetch)return this.load();}/**\n   `value()` synchronously returns the current value of the belongs-to\n   relationship. Unlike `record.relationshipName`, calling\n   `value()` on a reference does not trigger a fetch if the async\n   relationship is not yet loaded. If the relationship is not loaded\n   it will always return `null`.\n    Example\n    ```javascript\n   // models/blog.js\n   import { Model, belongsTo } from '@warp-drive/legacy/model';\n    export default class BlogModel extends Model {\n     @belongsTo('user', { async: true, inverse: null }) user;\n   }\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            data: { type: 'user', id: 1 }\n          }\n        }\n      }\n    });\n   let userRef = blog.belongsTo('user');\n    userRef.value(); // null\n    // provide data for reference\n   userRef.push({\n      data: {\n        type: 'user',\n        id: 1,\n        attributes: {\n          username: \"@user\"\n        }\n      }\n    }).then(function(user) {\n      userRef.value(); // user\n    });\n   ```\n     @public\n   @return {Model} the record in this relationship\n   */value(){const resource=this._resource();return resource&&resource.data?this.store.peekRecord(resource.data):null;}/**\n   Loads a record in a belongs-to relationship if it is not already\n   loaded. If the relationship is already loaded this method does not\n   trigger a new load.\n    Example\n    ```javascript\n   // models/blog.js\n   import { Model, belongsTo } from '@warp-drive/legacy/model';\n    export default class BlogModel extends Model {\n     @belongsTo('user', { async: true, inverse: null }) user;\n   }\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            data: { type: 'user', id: 1 }\n          }\n        }\n      }\n    });\n   let userRef = blog.belongsTo('user');\n    userRef.value(); // null\n    userRef.load().then(function(user) {\n      userRef.value() === user\n    });\n   ```\n    You may also pass in an options object whose properties will be\n   fed forward. This enables you to pass `adapterOptions` into the\n   request given to the adapter via the reference.\n    Example\n    ```javascript\n   userRef.load({ adapterOptions: { isPrivate: true } }).then(function(user) {\n     userRef.value() === user;\n   });\n   ```\n   ```js [app/adapters/user.js]\n   import Adapter from '@ember-data/adapter';\n    export default class UserAdapter extends Adapter {\n     findRecord(store, type, id, snapshot) {\n       // In the adapter you will have access to adapterOptions.\n       let adapterOptions = snapshot.adapterOptions;\n     }\n   });\n   ```\n     @public\n   @param {Object} options the options to pass in.\n   @return {Promise} a promise that resolves with the record in this belongs-to relationship.\n   */async load(options){const support=LEGACY_SUPPORT.get(this.___identifier);const fetchSyncRel=!this.belongsToRelationship.definition.isAsync&&!areAllInverseRecordsLoaded(this.store,this._resource());return fetchSyncRel?support.reloadBelongsTo(this.key,options).then(()=>this.value()):// we cast to fix the return type since typescript and eslint don't understand async functions\n// properly\nsupport.getBelongsTo(this.key,options);}/**\n   Triggers a reload of the value in this relationship. If the\n   remoteType is `\"link\"` Ember Data will use the relationship link to\n   reload the relationship. Otherwise it will reload the record by its\n   id.\n    Example\n    ```javascript\n   // models/blog.js\n   import { Model, belongsTo } from '@warp-drive/legacy/model';\n    export default class BlogModel extends Model {\n     @belongsTo('user', { async: true, inverse: null }) user;\n   }\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            data: { type: 'user', id: 1 }\n          }\n        }\n      }\n    });\n   let userRef = blog.belongsTo('user');\n    userRef.reload().then(function(user) {\n      userRef.value() === user\n    });\n   ```\n    You may also pass in an options object whose properties will be\n   fed forward. This enables you to pass `adapterOptions` into the\n   request given to the adapter via the reference. A full example\n   can be found in the `load` method.\n    Example\n    ```javascript\n   userRef.reload({ adapterOptions: { isPrivate: true } })\n   ```\n     @public\n   @param {Object} options the options to pass in.\n   @return {Promise} a promise that resolves with the record in this belongs-to relationship after the reload has completed.\n   */reload(options){const support=LEGACY_SUPPORT.get(this.___identifier);return support.reloadBelongsTo(this.key,options).then(()=>this.value());}}_BelongsToReference=BelongsToReference;(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.d)(_BelongsToReference.prototype,\"identifier\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.memoized]);(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.defineNonEnumerableSignal)(BelongsToReference.prototype,'_ref',0);const LEGACY_SUPPORT=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_1__.getOrSetGlobal)('LEGACY_SUPPORT',new Map());function lookupLegacySupport(record){const identifier=(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.recordIdentifierFor)(record);(test=>{if(!test){throw new Error(`Expected a record`);}})(identifier);let support=LEGACY_SUPPORT.get(identifier);if(!support){(test=>{if(!test){throw new Error(`Memory Leak Detected`);}})(!record.isDestroyed&&!record.isDestroying);support=new LegacySupport(record);LEGACY_SUPPORT.set(identifier,support);LEGACY_SUPPORT.set(record,support);}return support;}class LegacySupport{constructor(record){this.record=record;this.store=(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.storeFor)(record);this.identifier=(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.recordIdentifierFor)(record);this.cache=(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.peekCache)(record);if(this.store._graph){this.graph=this.store._graph;}this._manyArrayCache=Object.create(null);this._relationshipPromisesCache=Object.create(null);this._relationshipProxyCache=Object.create(null);this._pending=Object.create(null);this.references=Object.create(null);}_syncArray(array){// It’s possible the parent side of the relationship may have been destroyed by this point\nif(this.isDestroyed||this.isDestroying){return;}const currentState=array[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.SOURCE];const identifier=this.identifier;const[identifiers,jsonApi]=this._getCurrentState(identifier,array.key);if(jsonApi.meta){array.meta=jsonApi.meta;}if(jsonApi.links){array.links=jsonApi.links;}currentState.length=0;(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.fastPush)(currentState,identifiers);}mutate(mutation){this.cache.mutate(mutation);}_findBelongsTo(key,resource,relationship,options){// TODO @runspired follow up if parent isNew then we should not be attempting load here\n// TODO @runspired follow up on whether this should be in the relationship requests cache\nreturn this._findBelongsToByJsonApiResource(resource,this.identifier,relationship,options).then(identifier=>handleCompletedRelationshipRequest(this,key,relationship,identifier),e=>handleCompletedRelationshipRequest(this,key,relationship,null,e));}reloadBelongsTo(key,options){const loadingPromise=this._relationshipPromisesCache[key];if(loadingPromise){return loadingPromise;}const relationship=this.graph.get(this.identifier,key);(test=>{if(!test){throw new Error(`Expected ${key} to be a belongs-to relationship`);}})(isBelongsTo(relationship));const resource=this.cache.getRelationship(this.identifier,key);relationship.state.hasFailedLoadAttempt=false;relationship.state.shouldForceReload=true;const promise=this._findBelongsTo(key,resource,relationship,options);if(this._relationshipProxyCache[key]){// @ts-expect-error\nreturn this._updatePromiseProxyFor('belongsTo',key,{promise});}return promise;}getBelongsTo(key,options){const{identifier,cache}=this;const resource=cache.getRelationship(this.identifier,key);const relatedIdentifier=resource&&resource.data?resource.data:null;(test=>{if(!test){throw new Error(`Expected a stable identifier`);}})(!relatedIdentifier||(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.isStableIdentifier)(relatedIdentifier));const store=this.store;const relationship=this.graph.get(this.identifier,key);(test=>{if(!test){throw new Error(`Expected ${key} to be a belongs-to relationship`);}})(isBelongsTo(relationship));const isAsync=relationship.definition.isAsync;const _belongsToState={key,store,legacySupport:this,modelName:relationship.definition.type};if(isAsync){if(relationship.state.hasFailedLoadAttempt){return this._relationshipProxyCache[key];}const promise=this._findBelongsTo(key,resource,relationship,options);const isLoaded=relatedIdentifier&&store._instanceCache.recordIsLoaded(relatedIdentifier);return this._updatePromiseProxyFor('belongsTo',key,{promise,content:isLoaded?store._instanceCache.getRecord(relatedIdentifier):null,_belongsToState});}else{if(relatedIdentifier===null){return null;}else{(test=>{if(!test){throw new Error(`You looked up the '${key}' relationship on a '${identifier.type}' with id ${identifier.id||'null'} but some of the associated records were not loaded. Either make sure they are all loaded together with the parent record, or specify that the relationship is async (\\`belongsTo(<type>, { async: true, inverse: <inverse> })\\`)`);}})(store._instanceCache.recordIsLoaded(relatedIdentifier,true));return store._instanceCache.getRecord(relatedIdentifier);}}}setDirtyBelongsTo(key,value){return this.cache.mutate({op:'replaceRelatedRecord',record:this.identifier,field:key,value:extractIdentifierFromRecord(value)},// @ts-expect-error\ntrue);}_getCurrentState(identifier,field){const jsonApi=this.cache.getRelationship(identifier,field);const cache=this.store._instanceCache;const identifiers=[];if(jsonApi.data){for(let i=0;i<jsonApi.data.length;i++){const relatedIdentifier=jsonApi.data[i];(test=>{if(!test){throw new Error(`Expected a stable identifier`);}})((0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.isStableIdentifier)(relatedIdentifier));if(cache.recordIsLoaded(relatedIdentifier,true)){identifiers.push(relatedIdentifier);}}}return[identifiers,jsonApi];}getManyArray(key,definition){if(this.graph){let manyArray=this._manyArrayCache[key];if(!definition){definition=this.graph.get(this.identifier,key).definition;}if(!manyArray){const[identifiers,doc]=this._getCurrentState(this.identifier,key);manyArray=new _warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.RelatedCollection({store:this.store,type:definition.type,identifier:this.identifier,cache:this.cache,field:this.store.schema.fields(this.identifier).get(key),identifiers,key,meta:doc.meta||null,links:doc.links||null,isPolymorphic:definition.isPolymorphic,isAsync:definition.isAsync,_inverseIsAsync:definition.inverseIsAsync,// @ts-expect-error Typescript doesn't have a way for us to thread the generic backwards so it infers unknown instead of T\nmanager:this,isLoaded:!definition.isAsync,allowMutation:true});this._manyArrayCache[key]=manyArray;}return manyArray;}(test=>{{throw new Error('hasMany only works with the @ember-data/json-api package');}})();}fetchAsyncHasMany(key,relationship,manyArray,options){if(this.graph){let loadingPromise=this._relationshipPromisesCache[key];if(loadingPromise){return loadingPromise;}const jsonApi=this.cache.getRelationship(this.identifier,key);const promise=this._findHasManyByJsonApiResource(jsonApi,this.identifier,relationship,options);if(!promise){manyArray.isLoaded=true;return Promise.resolve(manyArray);}loadingPromise=promise.then(()=>handleCompletedRelationshipRequest(this,key,relationship,manyArray),e=>handleCompletedRelationshipRequest(this,key,relationship,manyArray,e));this._relationshipPromisesCache[key]=loadingPromise;return loadingPromise;}(test=>{{throw new Error('hasMany only works with the @ember-data/json-api package');}})();}reloadHasMany(key,options){if(this.graph){const loadingPromise=this._relationshipPromisesCache[key];if(loadingPromise){return loadingPromise;}const relationship=this.graph.get(this.identifier,key);const{definition,state}=relationship;state.hasFailedLoadAttempt=false;state.shouldForceReload=true;const manyArray=this.getManyArray(key,definition);const promise=this.fetchAsyncHasMany(key,relationship,manyArray,options);if(this._relationshipProxyCache[key]){return this._updatePromiseProxyFor('hasMany',key,{promise});}return promise;}(test=>{{throw new Error(`hasMany only works with the @ember-data/json-api package`);}})();}getHasMany(key,options){if(this.graph){const relationship=this.graph.get(this.identifier,key);const{definition,state}=relationship;const manyArray=this.getManyArray(key,definition);if(definition.isAsync){if(state.hasFailedLoadAttempt){return this._relationshipProxyCache[key];}const promise=this.fetchAsyncHasMany(key,relationship,manyArray,options);return this._updatePromiseProxyFor('hasMany',key,{promise,content:manyArray});}else{(test=>{if(!test){throw new Error(`You looked up the '${key}' relationship on a '${this.identifier.type}' with id ${this.identifier.id||'null'} but some of the associated records were not loaded. Either make sure they are all loaded together with the parent record, or specify that the relationship is async ('hasMany(<type>, { async: true, inverse: <inverse> })')`);}})(!anyUnloaded(this.store,relationship));return manyArray;}}(test=>{{throw new Error(`hasMany only works with the @ember-data/json-api package`);}})();}_updatePromiseProxyFor(kind,key,args){let promiseProxy=this._relationshipProxyCache[key];if(kind==='hasMany'){const{promise,content}=args;if(promiseProxy){(test=>{if(!test){throw new Error(`Expected a PromiseManyArray`);}})('_update'in promiseProxy);promiseProxy._update(promise,content);}else{promiseProxy=this._relationshipProxyCache[key]=new PromiseManyArray(promise,content);}return promiseProxy;}if(promiseProxy){const{promise,content}=args;(test=>{if(!test){throw new Error(`Expected a PromiseBelongsTo`);}})('_belongsToState'in promiseProxy);if(content!==undefined){promiseProxy.set('content',content);}void promiseProxy.set('promise',promise);}else{promiseProxy=PromiseBelongsTo.create(args);this._relationshipProxyCache[key]=promiseProxy;}return promiseProxy;}referenceFor(kind,name){let reference=this.references[name];if(!reference){if(!this.graph){// TODO @runspired while this feels odd, it is not a regression in capability because we do\n// not today support references pulling from RecordDatas other than our own\n// because of the intimate API access involved. This is something we will need to redesign.\n(test=>{{throw new Error(`snapshot.belongsTo only supported for @ember-data/json-api`);}})();}const{graph,identifier}=this;const relationship=graph.get(identifier,name);{if(kind){const modelName=identifier.type;const actualRelationshipKind=relationship.definition.kind;(test=>{if(!test){throw new Error(`You tried to get the '${name}' relationship on a '${modelName}' via record.${kind}('${name}'), but the relationship is of kind '${actualRelationshipKind}'. Use record.${actualRelationshipKind}('${name}') instead.`);}})(actualRelationshipKind===kind);}}const relationshipKind=relationship.definition.kind;if(relationshipKind==='belongsTo'){reference=new BelongsToReference(this.store,graph,identifier,relationship,name);}else if(relationshipKind==='hasMany'){reference=new HasManyReference(this.store,graph,identifier,relationship,name);}this.references[name]=reference;}return reference;}_findHasManyByJsonApiResource(resource,parentIdentifier,relationship,options={}){if(this.graph){if(!resource){return;}const{definition,state}=relationship;(0,_private_CKrP0ogQ_js__WEBPACK_IMPORTED_MODULE_3__.u)(this.store);const adapter=this.store.adapterFor?.(definition.type);const{isStale,hasDematerializedInverse,hasReceivedData,isEmpty,shouldForceReload}=state;const allInverseRecordsAreLoaded=areAllInverseRecordsLoaded(this.store,resource);const identifiers=resource.data;const shouldFindViaLink=resource.links&&resource.links.related&&(typeof adapter?.findHasMany==='function'||typeof identifiers==='undefined')&&(shouldForceReload||hasDematerializedInverse||isStale||!allInverseRecordsAreLoaded&&!isEmpty);const field=this.store.schema.fields({type:definition.inverseType}).get(definition.key);(test=>{if(!test){throw new Error(`Expected a hasMany field definition for ${definition.inverseType}.${definition.key}`);}})(field&&field.kind==='hasMany');const request={useLink:shouldFindViaLink,field,links:resource.links,meta:resource.meta,options,record:parentIdentifier};// fetch via link\nif(shouldFindViaLink){(test=>{if(!test){throw new Error(`Expected collection to be an array`);}})(!identifiers||Array.isArray(identifiers));(test=>{if(!test){throw new Error(`Expected stable identifiers`);}})(!identifiers||identifiers.every(_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.isStableIdentifier));const req=field.options.linksMode?{url:getRelatedLink(resource),op:'findHasMany',method:'GET',records:identifiers||[],data:request,[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_2__.EnableHydration]:false}:{op:'findHasMany',records:identifiers||[],data:request,cacheOptions:{[Symbol.for('wd:skip-cache')]:true}};return this.store.request(req);}const preferLocalCache=hasReceivedData&&!isEmpty;const hasLocalPartialData=hasDematerializedInverse||isEmpty&&Array.isArray(identifiers)&&identifiers.length>0;const attemptLocalCache=!shouldForceReload&&!isStale&&(preferLocalCache||hasLocalPartialData);if(attemptLocalCache&&allInverseRecordsAreLoaded){return;}const hasData=hasReceivedData&&!isEmpty;if(attemptLocalCache||hasData||hasLocalPartialData){(test=>{if(!test){throw new Error(`Expected collection to be an array`);}})(Array.isArray(identifiers));(test=>{if(!test){throw new Error(`Expected stable identifiers`);}})(identifiers.every(_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.isStableIdentifier));options.reload=options.reload||!attemptLocalCache||undefined;return this.store.request({op:'findHasMany',records:identifiers,data:request,cacheOptions:{[Symbol.for('wd:skip-cache')]:true}});}// we were explicitly told we have no data and no links.\n//   TODO if the relationshipIsStale, should we hit the adapter anyway?\nreturn;}(test=>{{throw new Error(`hasMany only works with the @ember-data/json-api package`);}})();}_findBelongsToByJsonApiResource(resource,parentIdentifier,relationship,options={}){if(!resource){return Promise.resolve(null);}const key=relationship.definition.key;// interleaved promises mean that we MUST cache this here\n// in order to prevent infinite re-render if the request\n// fails.\nif(this._pending[key]){return this._pending[key];}const identifier=resource.data?resource.data:null;(test=>{if(!test){throw new Error(`Expected a stable identifier`);}})(!identifier||(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.isStableIdentifier)(identifier));const{isStale,hasDematerializedInverse,hasReceivedData,isEmpty,shouldForceReload}=relationship.state;const allInverseRecordsAreLoaded=areAllInverseRecordsLoaded(this.store,resource);const shouldFindViaLink=resource.links?.related&&(shouldForceReload||hasDematerializedInverse||isStale||!allInverseRecordsAreLoaded&&!isEmpty);const field=this.store.schema.fields(this.identifier).get(relationship.definition.key);(test=>{if(!test){throw new Error(`Attempted to access a belongsTo relationship but no definition exists for it`);}})(field&&field.kind==='belongsTo');const request={useLink:shouldFindViaLink,field,links:resource.links,meta:resource.meta,options,record:parentIdentifier};// fetch via link\nif(shouldFindViaLink){const req=field.options.linksMode?{url:getRelatedLink(resource),op:'findBelongsTo',method:'GET',records:identifier?[identifier]:[],data:request,[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_2__.EnableHydration]:false}:{op:'findBelongsTo',records:identifier?[identifier]:[],data:request,cacheOptions:{[Symbol.for('wd:skip-cache')]:true}};const future=this.store.request(req);this._pending[key]=future.then(doc=>field.options.linksMode?doc.content.data:doc.content).finally(()=>{this._pending[key]=undefined;});return this._pending[key];}const preferLocalCache=hasReceivedData&&allInverseRecordsAreLoaded&&!isEmpty;const hasLocalPartialData=hasDematerializedInverse||isEmpty&&resource.data;// null is explicit empty, undefined is \"we don't know anything\"\nconst localDataIsEmpty=!identifier;const attemptLocalCache=!shouldForceReload&&!isStale&&(preferLocalCache||hasLocalPartialData);// we dont need to fetch and are empty\nif(attemptLocalCache&&localDataIsEmpty){return Promise.resolve(null);}// we dont need to fetch because we are local state\nconst resourceIsLocal=identifier?.id===null;if(attemptLocalCache&&allInverseRecordsAreLoaded||resourceIsLocal){return Promise.resolve(identifier);}// we may need to fetch\nif(identifier){(test=>{if(!test){throw new Error(`Cannot fetch belongs-to relationship with no information`);}})(identifier);options.reload=options.reload||!attemptLocalCache||undefined;this._pending[key]=this.store.request({op:'findBelongsTo',records:[identifier],data:request,cacheOptions:{[Symbol.for('wd:skip-cache')]:true}}).then(doc=>doc.content).finally(()=>{this._pending[key]=undefined;});return this._pending[key];}// we were explicitly told we have no data and no links.\n//   TODO if the relationshipIsStale, should we hit the adapter anyway?\nreturn Promise.resolve(null);}destroy(){this.isDestroying=true;let cache=this._manyArrayCache;this._manyArrayCache=Object.create(null);Object.keys(cache).forEach(key=>{cache[key].destroy();});cache=this._relationshipProxyCache;this._relationshipProxyCache=Object.create(null);Object.keys(cache).forEach(key=>{const proxy=cache[key];if(proxy.destroy){proxy.destroy();}});cache=this.references;this.references=Object.create(null);Object.keys(cache).forEach(key=>{cache[key].destroy();});this.isDestroyed=true;}}function getRelatedLink(resource){const related=resource.links?.related;(test=>{if(!test){throw new Error(`Expected a related link`);}})(related);return typeof related==='object'?related.href:related;}function handleCompletedRelationshipRequest(recordExt,key,relationship,value,error){delete recordExt._relationshipPromisesCache[key];relationship.state.shouldForceReload=false;const isHasMany=relationship.definition.kind==='hasMany';if(isHasMany){// we don't notify the record property here to avoid refetch\n// only the many array\n(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.notifyInternalSignal)(value[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.ARRAY_SIGNAL]);}if(error){relationship.state.hasFailedLoadAttempt=true;const proxy=recordExt._relationshipProxyCache[key];// belongsTo relationships are sometimes unloaded\n// when a load fails, in this case we need\n// to make sure that we aren't proxying\n// to destroyed content\n// for the sync belongsTo reload case there will be no proxy\n// for the async reload case there will be no proxy if the ui\n// has never been accessed\nif(proxy&&!isHasMany){// @ts-expect-error unsure why this is not resolving the boolean but async belongsTo is weird\nif(proxy.content&&proxy.content.isDestroying){proxy.set('content',null);}recordExt.store.notifications._flush();}throw error;}if(isHasMany){value.isLoaded=true;}else{recordExt.store.notifications._flush();}relationship.state.hasFailedLoadAttempt=false;// only set to not stale if no error is thrown\nrelationship.state.isStale=false;return isHasMany||!value?value:recordExt.store.peekRecord(value);}function extractIdentifierFromRecord(record){if(!record){return null;}return (0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.recordIdentifierFor)(record);}function anyUnloaded(store,relationship){const graph=store._graph;(test=>{if(!test){throw new Error(`Expected a Graph instance to be available`);}})(graph);const relationshipData=graph.getData(relationship.identifier,relationship.definition.key);const state=relationshipData.data;const cache=store._instanceCache;const unloaded=state?.find(s=>{const isLoaded=cache.recordIsLoaded(s,true);return!isLoaded;});return unloaded||false;}function areAllInverseRecordsLoaded(store,resource){const instanceCache=store._instanceCache;const identifiers=resource.data;if(Array.isArray(identifiers)){(test=>{if(!test){throw new Error(`Expected stable identifiers`);}})(identifiers.every(_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.isStableIdentifier));// treat as collection\n// check for unloaded records\nreturn identifiers.every(identifier=>instanceCache.recordIsLoaded(identifier));}// treat as single resource\nif(!identifiers)return true;(test=>{if(!test){throw new Error(`Expected stable identifiers`);}})((0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_0__.isStableIdentifier)(identifiers));return instanceCache.recordIsLoaded(identifiers);}function isBelongsTo(relationship){return relationship.definition.kind==='belongsTo';}// we force the type here to our own construct because mixin and extend patterns\n// lose generic signatures. We also do this because we need to Omit `clear` from\n// the type of ArrayProxy as we override it's signature.\nconst ArrayProxyWithCustomOverrides=(_ember_array_proxy__WEBPACK_IMPORTED_MODULE_9___default());/**\n  Holds validation errors for a given record, organized by attribute names.\n\n  This class is not directly instantiable.\n\n  Every `Model` has an `errors` property that is an instance of\n  `Errors`. This can be used to display validation error\n  messages returned from the server when a `record.save()` rejects.\n\n  For Example, if you had a `User` model that looked like this:\n\n  ```js [app/models/user.js]\n  import { Model, attr } from '@warp-drive/legacy/model';\n\n  export default class UserModel extends Model {\n    @attr('string') username;\n    @attr('string') email;\n  }\n  ```\n  And you attempted to save a record that did not validate on the backend:\n\n  ```javascript\n  let user = store.createRecord('user', {\n    username: 'tomster',\n    email: 'invalidEmail'\n  });\n  user.save();\n  ```\n\n  Your backend would be expected to return an error response that described\n  the problem, so that error messages can be generated on the app.\n\n  API responses will be translated into instances of `Errors` differently,\n  depending on the specific combination of adapter and serializer used. You\n  may want to check the documentation or the source code of the libraries\n  that you are using, to know how they expect errors to be communicated.\n\n  Errors can be displayed to the user by accessing their property name\n  to get an array of all the error objects for that property. Each\n  error object is a JavaScript object with two keys:\n\n  - `message` A string containing the error message from the backend\n  - `attribute` The name of the property associated with this error message\n\n  ```handlebars\n  <label>Username: <Input @value={{@model.username}} /> </label>\n  {{#each @model.errors.username as |error|}}\n    <div class=\"error\">\n      {{error.message}}\n    </div>\n  {{/each}}\n\n  <label>Email: <Input @value={{@model.email}} /> </label>\n  {{#each @model.errors.email as |error|}}\n    <div class=\"error\">\n      {{error.message}}\n    </div>\n  {{/each}}\n  ```\n\n  You can also access the special `messages` property on the error\n  object to get an array of all the error strings.\n\n  ```handlebars\n  {{#each @model.errors.messages as |message|}}\n    <div class=\"error\">\n      {{message}}\n    </div>\n  {{/each}}\n  ```\n\n  @class Errors\n  @public\n */var _messages2=/*#__PURE__*/new WeakMap();var _isEmpty=/*#__PURE__*/new WeakMap();class Errors extends ArrayProxyWithCustomOverrides{constructor(...args){super(...args);_classPrivateFieldInitSpec(this,_messages2,((0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.i)(this,\"messages\"),void 0));_classPrivateFieldInitSpec(this,_isEmpty,((0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.i)(this,\"isEmpty\"),void 0));}/**\n    @property errorsByAttributeName\n    @type {MapWithDefault}\n    @private\n  */get errorsByAttributeName(){return new Map();}/**\n    Returns errors for a given attribute\n     ```javascript\n    let user = store.createRecord('user', {\n      username: 'tomster',\n      email: 'invalidEmail'\n    });\n    user.save().catch(function(){\n      user.errors.errorsFor('email'); // returns:\n      // [{attribute: \"email\", message: \"Doesn't look like a valid email.\"}]\n    });\n    ```\n     @public\n    @param {String} attribute\n    @return {Array}\n  */errorsFor(attribute){const map=this.errorsByAttributeName;let errors=map.get(attribute);if(errors===undefined){errors=(0,_ember_array__WEBPACK_IMPORTED_MODULE_8__.A)();map.set(attribute,errors);}// Errors may be a native array with extensions turned on. Since we access\n// the array via a method, and not a computed or using `Ember.get`, it does\n// not entangle properly with autotracking, so we entangle manually by\n// getting the `[]` property.\n(0,_ember_object__WEBPACK_IMPORTED_MODULE_4__.get)(errors,'[]');return errors;}/**\n    An array containing all of the error messages for this\n    record. This is useful for displaying all errors to the user.\n     ```handlebars\n    {{#each @model.errors.messages as |message|}}\n      <div class=\"error\">\n        {{message}}\n      </div>\n    {{/each}}\n    ```\n     @property messages\n    @public\n    @type {Array}\n  *//**\n    @property content\n    @type {Array}\n    @private\n  */get content(){return (0,_ember_array__WEBPACK_IMPORTED_MODULE_8__.A)();}/**\n    @private\n  */unknownProperty(attribute){const errors=this.errorsFor(attribute);if(errors.length===0){return undefined;}return errors;}/**\n    Total number of errors.\n     @property length\n    @type {Number}\n    @public\n    @readonly\n  *//**\n    `true` if we have no errors.\n     @property isEmpty\n    @type {Boolean}\n    @public\n    @readonly\n  *//**\n   Manually adds errors to the record. This will trigger the `becameInvalid` event/ lifecycle method on\n    the record and transition the record into an `invalid` state.\n    Example\n   ```javascript\n    let errors = user.errors;\n     // add multiple errors\n    errors.add('password', [\n      'Must be at least 12 characters',\n      'Must contain at least one symbol',\n      'Cannot contain your name'\n    ]);\n     errors.errorsFor('password');\n    // =>\n    // [\n    //   { attribute: 'password', message: 'Must be at least 12 characters' },\n    //   { attribute: 'password', message: 'Must contain at least one symbol' },\n    //   { attribute: 'password', message: 'Cannot contain your name' },\n    // ]\n     // add a single error\n    errors.add('username', 'This field is required');\n     errors.errorsFor('username');\n    // =>\n    // [\n    //   { attribute: 'username', message: 'This field is required' },\n    // ]\n   ```\n    @public\n    @param {String} attribute - the property name of an attribute or relationship\n    @param {string[]|string} messages - an error message or array of error messages for the attribute\n   */add(attribute,messages){const errors=this._findOrCreateMessages(attribute,messages);this.addObjects(errors);this.errorsFor(attribute).addObjects(errors);this.__record.currentState.notify('isValid');this.notifyPropertyChange(attribute);}/**\n    @private\n  */_findOrCreateMessages(attribute,messages){const errors=this.errorsFor(attribute);const messagesArray=Array.isArray(messages)?messages:[messages];const _messages=new Array(messagesArray.length);for(let i=0;i<messagesArray.length;i++){const message=messagesArray[i];const err=errors.findBy('message',message);if(err){_messages[i]=err;}else{_messages[i]={attribute:attribute,message};}}return _messages;}/**\n   Manually removes all errors for a given member from the record.\n     This will transition the record into a `valid` state, and\n    triggers the `becameValid` event and lifecycle method.\n    Example:\n    ```javascript\n    let errors = user.errors;\n    errors.add('phone', ['error-1', 'error-2']);\n     errors.errorsFor('phone');\n    // =>\n    // [\n    //   { attribute: 'phone', message: 'error-1' },\n    //   { attribute: 'phone', message: 'error-2' },\n    // ]\n     errors.remove('phone');\n     errors.errorsFor('phone');\n    // => undefined\n   ```\n    @public\n   @param {String} member - the property name of an attribute or relationship\n   */remove(attribute){if(this.isEmpty){return;}const content=this.rejectBy('attribute',attribute);this.content.setObjects(content);// Although errorsByAttributeName.delete is technically enough to sync errors state, we also\n// must mutate the array as well for autotracking\nconst errors=this.errorsFor(attribute);for(let i=0;i<errors.length;i++){if(errors[i].attribute===attribute){// .replace from Ember.NativeArray is necessary. JS splice will not work.\nerrors.replace(i,1);}}this.errorsByAttributeName.delete(attribute);this.__record.currentState.notify('isValid');this.notifyPropertyChange(attribute);this.notifyPropertyChange('length');}/**\n   Manually clears all errors for the record.\n     This will transition the record into a `valid` state, and\n     will trigger the `becameValid` event and lifecycle method.\n   Example:\n    ```javascript\n   let errors = user.errors;\n   errors.add('username', ['error-a']);\n   errors.add('phone', ['error-1', 'error-2']);\n    errors.errorsFor('username');\n   // =>\n   // [\n   //   { attribute: 'username', message: 'error-a' },\n   // ]\n    errors.errorsFor('phone');\n   // =>\n   // [\n   //   { attribute: 'phone', message: 'error-1' },\n   //   { attribute: 'phone', message: 'error-2' },\n   // ]\n    errors.clear();\n    errors.errorsFor('username');\n   // => undefined\n    errors.errorsFor('phone');\n   // => undefined\n    errors.messages\n   // => []\n   ```\n   @public\n   */clear(){if(this.isEmpty){return;}const errorsByAttributeName=this.errorsByAttributeName;const attributes=[];errorsByAttributeName.forEach(function(_,attribute){attributes.push(attribute);});errorsByAttributeName.clear();attributes.forEach(attribute=>{this.notifyPropertyChange(attribute);});this.__record.currentState.notify('isValid');super.clear();}/**\n    Checks if there are error messages for the given attribute.\n     ```js [app/controllers/user/edit.js]\n    export default class UserEditController extends Controller {\n      @action\n      save(user) {\n        if (user.errors.has('email')) {\n          return alert('Please update your email before attempting to save.');\n        }\n        user.save();\n      }\n    }\n    ```\n     @public\n    @param {String} attribute\n    @return {Boolean} true if there some errors on given attribute\n  */has(attribute){return this.errorsFor(attribute).length>0;}}_Errors=Errors;(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.d)(_Errors.prototype,\"errorsByAttributeName\",[(0,_ember_object__WEBPACK_IMPORTED_MODULE_4__.computed)()]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.a)(_Errors.prototype,\"messages\",[(0,_ember_object_computed__WEBPACK_IMPORTED_MODULE_10__.mapBy)('content','message')]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.d)(_Errors.prototype,\"content\",[(0,_ember_object__WEBPACK_IMPORTED_MODULE_4__.computed)()]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_7__.a)(_Errors.prototype,\"isEmpty\",[(0,_ember_object_computed__WEBPACK_IMPORTED_MODULE_10__.not)('length')]);\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/legacy/dist/errors-BX5wowuz.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/legacy/dist/model.js":
/*!*******************************************************!*\
  !*** ./node_modules/@warp-drive/legacy/dist/model.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Model: () => (/* reexport safe */ _schema_provider_BdQhkT_Q_js__WEBPACK_IMPORTED_MODULE_3__.M),\n/* harmony export */   attr: () => (/* binding */ attr),\n/* harmony export */   belongsTo: () => (/* binding */ belongsTo),\n/* harmony export */   buildSchema: () => (/* reexport safe */ _schema_provider_BdQhkT_Q_js__WEBPACK_IMPORTED_MODULE_3__.b),\n/* harmony export */   \"default\": () => (/* reexport safe */ _schema_provider_BdQhkT_Q_js__WEBPACK_IMPORTED_MODULE_3__.M),\n/* harmony export */   hasMany: () => (/* binding */ hasMany),\n/* harmony export */   instantiateRecord: () => (/* binding */ instantiateRecord),\n/* harmony export */   modelFor: () => (/* binding */ modelFor),\n/* harmony export */   teardownRecord: () => (/* binding */ teardownRecord)\n/* harmony export */ });\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/object */ \"@ember/object\");\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_object__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _warp_drive_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @warp-drive/core */ \"./node_modules/@warp-drive/core/dist/index.js\");\n/* harmony import */ var _warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @warp-drive/core/store/-private */ \"./node_modules/@warp-drive/core/dist/store/-private.js\");\n/* harmony import */ var _schema_provider_BdQhkT_Q_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./schema-provider-BdQhkT-Q.js */ \"./node_modules/@warp-drive/legacy/dist/schema-provider-BdQhkT-Q.js\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @warp-drive/core/types/symbols */ \"./node_modules/@warp-drive/core/dist/types/symbols.js\");\n/* harmony import */ var _errors_BX5wowuz_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./errors-BX5wowuz.js */ \"./node_modules/@warp-drive/legacy/dist/errors-BX5wowuz.js\");\n/* harmony import */ var _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @warp-drive/utilities/string */ \"./node_modules/@warp-drive/utilities/dist/string.js\");\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ember/application */ \"@ember/application\");\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_ember_application__WEBPACK_IMPORTED_MODULE_8__);\nfunction _attr(type,options){if(typeof type==='object'){options=type;type=undefined;}else{options=options||{};}const meta={type:type,kind:'attribute',isAttribute:true,options:options,key:null};return (0,_ember_object__WEBPACK_IMPORTED_MODULE_0__.computed)({get(key){{if(['currentState'].includes(key)){throw new Error(`'${key}' is a reserved property name on instances of classes extending Model. Please choose a different property name for your attr on ${this.constructor.toString()}`);}}if(this.isDestroyed||this.isDestroying){return;}return (0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_2__.peekCache)(this).getAttr((0,_warp_drive_core__WEBPACK_IMPORTED_MODULE_1__.recordIdentifierFor)(this),key);},set(key,value){{if(['currentState'].includes(key)){throw new Error(`'${key}' is a reserved property name on instances of classes extending Model. Please choose a different property name for your attr on ${this.constructor.toString()}`);}}const identifier=(0,_warp_drive_core__WEBPACK_IMPORTED_MODULE_1__.recordIdentifierFor)(this);(test=>{if(!test){throw new Error(`Attempted to set '${key}' on the deleted record ${identifier.type}:${identifier.id} (${identifier.lid})`);}})(!this.currentState.isDeleted);const cache=(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_2__.peekCache)(this);const currentValue=cache.getAttr(identifier,key);if(currentValue!==value){cache.setAttr(identifier,key,value);if(!this.isValid){const{errors}=this;if(errors.get(key)){errors.remove(key);this.currentState.cleanErrorRequests();}}}return value;}}).meta(meta);}// NOTE: Usage of Explicit ANY\n// -------------------------------------------------------------------\n// any is required here because we are the maximal not the minimal\n// subset of options allowed. If we used unknown, object, or\n// Record<string, unknown> we would get type errors when we try to\n// assert against a more specific implementation with precise options.\n// -------------------------------------------------------------------\n// see note on Explicit ANY above\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n/**\n * The return type of `void` is a lie to appease TypeScript. The actual return type\n * is a descriptor, but typescript incorrectly insists that decorator functions return\n * `void` or `any`.\n *\n *//**\n  `attr` defines an attribute on a [Model](/ember-data/release/classes/Model).\n  By default, attributes are passed through as-is, however you can specify an\n  optional type to have the value automatically transformed.\n  EmberData ships with four basic transform types: `string`, `number`,\n  `boolean` and `date`. You can define your own transforms by subclassing\n  [Transform](/ember-data/release/classes/Transform).\n\n  Note that you cannot use `attr` to define an attribute of `id`.\n\n  `attr` takes an optional hash as a second parameter, currently\n  supported options are:\n\n  - `defaultValue`: Pass a string or a function to be called to set the attribute\n  to a default value if and only if the key is absent from the payload response.\n\n  Example\n\n  ```js [app/models/user.js]\n  import { Model, attr } from '@warp-drive/legacy/model';\n\n  export default class UserModel extends Model {\n    @attr('string') username;\n    @attr('string') email;\n    @attr('boolean', { defaultValue: false }) verified;\n  }\n  ```\n\n  Default value can also be a function. This is useful it you want to return\n  a new object for each attribute.\n\n  ```js [app/models/user.js]\n  import { Model, attr } from '@warp-drive/legacy/model';\n\n  export default class UserModel extends Model {\n    @attr('string') username;\n    @attr('string') email;\n\n    @attr({\n      defaultValue() {\n        return {};\n      }\n    })\n    settings;\n  }\n  ```\n\n  The `options` hash is passed as second argument to a transforms'\n  `serialize` and `deserialize` method. This allows to configure a\n  transformation and adapt the corresponding value, based on the config:\n\n  ```js [app/models/post.js]\n  import { Model, attr } from '@warp-drive/legacy/model';\n\n  export default class PostModel extends Model {\n    @attr('text', {\n      uppercase: true\n    })\n    text;\n  }\n  ```\n\n  ```js [app/transforms/text.js]\n  export default class TextTransform {\n    serialize(value, options) {\n      if (options.uppercase) {\n        return value.toUpperCase();\n      }\n\n      return value;\n    }\n\n    deserialize(value) {\n      return value;\n    }\n\n    static create() {\n      return new this();\n    }\n  }\n  ```\n\n  @public\n  @param {String|Object} type the attribute type\n  @param {Object} options a hash of options\n  @return {Attribute}\n*/// see note on DataDecorator for why void\nfunction attr(type,options,desc){const args=[type,options,desc];// see note on DataDecorator for why void\nreturn (0,_schema_provider_BdQhkT_Q_js__WEBPACK_IMPORTED_MODULE_3__.j)(args)?_attr()(...args):_attr(type,options);}//   get: () => getT;\n//   // set: (value: Awaited<getT>) => void;\n//   set: (value: getT) => void;\n//   // init: () => getT;\n// };\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n// BelongsToDecoratorObject<getT>;\nfunction _belongsTo(type,options){(test=>{if(!test){throw new Error(`Expected options.async from @belongsTo('${type}', options) to be a boolean`);}})(options&&typeof options.async==='boolean');(test=>{if(!test){throw new Error(`Expected options.inverse from @belongsTo('${type}', options) to be either null or the string type of the related resource.`);}})(options.inverse===null||typeof options.inverse==='string'&&options.inverse.length>0);const meta={type:(0,_schema_provider_BdQhkT_Q_js__WEBPACK_IMPORTED_MODULE_3__.n)(type),options:options,kind:'belongsTo',name:'<Unknown BelongsTo>'};return (0,_ember_object__WEBPACK_IMPORTED_MODULE_0__.computed)({get(key){// this is a legacy behavior we may not carry into a new model setup\n// it's better to error on disconnected records so users find errors\n// in their logic.\nif(this.isDestroying||this.isDestroyed){return null;}const support=(0,_errors_BX5wowuz_js__WEBPACK_IMPORTED_MODULE_6__.l)(this);{if(['currentState'].includes(key)){throw new Error(`'${key}' is a reserved property name on instances of classes extending Model. Please choose a different property name for your belongsTo on ${this.constructor.toString()}`);}if(Object.prototype.hasOwnProperty.call(options,'serialize')){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_4__.warn)(`You provided a serialize option on the \"${key}\" property in the \"${support.identifier.type}\" class, this belongs in the serializer. See Serializer and it's implementations https://api.emberjs.com/ember-data/release/classes/Serializer`,false,{id:'ds.model.serialize-option-in-belongs-to'});}if(Object.prototype.hasOwnProperty.call(options,'embedded')){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_4__.warn)(`You provided an embedded option on the \"${key}\" property in the \"${support.identifier.type}\" class, this belongs in the serializer. See EmbeddedRecordsMixin https://api.emberjs.com/ember-data/release/classes/EmbeddedRecordsMixin`,false,{id:'ds.model.embedded-option-in-belongs-to'});}}return support.getBelongsTo(key);},set(key,value){(test=>{if(!test){throw new Error(`Cannot set belongsTo relationship ${key} on a destroyed record`);}})(!this.isDestroying&&!this.isDestroyed);if(this.isDestroying||this.isDestroyed){return null;}const support=(0,_errors_BX5wowuz_js__WEBPACK_IMPORTED_MODULE_6__.l)(this);{if(['currentState'].includes(key)){throw new Error(`'${key}' is a reserved property name on instances of classes extending Model. Please choose a different property name for your belongsTo on ${this.constructor.toString()}`);}}this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__.RecordStore]._join(()=>{support.setDirtyBelongsTo(key,value);});return support.getBelongsTo(key);}}).meta(meta);}/**\n  `belongsTo` is used to define One-To-One and One-To-Many, and One-To-None\n  relationships on a [Model](/ember-data/release/classes/Model).\n\n  `belongsTo` takes a configuration hash as a second parameter, currently\n  supported options are:\n\n  - `async`: (*required*) A boolean value used to declare whether this is a sync (false) or async (true) relationship.\n  - `inverse`: (*required*)  A string used to identify the inverse property on a related model, or `null`.\n  - `polymorphic`: (*optional*) A boolean value to mark the relationship as polymorphic\n  - `as`: (*optional*) A string used to declare the abstract type \"this\" record satisfies for polymorphism.\n\n  ### Examples\n\n  To declare a **one-to-many** (or many-to-many) relationship, use\n  `belongsTo` in combination with `hasMany`:\n\n  ```js\n  // app/models/comment.js\n  import { Model, belongsTo } from '@warp-drive/legacy/model';\n\n  export default class Comment extends Model {\n    @belongsTo('post', { async: false, inverse: 'comments' }) post;\n  }\n\n  // app/models/post.js\n  import { Model, hasMany } from '@warp-drive/legacy/model';\n\n  export default class Post extends Model {\n    @hasMany('comment', { async: false, inverse: 'post' }) comments;\n  }\n  ```\n\n  To declare a **one-to-one** relationship with managed inverses, use `belongsTo` for both sides:\n\n  ```js\n  // app/models/author.js\n  import { Model, belongsTo } from '@warp-drive/legacy/model';\n\n  export default class Author extends Model {\n    @belongsTo('address', { async: true, inverse: 'owner' }) address;\n  }\n\n  // app/models/address.js\n  import { Model, belongsTo } from '@warp-drive/legacy/model';\n\n  export default class Address extends Model {\n    @belongsTo('author', { async: true, inverse: 'address' }) owner;\n  }\n  ```\n\n  To declare a **one-to-one** relationship without managed inverses, use `belongsTo` for both sides\n  with `null` as the inverse:\n\n  ```js\n  // app/models/author.js\n  import { Model, belongsTo } from '@warp-drive/legacy/model';\n\n  export default class Author extends Model {\n    @belongsTo('address', { async: true, inverse: null }) address;\n  }\n\n  // app/models/address.js\n  import { Model, belongsTo } from '@warp-drive/legacy/model';\n\n  export default class Address extends Model {\n    @belongsTo('author', { async: true, inverse: null }) owner;\n  }\n  ```\n\n  To declare a one-to-none relationship between two models, use\n  `belongsTo` with inverse set to `null` on just one side::\n\n  ```js\n  // app/models/person.js\n  import { Model, belongsTo } from '@warp-drive/legacy/model';\n\n  export default class Person extends Model {\n    @belongsTo('person', { async: false, inverse: null }) bestFriend;\n  }\n  ```\n\n  #### Sync vs Async Relationships\n\n  EmberData fulfills relationships using resource data available in\n  the cache.\n\n  Sync relationships point directly to the known related resources.\n\n  When a relationship is declared as async, if any of the known related\n  resources have not been loaded, they will be fetched. The property\n  on the record when accessed provides a promise that resolves once\n  all resources are loaded.\n\n  Async relationships may take advantage of links. On access, if the related\n  link has not been loaded, or if any known resources are not available in\n  the cache, the fresh state will be fetched using the link.\n\n  In contrast to async relationship, accessing a sync relationship\n  will error on access when any of the known related resources have\n  not been loaded.\n\n  If you are using `links` with sync relationships, you have to use\n  the BelongsTo reference API to fetch or refresh related resources\n  that aren't loaded. For instance, for a `bestFriend` relationship:\n\n  ```js\n  person.belongsTo('bestFriend').reload();\n  ```\n\n  #### Polymorphic Relationships\n\n  To declare a polymorphic relationship, use `hasMany` with the `polymorphic`\n  option set to `true`:\n\n  ```js\n  // app/models/comment.js\n  import { Model, belongsTo } from '@warp-drive/legacy/model';\n\n  export default class Comment extends Model {\n    @belongsTo('commentable', { async: false, inverse: 'comments', polymorphic: true }) parent;\n  }\n  ```\n\n  `'commentable'` here is referred to as the \"abstract type\" for the polymorphic\n  relationship.\n\n  Polymorphic relationships with `inverse: null` will accept any type of record as their content.\n  Polymorphic relationships with `inverse` set to a string will only accept records with a matching\n  inverse relationships declaring itself as satisfying the abstract type.\n\n  Below, 'as' is used to declare the that 'post' record satisfies the abstract type 'commentable'\n  for this relationship.\n\n  ```js\n  // app/models/post.js\n  import { Model, hasMany } from '@warp-drive/legacy/model';\n\n  export default class Post extends Model {\n    @hasMany('comment', { async: false, inverse: 'parent', as: 'commentable' }) comments;\n  }\n  ```\n\n  Note: every Model that declares an inverse to a polymorphic relationship must\n  declare itself exactly the same. This is because polymorphism is based on structural\n  traits.\n\n  Polymorphic to polymorphic relationships are supported. Both sides of the relationship\n  must be declared as polymorphic, and the `as` option must be used to declare the abstract\n  type each record satisfies on both sides.\n\n  @public\n  @param {String} type (optional) the name of the related resource\n  @param {Object} options (optional) a hash of options\n  @return {PropertyDescriptor} relationship\n*/// export function belongsTo<K extends Promise<unknown>, T extends Awaited<K> = Awaited<K>>(\n//   type: TypeFromInstance<NoNull<T>>,\n//   options: RelationshipOptions<T, true>\n// ): RelationshipDecorator<K>;\nfunction belongsTo(type,options){{(test=>{if(!test){throw new Error(`belongsTo must be invoked with a type and options. Did you mean \\`@belongsTo(${type}, { async: false, inverse: null })\\`?`);}})(!(0,_schema_provider_BdQhkT_Q_js__WEBPACK_IMPORTED_MODULE_3__.j)(arguments));}return _belongsTo(type,options);}function normalizeType(type){{const result=(0,_warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_7__.singularize)((0,_warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_7__.dasherize)(type));(0,_ember_debug__WEBPACK_IMPORTED_MODULE_4__.deprecate)(`The resource type '${type}' is not normalized. Update your application code to use '${result}' instead of '${type}'.`,result===type,{id:'ember-data:deprecate-non-strict-types',until:'6.0',for:'ember-data',since:{available:'4.13',enabled:'5.3'}});return result;}// removed by dead control flow\n}function _hasMany(type,options){(test=>{if(!test){throw new Error(`Expected hasMany options.async to be a boolean`);}})(options&&typeof options.async==='boolean');// Metadata about relationships is stored on the meta of\n// the relationship. This is used for introspection and\n// serialization. Note that `key` is populated lazily\n// the first time the CP is called.\nconst meta={type:normalizeType(type),options,kind:'hasMany',name:'<Unknown BelongsTo>'};return (0,_ember_object__WEBPACK_IMPORTED_MODULE_0__.computed)({get(key){{if(['currentState'].includes(key)){throw new Error(`'${key}' is a reserved property name on instances of classes extending Model. Please choose a different property name for your hasMany on ${this.constructor.toString()}`);}}if(this.isDestroying||this.isDestroyed){return[];}return (0,_errors_BX5wowuz_js__WEBPACK_IMPORTED_MODULE_6__.l)(this).getHasMany(key);},set(key,records){{if(['currentState'].includes(key)){throw new Error(`'${key}' is a reserved property name on instances of classes extending Model. Please choose a different property name for your hasMany on ${this.constructor.toString()}`);}}const support=(0,_errors_BX5wowuz_js__WEBPACK_IMPORTED_MODULE_6__.l)(this);const manyArray=support.getManyArray(key);(test=>{if(!test){throw new Error(`You must pass an array of records to set a hasMany relationship`);}})(Array.isArray(records));this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__.RecordStore]._join(()=>{manyArray.splice(0,manyArray.length,...records);});return support.getHasMany(key);}}).meta(meta);}/**\n  `hasMany` is used to define Many-To-One and Many-To-Many, and Many-To-None\n  relationships on a [Model](/ember-data/release/classes/Model).\n\n  `hasMany` takes a configuration hash as a second parameter, currently\n  supported options are:\n\n  - `async`: (*required*) A boolean value used to declare whether this is a sync (false) or async (true) relationship.\n  - `inverse`: (*required*)  A string used to identify the inverse property on a related model, or `null`.\n  - `polymorphic`: (*optional*) A boolean value to mark the relationship as polymorphic\n  - `as`: (*optional*) A string used to declare the abstract type \"this\" record satisfies for polymorphism.\n\n  ### Examples\n\n  To declare a **many-to-one** (or one-to-many) relationship, use\n  `belongsTo` in combination with `hasMany`:\n\n  ```js\n  // app/models/post.js\n  import { Model, hasMany } from '@warp-drive/legacy/model';\n\n  export default class Post extends Model {\n    @hasMany('comment', { async: false, inverse: 'post' }) comments;\n  }\n\n\n  // app/models/comment.js\n  import { Model, belongsTo } from '@warp-drive/legacy/model';\n\n  export default class Comment extends Model {\n    @belongsTo('post', { async: false, inverse: 'comments' }) post;\n  }\n  ```\n\n  To declare a **many-to-many** relationship with managed inverses, use `hasMany` for both sides:\n\n  ```js\n  // app/models/post.js\n  import { Model, hasMany } from '@warp-drive/legacy/model';\n\n  export default class Post extends Model {\n    @hasMany('tag', { async: true, inverse: 'posts' }) tags;\n  }\n\n  // app/models/tag.js\n  import { Model, hasMany } from '@warp-drive/legacy/model';\n\n  export default class Tag extends Model {\n    @hasMany('post', { async: true, inverse: 'tags' }) posts;\n  }\n  ```\n\n  To declare a **many-to-many** relationship without managed inverses, use `hasMany` for both sides\n  with `null` as the inverse:\n\n  ```js\n  // app/models/post.js\n  import { Model, hasMany } from '@warp-drive/legacy/model';\n\n  export default class Post extends Model {\n    @hasMany('tag', { async: true, inverse: null }) tags;\n  }\n\n  // app/models/tag.js\n  import { Model, hasMany } from '@warp-drive/legacy/model';\n\n  export default class Tag extends Model {\n    @hasMany('post', { async: true, inverse: null }) posts;\n  }\n  ```\n\n  To declare a many-to-none relationship between two models, use\n  `hasMany` with inverse set to `null` on just one side::\n\n  ```js\n  // app/models/post.js\n  import { Model, hasMany } from '@warp-drive/legacy/model';\n\n  export default class Post extends Model {\n    @hasMany('category', { async: true, inverse: null }) categories;\n  }\n  ```\n\n  #### Sync vs Async Relationships\n\n  EmberData fulfills relationships using resource data available in\n  the cache.\n\n  Sync relationships point directly to the known related resources.\n\n  When a relationship is declared as async, if any of the known related\n  resources have not been loaded, they will be fetched. The property\n  on the record when accessed provides a promise that resolves once\n  all resources are loaded.\n\n  Async relationships may take advantage of links. On access, if the related\n  link has not been loaded, or if any known resources are not available in\n  the cache, the fresh state will be fetched using the link.\n\n  In contrast to async relationship, accessing a sync relationship\n  will error on access when any of the known related resources have\n  not been loaded.\n\n  If you are using `links` with sync relationships, you have to use\n  the HasMany reference API to fetch or refresh related resources\n  that aren't loaded. For instance, for a `comments` relationship:\n\n  ```js\n  post.hasMany('comments').reload();\n  ```\n\n  #### Polymorphic Relationships\n\n  To declare a polymorphic relationship, use `hasMany` with the `polymorphic`\n  option set to `true`:\n\n  ```js\n  // app/models/comment.js\n  import { Model, belongsTo } from '@warp-drive/legacy/model';\n\n  export default class Comment extends Model {\n    @belongsTo('commentable', { async: false, inverse: 'comments', polymorphic: true }) parent;\n  }\n  ```\n\n  `'commentable'` here is referred to as the \"abstract type\" for the polymorphic\n  relationship.\n\n  Polymorphic relationships with `inverse: null` will accept any type of record as their content.\n  Polymorphic relationships with `inverse` set to a string will only accept records with a matching\n  inverse relationships declaring itself as satisfying the abstract type.\n\n  Below, 'as' is used to declare the that 'post' record satisfies the abstract type 'commentable'\n  for this relationship.\n\n  ```js\n  // app/models/post.js\n  import { Model, hasMany } from '@warp-drive/legacy/model';\n\n  export default class Post extends Model {\n    @hasMany('comment', { async: false, inverse: 'parent', as: 'commentable' }) comments;\n  }\n  ```\n\n  Note: every Model that declares an inverse to a polymorphic relationship must\n  declare itself exactly the same. This is because polymorphism is based on structural\n  traits.\n\n  Polymorphic to polymorphic relationships are supported. Both sides of the relationship\n  must be declared as polymorphic, and the `as` option must be used to declare the abstract\n  type each record satisfies on both sides.\n\n  @public\n  @param {String} type (optional) the name of the related resource\n  @param {Object} options (optional) a hash of options\n  @return {PropertyDescriptor} relationship\n*/// export function hasMany<K extends Promise<unknown>, T extends Awaited<K> = Awaited<K>>(\n//   type: TypeFromInstance<NoNull<T>>,\n//   options: RelationshipOptions<T, true>\n// ): RelationshipDecorator<K>;\nfunction hasMany(type,options){{(test=>{if(!test){throw new Error(`hasMany must be invoked with a type and options. Did you mean \\`@hasMany(${type}, { async: false, inverse: null })\\`?`);}})(!(0,_schema_provider_BdQhkT_Q_js__WEBPACK_IMPORTED_MODULE_3__.j)(arguments));}return _hasMany(type,options);}function instantiateRecord(identifier,createRecordArgs){const type=identifier.type;const cache=this.cache;// TODO deprecate allowing unknown args setting\nconst createOptions={_createProps:createRecordArgs,// TODO @deprecate consider deprecating accessing record properties during init which the below is necessary for\n_secretInit:{identifier,cache,store:this,cb:secretInit}};// ensure that `getOwner(this)` works inside a model instance\n(0,_ember_application__WEBPACK_IMPORTED_MODULE_8__.setOwner)(createOptions,(0,_ember_application__WEBPACK_IMPORTED_MODULE_8__.getOwner)(this));const factory=(0,_schema_provider_BdQhkT_Q_js__WEBPACK_IMPORTED_MODULE_3__.k)(this,type);(test=>{if(!test){throw new Error(`No model was found for '${type}'`);}})(factory);return factory.class.create(createOptions);}function teardownRecord(record){(test=>{if(!test){throw new Error(`expected to receive an instance of Model from @ember-data/model. If using a custom model make sure you implement teardownRecord`);}})('destroy'in record);record.destroy();}function modelFor(modelName){(test=>{if(!test){throw new Error(`Attempted to call store.modelFor(), but the store instance has already been destroyed.`);}})(!this.isDestroyed&&!this.isDestroying);(test=>{if(!test){throw new Error(`You need to pass a model name to the store's modelFor method`);}})(modelName);(test=>{if(!test){throw new Error(`Please pass a proper model name to the store's modelFor method`);}})(typeof modelName==='string'&&modelName.length);const type=(0,_schema_provider_BdQhkT_Q_js__WEBPACK_IMPORTED_MODULE_3__.n)(modelName);const maybeFactory=(0,_schema_provider_BdQhkT_Q_js__WEBPACK_IMPORTED_MODULE_3__.k)(this,type);const klass=maybeFactory&&maybeFactory.class?maybeFactory.class:null;const ignoreType=!klass||!klass.isModel||this._forceShim;if(!ignoreType){return klass;}(test=>{if(!test){throw new Error(`No model was found for '${type}' and no schema handles the type`);}})(this.schema.hasResource({type}));}function secretInit(record,cache,identifier,store){(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_2__.setRecordIdentifier)(record,identifier);_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_2__.StoreMap.set(record,store);(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_2__.setCacheFor)(record,cache);}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/legacy/dist/model.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/legacy/dist/runtime-BPCpkOf1-BKOwiRJp.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@warp-drive/legacy/dist/runtime-BPCpkOf1-BKOwiRJp.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ decorateFieldV2),\n/* harmony export */   d: () => (/* binding */ decorateMethodV2),\n/* harmony export */   i: () => (/* binding */ initializeDeferredDecorator)\n/* harmony export */ });\nconst deferred=/* @__PURE__ */new WeakMap();function deferDecorator(proto,prop,desc){let map=deferred.get(proto);if(!map){map=/* @__PURE__ */new Map();deferred.set(proto,map);}map.set(prop,desc);}function findDeferredDecorator(target,prop){var _a;let cursor=target.prototype;while(cursor){let desc=(_a=deferred.get(cursor))==null?void 0:_a.get(prop);if(desc){return desc;}cursor=cursor.prototype;}}function decorateFieldV2(prototype,prop,decorators,initializer){let desc={configurable:true,enumerable:true,writable:true,initializer:null};if(initializer){desc.initializer=initializer;}for(let decorator of decorators){desc=decorator(prototype,prop,desc)||desc;}if(desc.initializer===void 0){Object.defineProperty(prototype,prop,desc);}else{deferDecorator(prototype,prop,desc);}}function decorateMethodV2(prototype,prop,decorators){const origDesc=Object.getOwnPropertyDescriptor(prototype,prop);let desc={...origDesc};for(let decorator of decorators){desc=decorator(prototype,prop,desc)||desc;}if(desc.initializer!==void 0){desc.value=desc.initializer?desc.initializer.call(prototype):void 0;desc.initializer=void 0;}Object.defineProperty(prototype,prop,desc);}function initializeDeferredDecorator(target,prop){let desc=findDeferredDecorator(target.constructor,prop);if(desc){Object.defineProperty(target,prop,{enumerable:desc.enumerable,configurable:desc.configurable,writable:desc.writable,value:desc.initializer?desc.initializer.call(target):void 0});}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/legacy/dist/runtime-BPCpkOf1-BKOwiRJp.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/legacy/dist/schema-provider-BdQhkT-Q.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@warp-drive/legacy/dist/schema-provider-BdQhkT-Q.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   M: () => (/* binding */ Model),\n/* harmony export */   R: () => (/* binding */ RecordState),\n/* harmony export */   a: () => (/* binding */ save),\n/* harmony export */   b: () => (/* binding */ buildSchema),\n/* harmony export */   c: () => (/* binding */ reload),\n/* harmony export */   d: () => (/* binding */ destroyRecord),\n/* harmony export */   e: () => (/* binding */ deleteRecord),\n/* harmony export */   f: () => (/* binding */ changedAttributes),\n/* harmony export */   g: () => (/* binding */ belongsTo),\n/* harmony export */   h: () => (/* binding */ hasMany),\n/* harmony export */   i: () => (/* binding */ createSnapshot),\n/* harmony export */   j: () => (/* binding */ isElementDescriptor),\n/* harmony export */   k: () => (/* binding */ getModelFactory),\n/* harmony export */   n: () => (/* binding */ normalizeModelName),\n/* harmony export */   r: () => (/* binding */ rollbackAttributes),\n/* harmony export */   s: () => (/* binding */ serialize),\n/* harmony export */   u: () => (/* binding */ unloadRecord)\n/* harmony export */ });\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/application */ \"@ember/application\");\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_application__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember/object */ \"@ember/object\");\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ember_object__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _warp_drive_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @warp-drive/core */ \"./node_modules/@warp-drive/core/dist/index.js\");\n/* harmony import */ var _warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @warp-drive/core/store/-private */ \"./node_modules/@warp-drive/core/dist/store/-private.js\");\n/* harmony import */ var _warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @warp-drive/core/types/symbols */ \"./node_modules/@warp-drive/core/dist/types/symbols.js\");\n/* harmony import */ var _errors_BX5wowuz_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./errors-BX5wowuz.js */ \"./node_modules/@warp-drive/legacy/dist/errors-BX5wowuz.js\");\n/* harmony import */ var _private_CKrP0ogQ_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./-private-CKrP0ogQ.js */ \"./node_modules/@warp-drive/legacy/dist/-private-CKrP0ogQ.js\");\n/* harmony import */ var _ember_object_internals__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ember/object/internals */ \"@ember/object/internals\");\n/* harmony import */ var _ember_object_internals__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_ember_object_internals__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./runtime-BPCpkOf1-BKOwiRJp.js */ \"./node_modules/@warp-drive/legacy/dist/runtime-BPCpkOf1-BKOwiRJp.js\");\n/* harmony import */ var _warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @warp-drive/utilities/string */ \"./node_modules/@warp-drive/utilities/dist/string.js\");\nvar _RecordState,_Model;function _defineProperty(e,r,t){return(r=_toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\";}function _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}function isElementDescriptor(args){const[maybeTarget,maybeKey,maybeDesc]=args;return(// Ensure we have the right number of args\nargs.length===3&&(// Make sure the target is a class or object (prototype)\ntypeof maybeTarget==='function'||typeof maybeTarget==='object'&&maybeTarget!==null)&&// Make sure the key is a string\ntypeof maybeKey==='string'&&(// Make sure the descriptor is the right shape\ntypeof maybeDesc==='object'&&maybeDesc!==null&&'enumerable'in maybeDesc&&'configurable'in maybeDesc||// TS compatibility\nmaybeDesc===undefined));}function normalizeModelName(type){{const result=(0,_warp_drive_utilities_string__WEBPACK_IMPORTED_MODULE_10__.dasherize)(type);(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`The resource type '${type}' is not normalized. Update your application code to use '${result}' instead of '${type}'.`,result===type,{id:'ember-data:deprecate-non-strict-types',until:'6.0',for:'ember-data',since:{available:'4.13',enabled:'5.3'}});return result;}// removed by dead control flow\n}function rollbackAttributes(){const{currentState}=this;const{isNew}=currentState;this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__.RecordStore]._join(()=>{(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.peekCache)(this).rollbackAttrs((0,_warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this));this.errors.clear();currentState.cleanErrorRequests();if(isNew){this.unloadRecord();}});}function unloadRecord(){if(this.currentState.isNew&&(this.isDestroyed||this.isDestroying)){return;}this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__.RecordStore].unloadRecord(this);}function belongsTo(prop){return (0,_errors_BX5wowuz_js__WEBPACK_IMPORTED_MODULE_6__.l)(this).referenceFor('belongsTo',prop);}function hasMany(prop){return (0,_errors_BX5wowuz_js__WEBPACK_IMPORTED_MODULE_6__.l)(this).referenceFor('hasMany',prop);}function reload(options={}){options.isReloading=true;options.reload=true;const identifier=(0,_warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this);(test=>{if(!test){throw new Error(`You cannot reload a record without an ID`);}})(identifier.id);this.isReloading=true;const promise=this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__.RecordStore].request({op:'findRecord',data:{options,record:identifier},cacheOptions:{[Symbol.for('wd:skip-cache')]:true}}).then(()=>this).finally(()=>{this.isReloading=false;});return promise;}function changedAttributes(){return (0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.peekCache)(this).changedAttrs((0,_warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this));}function serialize(options){(0,_private_CKrP0ogQ_js__WEBPACK_IMPORTED_MODULE_7__.u)(this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__.RecordStore]);return this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__.RecordStore].serializeRecord(this,options);}function deleteRecord(){// ensure we've populated currentState prior to deleting a new record\nif(this.currentState){this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__.RecordStore].deleteRecord(this);}}function save(options){let promise;if(this.currentState.isNew&&this.currentState.isDeleted){promise=Promise.resolve(this);}else{this.errors.clear();promise=this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__.RecordStore].saveRecord(this,options);}return promise;}function destroyRecord(options){const{isNew}=this.currentState;this.deleteRecord();if(isNew){return Promise.resolve(this);}return this.save(options).then(_=>{this.unloadRecord();return this;});}function createSnapshot(){const store=this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__.RecordStore];if(!store._fetchManager){store._fetchManager=new _private_CKrP0ogQ_js__WEBPACK_IMPORTED_MODULE_7__.F(store);}// @ts-expect-error Typescript isn't able to curry narrowed args that are divorced from each other.\nreturn store._fetchManager.createSnapshot((0,_warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this));}function notifyChanges(identifier,value,key,record,store){switch(value){case'added':case'attributes':if(key){notifyAttribute(store,identifier,key,record);}else{record.eachAttribute(name=>{notifyAttribute(store,identifier,name,record);});}break;case'relationships':if(key){const meta=record.constructor.relationshipsByName.get(key);(test=>{if(!test){throw new Error(`Expected to find a relationship for ${key} on ${identifier.type}`);}})(meta);notifyRelationship(identifier,key,record,meta);}else{record.eachRelationship((name,meta)=>{notifyRelationship(identifier,name,record,meta);});}break;case'identity':(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.notifyInternalSignal)((0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.peekInternalSignal)((0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.withSignalStore)(record),'id'));break;}}function notifyRelationship(identifier,key,record,meta){if(meta.kind==='belongsTo'){record.notifyPropertyChange(key);}else if(meta.kind==='hasMany'){const support=_errors_BX5wowuz_js__WEBPACK_IMPORTED_MODULE_6__.L.get(identifier);const manyArray=support&&support._manyArrayCache[key];const hasPromise=support&&support._relationshipPromisesCache[key];if(manyArray&&hasPromise){// do nothing, we will notify the ManyArray directly\n// once the fetch has completed.\nreturn;}if(manyArray){(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.notifyInternalSignal)(manyArray[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.ARRAY_SIGNAL]);//We need to notifyPropertyChange in the adding case because we need to make sure\n//we fetch the newly added record in case it is unloaded\n//TODO(Igor): Consider whether we could do this only if the record state is unloaded\n(test=>{if(!test){throw new Error(`Expected options to exist on relationship meta`);}})(meta.options);(test=>{if(!test){throw new Error(`Expected async to exist on relationship meta options`);}})('async'in meta.options);if(meta.options.async){record.notifyPropertyChange(key);}}}}function notifyAttribute(store,identifier,key,record){const currentValue=(0,_ember_object_internals__WEBPACK_IMPORTED_MODULE_8__.cacheFor)(record,key);const cache=store.cache;if(currentValue!==cache.getAttr(identifier,key)){record.notifyPropertyChange(key);}}const SOURCE_POINTER_REGEXP=/^\\/?data\\/(attributes|relationships)\\/(.*)/;const SOURCE_POINTER_PRIMARY_REGEXP=/^\\/?data/;const PRIMARY_ATTRIBUTE_KEY='base';function isInvalidError(error){return!!error&&error instanceof Error&&'isAdapterError'in error&&error.isAdapterError===true&&'code'in error&&error.code==='InvalidError';}/**\nHistorically EmberData managed a state machine\nfor each record, the localState for which\nwas reflected onto Model.\n\nThis implements the flags and stateName for backwards compat\nwith the state tree that used to be possible (listed below).\n\nstateName and dirtyType are candidates for deprecation.\n\nroot\n  empty\n    deleted    // hidden from stateName\n    preloaded  // hidden from stateName\n\n  loading\n     empty     // hidden from stateName\n     preloaded // hidden from stateName\n\n  loaded\n    saved\n    updated\n      uncommitted\n      invalid\n      inFlight\n    created\n      uncommitted\n      invalid\n      inFlight\n\n  deleted\n    saved\n      new      // hidden from stateName\n    uncommitted\n    invalid\n    inFlight\n\n  @internal\n*/class RecordState{constructor(record){const store=(0,_warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.storeFor)(record);const identity=(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor)(record);this.identifier=identity;this.record=record;this.cache=store.cache;this.pendingCount=0;this.fulfilledCount=0;this.rejectedCount=0;this._errorRequests=[];this._lastError=null;const requests=store.getRequestStateService();const notifications=store.notifications;const handleRequest=req=>{if(req.type==='mutation'){switch(req.state){case'pending':this.isSaving=true;break;case'rejected':this.isSaving=false;this._lastError=req;if(!(req.response&&isInvalidError(req.response.data))){this._errorRequests.push(req);}notifyErrorsStateChanged(this);break;case'fulfilled':this._errorRequests=[];this._lastError=null;this.isSaving=false;this.notify('isDirty');notifyErrorsStateChanged(this);break;}}else{switch(req.state){case'pending':this.pendingCount++;this.notify('isLoading');break;case'rejected':this.pendingCount--;this._lastError=req;if(!(req.response&&isInvalidError(req.response.data))){this._errorRequests.push(req);}this.notify('isLoading');notifyErrorsStateChanged(this);break;case'fulfilled':this.pendingCount--;this.fulfilledCount++;this.notify('isLoading');this.notify('isDirty');notifyErrorsStateChanged(this);this._errorRequests=[];this._lastError=null;break;}}};requests.subscribeForRecord(identity,handleRequest);// we instantiate lazily\n// so we grab anything we don't have yet\nconst lastRequest=requests.getLastRequestForRecord(identity);if(lastRequest){handleRequest(lastRequest);}this.handler=notifications.subscribe(identity,(identifier,type,key)=>{switch(type){case'state':this.notify('isSaved');this.notify('isNew');this.notify('isDeleted');this.notify('isDirty');break;case'attributes':this.notify('isEmpty');this.notify('isDirty');break;case'errors':this.updateInvalidErrors(this.record.errors);this.notify('isValid');break;}});}/** @internal */destroy(){(0,_warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.storeFor)(this.record).notifications.unsubscribe(this.handler);}/** @internal */notify(key){const signals=(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.withSignalStore)(this);const signal=(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.peekInternalSignal)(signals,key);if(signal){(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.notifyInternalSignal)(signal);}}/** @internal */updateInvalidErrors(errors){(test=>{if(!test){throw new Error(`Expected the Cache instance for ${this.identifier.lid}  to implement getErrors(identifier)`);}})(typeof this.cache.getErrors==='function');const jsonApiErrors=this.cache.getErrors(this.identifier);errors.clear();for(let i=0;i<jsonApiErrors.length;i++){const error=jsonApiErrors[i];if(error.source&&error.source.pointer){const keyMatch=error.source.pointer.match(SOURCE_POINTER_REGEXP);let key;if(keyMatch){key=keyMatch[2];}else if(error.source.pointer.search(SOURCE_POINTER_PRIMARY_REGEXP)!==-1){key=PRIMARY_ATTRIBUTE_KEY;}if(key){const errMsg=error.detail||error.title;(test=>{if(!test){throw new Error(`Expected field error to have a detail or title to use as the message`);}})(errMsg);errors.add(key,errMsg);}}}}/** @internal */cleanErrorRequests(){this.notify('isValid');this.notify('isError');this.notify('adapterError');this._errorRequests=[];this._lastError=null;}get isLoading(){return!this.isLoaded&&this.pendingCount>0&&this.fulfilledCount===0;}get isLoaded(){if(this.isNew){return true;}return this.fulfilledCount>0||!this.isEmpty;}get isSaved(){const rd=this.cache;if(this.isDeleted){(test=>{if(!test){throw new Error(`Expected Cache to implement isDeletionCommitted()`);}})(typeof rd.isDeletionCommitted==='function');return rd.isDeletionCommitted(this.identifier);}if(this.isNew||this.isEmpty||!this.isValid||this.isDirty||this.isLoading){return false;}return true;}get isEmpty(){const rd=this.cache;// TODO this is not actually an RFC'd concept. Determine the\n// correct heuristic to replace this with.\n(test=>{if(!test){throw new Error(`Expected Cache to implement isEmpty()`);}})(typeof rd.isEmpty==='function');return!this.isNew&&rd.isEmpty(this.identifier);}get isNew(){const rd=this.cache;(test=>{if(!test){throw new Error(`Expected Cache to implement isNew()`);}})(typeof rd.isNew==='function');return rd.isNew(this.identifier);}get isDeleted(){const rd=this.cache;(test=>{if(!test){throw new Error(`Expected Cache to implement isDeleted()`);}})(typeof rd.isDeleted==='function');return rd.isDeleted(this.identifier);}get isValid(){return this.record.errors.length===0;}get isDirty(){const rd=this.cache;if(this.isEmpty||rd.isDeletionCommitted(this.identifier)||this.isDeleted&&this.isNew){return false;}return this.isDeleted||this.isNew||rd.hasChangedAttrs(this.identifier);}get isError(){const errorReq=this._errorRequests[this._errorRequests.length-1];if(!errorReq){return false;}else{return true;}}get adapterError(){const request=this._lastError;if(!request){return null;}return request.state==='rejected'&&request.response.data;}get isPreloaded(){return!this.isEmpty&&this.isLoading;}get stateName(){// we might be empty while loading so check this first\nif(this.isLoading){return'root.loading';// got nothing yet or were unloaded\n}else if(this.isEmpty){return'root.empty';// deleted substates\n}else if(this.isDeleted){if(this.isSaving){return'root.deleted.inFlight';}else if(this.isSaved){// TODO ensure isSaved isn't true from previous requests\nreturn'root.deleted.saved';}else if(!this.isValid){return'root.deleted.invalid';}else{return'root.deleted.uncommitted';}// loaded.created substates\n}else if(this.isNew){if(this.isSaving){return'root.loaded.created.inFlight';}else if(!this.isValid){return'root.loaded.created.invalid';}return'root.loaded.created.uncommitted';// loaded.updated substates\n}else if(this.isSaving){return'root.loaded.updated.inFlight';}else if(!this.isValid){return'root.loaded.updated.invalid';}else if(this.isDirty){return'root.loaded.updated.uncommitted';// if nothing remains, we are loaded saved!\n}else{return'root.loaded.saved';}}get dirtyType(){// we might be empty while loading so check this first\nif(this.isLoading||this.isEmpty){return'';// deleted substates\n}else if(this.isDirty&&this.isDeleted){return'deleted';// loaded.created substates\n}else if(this.isNew){return'created';// loaded.updated substates\n}else if(this.isSaving||!this.isValid||this.isDirty){return'updated';// if nothing remains, we are loaded saved!\n}else{return'';}}}_RecordState=RecordState;(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_RecordState.prototype,\"isLoading\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.gate]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_RecordState.prototype,\"isLoaded\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.gate]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_RecordState.prototype,\"isSaved\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.gate]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_RecordState.prototype,\"isEmpty\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.gate]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_RecordState.prototype,\"isNew\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.gate]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_RecordState.prototype,\"isDeleted\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.gate]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_RecordState.prototype,\"isValid\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.gate]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_RecordState.prototype,\"isDirty\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.gate]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_RecordState.prototype,\"isError\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.gate]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_RecordState.prototype,\"adapterError\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.gate]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_RecordState.prototype,\"isPreloaded\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_RecordState.prototype,\"stateName\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_RecordState.prototype,\"dirtyType\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.defineSignal)(RecordState.prototype,'isSaving',false);function notifyErrorsStateChanged(state){state.notify('isValid');state.notify('isError');state.notify('adapterError');}/*\n * This decorator allows us to lazily compute\n * an expensive getter on first-access and thereafter\n * never recompute it.\n */function computeOnce(target,propertyName,desc){const cache=new WeakMap();// eslint-disable-next-line @typescript-eslint/unbound-method\nconst getter=desc.get;desc.get=function(){let meta=cache.get(this);if(!meta){meta={hasComputed:false,value:undefined};cache.set(this,meta);}if(!meta.hasComputed){meta.value=getter.call(this);meta.hasComputed=true;}return meta.value;};return desc;}/**\n * @noInheritDoc\n *//**\n * Base class from which Models can be defined.\n *\n * ::: code-group\n *\n * ```js [app/models/user.js]\n * import { Model, attr, belongsTo, hasMany } from '@warp-drive/legacy/model';\n *\n * export default class User extends Model {\n *   @attr name;\n *   @attr('number') age;\n *   @hasMany('post', { async: true, inverse: null }) posts;\n *   @belongsTo('group', { async: false, inverse: 'users' }) group;\n * }\n * ```\n *\n * ```ts [app/models/user.ts]\n * import { Model, attr, belongsTo, hasMany, type AsyncHasMany } from '@warp-drive/legacy/model';\n * import type { NumberTransform } from '@ember-data/serializer/transform';\n * import type Group from './group';\n * import type Post from './post';\n *\n * export default class User extends Model {\n *   @attr declare name: string;\n *\n *   @attr<NumberTransform>('number')\n *   declare age: number;\n *\n *   @hasMany('post', { async: true, inverse: null })\n *   declare posts: AsyncHasMany<Post>;\n *\n *   @belongsTo('group', { async: false, inverse: 'users' })\n *   declare group: Group | null;\n * }\n * ```\n *\n * :::\n *\n * Models both define the schema for a resource type and provide\n * the class to use as the reactive object for data of resource\n * of that type.\n *\n * @noInheritDoc\n */class Model extends (_ember_object__WEBPACK_IMPORTED_MODULE_2___default()){/** @internal */init(options){{if(!options?._secretInit&&!options?._createProps){throw new Error('You should not call `create` on a model. Instead, call `store.createRecord` with the attributes you would like to set.');}}const createProps=options._createProps;const _secretInit=options._secretInit;options._createProps=null;options._secretInit=null;const store=this.store=_secretInit.store;super.init(options);this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__.RecordStore]=store;const identity=_secretInit.identifier;_secretInit.cb(this,_secretInit.cache,identity,_secretInit.store);this.___recordState=new RecordState(this);this.setProperties(createProps);const notifications=store.notifications;this.___private_notifications=notifications.subscribe(identity,(identifier,type,field)=>{notifyChanges(identifier,type,field,this,store);});}/** @internal */// @ts-expect-error destroy should not return a value, but ember's types force it to\ndestroy(){const identifier=(0,_warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this);this.___recordState?.destroy();const store=(0,_warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.storeFor)(this);store.notifications.unsubscribe(this.___private_notifications);_errors_BX5wowuz_js__WEBPACK_IMPORTED_MODULE_6__.L.get(this)?.destroy();_errors_BX5wowuz_js__WEBPACK_IMPORTED_MODULE_6__.L.delete(this);_errors_BX5wowuz_js__WEBPACK_IMPORTED_MODULE_6__.L.delete(identifier);super.destroy();}/**\n    If this property is `true` the record is in the `empty`\n    state. Empty is the first state all records enter after they have\n    been created. Most records created by the store will quickly\n    transition to the `loading` state if data needs to be fetched from\n    the server or the `created` state if the record is created on the\n    client. A record can also enter the empty state if the adapter is\n    unable to locate the record.\n     @property isEmpty\n    @public\n    @readonly\n  */get isEmpty(){return this.currentState.isEmpty;}/**\n    If this property is `true` the record is in the `loading` state. A\n    record enters this state when the store asks the adapter for its\n    data. It remains in this state until the adapter provides the\n    requested data.\n     @property isLoading\n    @public\n    @readonly\n  */get isLoading(){return this.currentState.isLoading;}/**\n    If this property is `true` the record is in the `loaded` state. A\n    record enters this state when its data is populated. Most of a\n    record's lifecycle is spent inside substates of the `loaded`\n    state.\n     Example\n     ```javascript\n    let record = store.createRecord('model');\n    record.isLoaded; // true\n     const { content: { data: model } } = await store.request(findRecord({ type: 'model', id: '1' }));\n    model.isLoaded;\n    ```\n     @property isLoaded\n    @public\n    @readonly\n  */get isLoaded(){return this.currentState.isLoaded;}/**\n    If this property is `true` the record is in the `dirty` state. The\n    record has local changes that have not yet been saved by the\n    adapter. This includes records that have been created (but not yet\n    saved) or deleted.\n     Example\n     ```javascript\n    let record = store.createRecord('model');\n    record.hasDirtyAttributes; // true\n     const { content: { data: model } } = await store.request(findRecord({ type: 'model', id: '1' }));\n     model.hasDirtyAttributes; // false\n    model.foo = 'some value';\n    model.hasDirtyAttributes; // true\n    ```\n     @since 1.13.0\n    @property hasDirtyAttributes\n    @public\n    @readonly\n  */get hasDirtyAttributes(){return this.currentState.isDirty;}/**\n    If this property is `true` the record is in the `saving` state. A\n    record enters the saving state when `save` is called, but the\n    adapter has not yet acknowledged that the changes have been\n    persisted to the backend.\n     Example\n     ```javascript\n    let record = store.createRecord('model');\n    record.isSaving; // false\n    let promise = record.save();\n    record.isSaving; // true\n    promise.then(function() {\n      record.isSaving; // false\n    });\n    ```\n     @property isSaving\n    @public\n    @readonly\n  */get isSaving(){return this.currentState.isSaving;}/**\n    If this property is `true` the record is in the `deleted` state\n    and has been marked for deletion. When `isDeleted` is true and\n    `hasDirtyAttributes` is true, the record is deleted locally but the deletion\n    was not yet persisted. When `isSaving` is true, the change is\n    in-flight. When both `hasDirtyAttributes` and `isSaving` are false, the\n    change has persisted.\n     Example\n     ```javascript\n    let record = store.createRecord('model');\n    record.isDeleted;    // false\n    record.deleteRecord();\n     // Locally deleted\n    record.isDeleted;           // true\n    record.hasDirtyAttributes;  // true\n    record.isSaving;            // false\n     // Persisting the deletion\n    let promise = record.save();\n    record.isDeleted;    // true\n    record.isSaving;     // true\n     // Deletion Persisted\n    promise.then(function() {\n      record.isDeleted;          // true\n      record.isSaving;           // false\n      record.hasDirtyAttributes; // false\n    });\n    ```\n     @property isDeleted\n    @public\n    @readonly\n  */get isDeleted(){return this.currentState.isDeleted;}/**\n    If this property is `true` the record is in the `new` state. A\n    record will be in the `new` state when it has been created on the\n    client and the adapter has not yet report that it was successfully\n    saved.\n     Example\n     ```javascript\n    let record = store.createRecord('model');\n    record.isNew; // true\n     record.save().then(function(model) {\n      model.isNew; // false\n    });\n    ```\n     @property isNew\n    @public\n    @readonly\n  */get isNew(){return this.currentState.isNew;}/**\n    If this property is `true` the record is in the `valid` state.\n     A record will be in the `valid` state when the adapter did not report any\n    server-side validation failures.\n     @property isValid\n    @public\n    @readonly\n  */get isValid(){return this.currentState.isValid;}/**\n    If the record is in the dirty state this property will report what\n    kind of change has caused it to move into the dirty\n    state. Possible values are:\n     - `created` The record has been created by the client and not yet saved to the adapter.\n    - `updated` The record has been updated by the client and not yet saved to the adapter.\n    - `deleted` The record has been deleted by the client and not yet saved to the adapter.\n     Example\n     ```javascript\n    let record = store.createRecord('model');\n    record.dirtyType; // 'created'\n    ```\n     @property dirtyType\n    @public\n    @readonly\n  */get dirtyType(){return this.currentState.dirtyType;}/**\n    If `true` the adapter reported that it was unable to save local\n    changes to the backend for any reason other than a server-side\n    validation error.\n     Example\n     ```javascript\n    record.isError; // false\n    record.set('foo', 'valid value');\n    record.save().then(null, function() {\n      record.isError; // true\n    });\n    ```\n     @property isError\n    @public\n    @readonly\n  */get isError(){return this.currentState.isError;}set isError(v){{throw new Error(`isError is not directly settable`);}}/**\n    If `true` the store is attempting to reload the record from the adapter.\n     Example\n     ```javascript\n    record.isReloading; // false\n    record.reload();\n    record.isReloading; // true\n    ```\n     @property isReloading\n    @public\n    @readonly\n  *//**\n    All ember models have an id property. This is an identifier\n    managed by an external source. These are always coerced to be\n    strings before being used internally. Note when declaring the\n    attributes for a model it is an error to declare an id\n    attribute.\n     ```javascript\n    let record = store.createRecord('model');\n    record.id; // null\n     const { content: { data: model } } = await store.request(findRecord({ type: 'model', id: '1' }));\n    model.id; // '1'\n    ```\n     @property id\n    @public\n  */get id(){// this guard exists, because some dev-only deprecation code\n// (addListener via validatePropertyInjections) invokes toString before the\n// object is real.\n{try{return (0,_warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this).id;}catch{return null;}}// removed by dead control flow\n}set id(id){const normalizedId=(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.coerceId)(id);const identifier=(0,_warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this);const didChange=normalizedId!==identifier.id;(test=>{if(!test){throw new Error(`Cannot set ${identifier.type} record's id to ${id}, because id is already ${identifier.id}`);}})(!didChange||identifier.id===null);if(normalizedId!==null&&didChange){this.store._instanceCache.setRecordId(identifier,normalizedId);this.store.notifications.notify(identifier,'identity');}}toString(){return`<model::${this.constructor.modelName}:${this.id}>`;}/**\n    @property currentState\n    @private\n  */// TODO we can probably make this a computeOnce\n// we likely do not need to notify the currentState root anymore\nget currentState(){// descriptors are called with the wrong `this` context during mergeMixins\n// when using legacy/classic ember classes. Basically: lazy in prod and eager in dev.\n// so we do this to try to steer folks to the nicer \"dont user currentState\"\n// error.\nreturn this.___recordState;}set currentState(_v){throw new Error('cannot set currentState');}/**\n    The store service instance which created this record instance\n    @property store\n    @public\n   *//**\n    When the record is in the `invalid` state this object will contain\n    any errors returned by the adapter. When present the errors hash\n    contains keys corresponding to the invalid property names\n    and values which are arrays of Javascript objects with two keys:\n     - `message` A string containing the error message from the backend\n    - `attribute` The name of the property associated with this error message\n     ```javascript\n    record.errors.length; // 0\n    record.set('foo', 'invalid value');\n    record.save().catch(function() {\n      record.errors.foo;\n      // [{message: 'foo should be a number.', attribute: 'foo'}]\n    });\n    ```\n     The `errors` property is useful for displaying error messages to\n    the user.\n     ```handlebars\n    <label>Username: <Input @value={{@model.username}} /> </label>\n    {{#each @model.errors.username as |error|}}\n      <div class=\"error\">\n        {{error.message}}\n      </div>\n    {{/each}}\n    <label>Email: <Input @value={{@model.email}} /> </label>\n    {{#each @model.errors.email as |error|}}\n      <div class=\"error\">\n        {{error.message}}\n      </div>\n    {{/each}}\n    ```\n      You can also access the special `messages` property on the error\n    object to get an array of all the error strings.\n     ```handlebars\n    {{#each @model.errors.messages as |message|}}\n      <div class=\"error\">\n        {{message}}\n      </div>\n    {{/each}}\n    ```\n     @property errors\n    @public\n  */get errors(){const errors=_errors_BX5wowuz_js__WEBPACK_IMPORTED_MODULE_6__.E.create({__record:this});this.currentState.updateInvalidErrors(errors);return errors;}/**\n    This property holds the `AdapterError` object with which\n    last adapter operation was rejected.\n     @property adapterError\n    @public\n  */get adapterError(){return this.currentState.adapterError;}set adapterError(v){throw new Error(`adapterError is not directly settable`);}/*\n    We hook the default implementation to ensure\n    our tagged properties are properly notified\n    as well. We still super for everything because\n    sync observers require a direct call occuring\n    to trigger their flush. We wouldn't need to\n    super in 4.0+ where sync observers are removed.\n   */// @ts-expect-error no return is necessary, but Ember's types are forcing it\nnotifyPropertyChange(prop){const signals=(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.withSignalStore)(this);(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.entangleSignal)(signals,this,prop,undefined);super.notifyPropertyChange(prop);}/** @internal */attr(){(test=>{{throw new Error('The `attr` method is not available on Model, a Snapshot was probably expected. Are you passing a Model instead of a Snapshot to your serializer?');}})();}/**\n   Given a callback, iterates over each of the relationships in the model,\n   invoking the callback with the name of each relationship and its relationship\n   descriptor.\n     The callback method you provide should have the following signature (all\n   parameters are optional):\n    ```javascript\n   function(name, descriptor);\n   ```\n    - `name` the name of the current property in the iteration\n   - `descriptor` the meta object that describes this relationship\n    The relationship descriptor argument is an object with the following properties.\n    - **name** <span class=\"type\">String</span> the name of this relationship on the Model\n   - **kind** <span class=\"type\">String</span> \"hasMany\" or \"belongsTo\"\n   - **options** <span class=\"type\">Object</span> the original options hash passed when the relationship was declared\n   - **parentType** <span class=\"type\">Model</span> the type of the Model that owns this relationship\n   - **type** <span class=\"type\">String</span> the type name of the related Model\n    Note that in addition to a callback, you can also pass an optional target\n   object that will be set as `this` on the context.\n    Example\n    ```js [app/serializers/application.js]\n   import JSONSerializer from '@ember-data/serializer/json';\n    export default class ApplicationSerializer extends JSONSerializer {\n      serialize(record, options) {\n      let json = {};\n       record.eachRelationship(function(name, descriptor) {\n        if (descriptor.kind === 'hasMany') {\n          let serializedHasManyName = name.toUpperCase() + '_IDS';\n          json[serializedHasManyName] = record.get(name).map(r => r.id);\n        }\n      });\n       return json;\n    }\n  }\n   ```\n    @public\n   @param {Function} callback the callback to invoke\n   @param {any} binding the value to which the callback's `this` should be bound\n   */eachRelationship(callback,binding){this.constructor.eachRelationship(callback,binding);}relationshipFor(name){return this.constructor.relationshipsByName.get(name);}inverseFor(name){return this.constructor.inverseFor(name,(0,_warp_drive_core__WEBPACK_IMPORTED_MODULE_3__.storeFor)(this));}eachAttribute(callback,binding){this.constructor.eachAttribute(callback,binding);}/**\n   * @internal\n   *//*\n   These class methods below provide relationship\n   introspection abilities about relationships.\n    A note about the computed properties contained here:\n    **These properties are effectively sealed once called for the first time.**\n   To avoid repeatedly doing expensive iteration over a model's fields, these\n   values are computed once and then cached for the remainder of the runtime of\n   your application.\n    If your application needs to modify a class after its initial definition\n   (for example, using `reopen()` to add additional attributes), make sure you\n   do it before using your model with the store, which uses these properties\n   extensively.\n   *//**\n   For a given relationship name, returns the model type of the relationship.\n    For example, if you define a model like this:\n    ```js [app/models/post.js]\n   import { Model, hasMany } from '@warp-drive/legacy/model';\n    export default class PostModel extends Model {\n     @hasMany('comment') comments;\n   }\n   ```\n    Calling `store.modelFor('post').typeForRelationship('comments', store)` will return `Comment`.\n     @public\n   @param {String} name the name of the relationship\n   @param {store} store an instance of Store\n   @return {Model} the type of the relationship, or undefined\n   */static typeForRelationship(name,store){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const relationship=this.relationshipsByName.get(name);return relationship&&store.modelFor(relationship.type);}static get inverseMap(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);return Object.create(null);}/**\n   Find the relationship which is the inverse of the one asked for.\n    For example, if you define models like this:\n    ```js [app/models/post.js]\n   import { Model, hasMany } from '@warp-drive/legacy/model';\n    export default class PostModel extends Model {\n      @hasMany('message') comments;\n    }\n   ```\n    ```js [app/models/message.js]\n   import { Model, belongsTo } from '@warp-drive/legacy/model';\n    export default class MessageModel extends Model {\n      @belongsTo('post') owner;\n    }\n   ```\n    ``` js\n   store.modelFor('post').inverseFor('comments', store) // { type: 'message', name: 'owner', kind: 'belongsTo' }\n   store.modelFor('message').inverseFor('owner', store) // { type: 'post', name: 'comments', kind: 'hasMany' }\n   ```\n     @public\n   @param {String} name the name of the relationship\n   @param {Store} store\n   @return {Object} the inverse relationship, or null\n   */static inverseFor(name,store){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const inverseMap=this.inverseMap;if(inverseMap[name]){return inverseMap[name];}else{const inverse=this._findInverseFor(name,store);inverseMap[name]=inverse;return inverse;}}//Calculate the inverse, ignoring the cache\nstatic _findInverseFor(name,store){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const relationship=this.relationshipsByName.get(name);(test=>{if(!test){throw new Error(`No relationship named '${name}' on '${this.modelName}' exists.`);}})(relationship);if(!relationship){return null;}const{options}=relationship;(test=>{if(!test){throw new Error(`Expected the relationship ${name} on ${this.modelName} to define an inverse.`);}})(options.inverse===null||typeof options.inverse==='string'&&options.inverse.length>0);if(options.inverse===null){return null;}const schemaExists=store.schema.hasResource(relationship);(test=>{if(!test){throw new Error(`No associated schema found for '${relationship.type}' while calculating the inverse of ${name} on ${this.modelName}`);}})(schemaExists);if(!schemaExists){return null;}const inverseField=store.schema.fields(relationship).get(options.inverse);(test=>{if(!test){throw new Error(`No inverse relationship found for '${name}' on '${this.modelName}'`);}})(inverseField&&(inverseField.kind==='belongsTo'||inverseField.kind==='hasMany'));return inverseField||null;}/**\n   The model's relationships as a map, keyed on the type of the\n   relationship. The value of each entry is an array containing a descriptor\n   for each relationship with that type, describing the name of the relationship\n   as well as the type.\n    For example, given the following model definition:\n    ```js [app/models/blog.js]\n   import { Model, belongsTo, hasMany } from '@warp-drive/legacy/model';\n    export default class BlogModel extends Model {\n      @hasMany('user') users;\n      @belongsTo('user') owner;\n      @hasMany('post') posts;\n    }\n   ```\n    This computed property would return a map describing these\n   relationships, like this:\n    ```javascript\n   import Blog from 'app/models/blog';\n   import User from 'app/models/user';\n   import Post from 'app/models/post';\n    let relationships = Blog.relationships;\n   relationships.user;\n   //=> [ { name: 'users', kind: 'hasMany' },\n   //     { name: 'owner', kind: 'belongsTo' } ]\n   relationships.post;\n   //=> [ { name: 'posts', kind: 'hasMany' } ]\n   ```\n    @property relationships\n    @public\n   @readonly\n   */static get relationships(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const map=new Map();const relationshipsByName=this.relationshipsByName;// Loop through each computed property on the class\nrelationshipsByName.forEach(desc=>{const{type}=desc;if(!map.has(type)){map.set(type,[]);}map.get(type).push(desc);});return map;}/**\n   A hash containing lists of the model's relationships, grouped\n   by the relationship kind. For example, given a model with this\n   definition:\n    ```js [app/models/blog.js]\n   import { Model, belongsTo, hasMany } from '@warp-drive/legacy/model';\n    export default class BlogModel extends Model {\n      @hasMany('user') users;\n      @belongsTo('user') owner;\n       @hasMany('post') posts;\n    }\n   ```\n    This property would contain the following:\n    ```javascript\n   import Blog from 'app/models/blog';\n    let relationshipNames = Blog.relationshipNames;\n   relationshipNames.hasMany;\n   //=> ['users', 'posts']\n   relationshipNames.belongsTo;\n   //=> ['owner']\n   ```\n    @property relationshipNames\n    @public\n   @readonly\n   */static get relationshipNames(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const names={hasMany:[],belongsTo:[]};this.eachComputedProperty((name,meta)=>{if(isRelationshipSchema(meta)){names[meta.kind].push(name);}});return names;}/**\n   An array of types directly related to a model. Each type will be\n   included once, regardless of the number of relationships it has with\n   the model.\n    For example, given a model with this definition:\n    ```js [app/models/blog.js]\n   import { Model, belongsTo, hasMany } from '@warp-drive/legacy/model';\n    export default class BlogModel extends Model {\n      @hasMany('user') users;\n      @belongsTo('user') owner;\n       @hasMany('post') posts;\n    }\n   ```\n    This property would contain the following:\n    ```javascript\n   import Blog from 'app/models/blog';\n    let relatedTypes = Blog.relatedTypes');\n   //=> ['user', 'post']\n   ```\n    @property relatedTypes\n   @public\n   @readonly\n   */static get relatedTypes(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const types=[];const rels=this.relationshipsObject;const relationships=Object.keys(rels);// create an array of the unique types involved\n// in relationships\nfor(let i=0;i<relationships.length;i++){const name=relationships[i];const meta=rels[name];const modelName=meta.type;if(!types.includes(modelName)){types.push(modelName);}}return types;}/**\n   A map whose keys are the relationships of a model and whose values are\n   relationship descriptors.\n    For example, given a model with this\n   definition:\n    ```js [app/models/blog.js]\n   import { Model, belongsTo, hasMany } from '@warp-drive/legacy/model';\n    export default class BlogModel extends Model {\n      @hasMany('user') users;\n      @belongsTo('user') owner;\n       @hasMany('post') posts;\n    }\n   ```\n    This property would contain the following:\n    ```javascript\n   import Blog from 'app/models/blog';\n    let relationshipsByName = Blog.relationshipsByName;\n   relationshipsByName.users;\n   //=> { name: 'users', kind: 'hasMany', type: 'user', options: Object }\n   relationshipsByName.owner;\n   //=> { name: 'owner', kind: 'belongsTo', type: 'user', options: Object }\n   ```\n    @property relationshipsByName\n    @public\n   @readonly\n   */static get relationshipsByName(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const map=new Map();const rels=this.relationshipsObject;const relationships=Object.keys(rels);for(let i=0;i<relationships.length;i++){const name=relationships[i];const value=rels[name];map.set(value.name,value);}return map;}static get relationshipsObject(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const relationships=Object.create(null);const modelName=this.modelName;this.eachComputedProperty((name,meta)=>{if(!isRelationshipSchema(meta)){return;}// TODO deprecate key being here\nmeta.key=name;meta.name=name;relationships[name]=meta;(test=>{if(!test){throw new Error(`Expected options in meta`);}})(meta.options&&typeof meta.options==='object');(test=>{if(!test){throw new Error(`You should not specify both options.as and options.inverse as null on ${modelName}.${meta.name}, as if there is no inverse field there is no abstract type to conform to. You may have intended for this relationship to be polymorphic, or you may have mistakenly set inverse to null.`);}})(!(meta.options.inverse===null&&meta.options.as?.length));});return relationships;}/**\n   A map whose keys are the fields of the model and whose values are strings\n   describing the kind of the field. A model's fields are the union of all of its\n   attributes and relationships.\n    For example:\n    ```js [app/models/blog.js]\n   import { Model, attr, belongsTo, hasMany } from '@warp-drive/legacy/model';\n    export default class BlogModel extends Model {\n      @hasMany('user') users;\n      @belongsTo('user') owner;\n       @hasMany('post') posts;\n       @attr('string') title;\n    }\n   ```\n    ```js\n   import Blog from 'app/models/blog'\n    let fields = Blog.fields;\n   fields.forEach(function(kind, field) {\n      // do thing\n    });\n    // prints:\n   // users, hasMany\n   // owner, belongsTo\n   // posts, hasMany\n   // title, attribute\n   ```\n    @property fields\n    @public\n   @readonly\n   */static get fields(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const map=new Map();this.eachComputedProperty((name,meta)=>{if(isRelationshipSchema(meta)){map.set(name,meta.kind);}else if(isAttributeSchema(meta)){map.set(name,'attribute');}});return map;}/**\n   Given a callback, iterates over each of the relationships in the model,\n   invoking the callback with the name of each relationship and its relationship\n   descriptor.\n     @public\n   @param {Function} callback the callback to invoke\n   @param {any} binding the value to which the callback's `this` should be bound\n   */static eachRelationship(callback,binding){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);this.relationshipsByName.forEach((relationship,name)=>{callback.call(binding,name,relationship);});}/**\n   Given a callback, iterates over each of the types related to a model,\n   invoking the callback with the related type's class. Each type will be\n   returned just once, regardless of how many different relationships it has\n   with a model.\n     @public\n   @param {Function} callback the callback to invoke\n   @param {any} binding the value to which the callback's `this` should be bound\n   */static eachRelatedType(callback,binding){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const relationshipTypes=this.relatedTypes;for(let i=0;i<relationshipTypes.length;i++){const type=relationshipTypes[i];callback.call(binding,type);}}/**\n   *\n   * @private\n   * @deprecated\n   */static determineRelationshipType(knownSide,store){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const knownKey=knownSide.name;const knownKind=knownSide.kind;const inverse=this.inverseFor(knownKey,store);// let key;\nif(!inverse){return knownKind==='belongsTo'?'oneToNone':'manyToNone';}// key = inverse.name;\nconst otherKind=inverse.kind;if(otherKind==='belongsTo'){return knownKind==='belongsTo'?'oneToOne':'manyToOne';}else{return knownKind==='belongsTo'?'oneToMany':'manyToMany';}}/**\n   A map whose keys are the attributes of the model (properties\n   described by attr) and whose values are the meta object for the\n   property.\n    Example\n    ```js [app/models/person.js]\n   import { Model, attr } from '@warp-drive/legacy/model';\n    export default class PersonModel extends Model {\n      @attr('string') firstName;\n      @attr('string') lastName;\n      @attr('date') birthday;\n    }\n   ```\n    ```javascript\n   import Person from 'app/models/person'\n    let attributes = Person.attributes\n    attributes.forEach(function(meta, name) {\n      // do thing\n    });\n    // prints:\n   // firstName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"firstName\"}\n   // lastName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"lastName\"}\n   // birthday {type: \"date\", kind: 'attribute', options: Object, parentType: function, name: \"birthday\"}\n   ```\n    @property attributes\n    @public\n   @readonly\n   */static get attributes(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const map=new Map();this.eachComputedProperty((name,meta)=>{if(isAttributeSchema(meta)){(test=>{if(!test){throw new Error(\"You may not set 'id' as an attribute on your model. Please remove any lines that look like: `id: attr('<type>')` from \"+this.toString());}})(name!=='id');// TODO deprecate key being here\nmeta.key=name;meta.name=name;map.set(name,meta);}});return map;}/**\n   A map whose keys are the attributes of the model (properties\n   described by attr) and whose values are type of transformation\n   applied to each attribute. This map does not include any\n   attributes that do not have an transformation type.\n    Example\n    ```js [app/models/person.js]\n   import { Model, attr } from '@warp-drive/legacy/model';\n    export default class PersonModel extends Model {\n      @attr firstName;\n      @attr('string') lastName;\n      @attr('date') birthday;\n    }\n   ```\n    ```javascript\n   import Person from 'app/models/person';\n    let transformedAttributes = Person.transformedAttributes\n    transformedAttributes.forEach(function(field, type) {\n      // do thing\n    });\n    // prints:\n   // lastName string\n   // birthday date\n   ```\n    @property transformedAttributes\n    @public\n   @readonly\n   */static get transformedAttributes(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const map=new Map();this.eachAttribute((name,meta)=>{if(meta.type){map.set(name,meta.type);}});return map;}/**\n   Iterates through the attributes of the model, calling the passed function on each\n   attribute.\n    The callback method you provide should have the following signature (all\n   parameters are optional):\n    ```javascript\n   function(name, meta);\n   ```\n    - `name` the name of the current property in the iteration\n   - `meta` the meta object for the attribute property in the iteration\n    Note that in addition to a callback, you can also pass an optional target\n   object that will be set as `this` on the context.\n    Example\n    ```javascript\n   import { Model, attr } from '@warp-drive/legacy/model';\n    class PersonModel extends Model {\n      @attr('string') firstName;\n      @attr('string') lastName;\n      @attr('date') birthday;\n    }\n    PersonModel.eachAttribute(function(name, meta) {\n      // do thing\n    });\n    // prints:\n   // firstName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"firstName\"}\n   // lastName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"lastName\"}\n   // birthday {type: \"date\", kind: 'attribute', options: Object, parentType: function, name: \"birthday\"}\n   ```\n     @public\n   @param {Function} callback The callback to execute\n   @param {Object} [binding] the value to which the callback's `this` should be bound\n   */static eachAttribute(callback,binding){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);this.attributes.forEach((meta,name)=>{callback.call(binding,name,meta);});}/**\n   Iterates through the transformedAttributes of the model, calling\n   the passed function on each attribute. Note the callback will not be\n   called for any attributes that do not have an transformation type.\n    The callback method you provide should have the following signature (all\n   parameters are optional):\n    ```javascript\n   function(name, type);\n   ```\n    - `name` the name of the current property in the iteration\n   - `type` a string containing the name of the type of transformed\n   applied to the attribute\n    Note that in addition to a callback, you can also pass an optional target\n   object that will be set as `this` on the context.\n    Example\n    ```javascript\n   import { Model, attr } from '@warp-drive/legacy/model';\n    let Person = Model.extend({\n      firstName: attr(),\n      lastName: attr('string'),\n      birthday: attr('date')\n    });\n    Person.eachTransformedAttribute(function(name, type) {\n      // do thing\n    });\n    // prints:\n   // lastName string\n   // birthday date\n   ```\n     @public\n   @param {Function} callback The callback to execute\n   @param {Object} [binding] the value to which the callback's `this` should be bound\n   */static eachTransformedAttribute(callback,binding){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);this.transformedAttributes.forEach((type,name)=>{callback.call(binding,name,type);});}/**\n   Returns the name of the model class.\n     @public\n   */static toString(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);return`model:${this.modelName}`;}}// @ts-expect-error TS doesn't know how to do `this` function overloads\n_Model=Model;(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"isEmpty\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"isLoading\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"isLoaded\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"hasDirtyAttributes\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"isSaving\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"isDeleted\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"isNew\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"isValid\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"dirtyType\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"isError\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"id\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.gate]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"currentState\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.gate]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"errors\",[computeOnce]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model.prototype,\"adapterError\",[_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.memoized]);_defineProperty(Model,\"isModel\",true);/**\n   Represents the model's class name as a string. This can be used to look up the model's class name through\n   `Store`'s modelFor method.\n    `modelName` is generated for you by EmberData. It will be a lowercased, dasherized string.\n   For example:\n    ```javascript\n   store.modelFor('post').modelName; // 'post'\n   store.modelFor('blog-post').modelName; // 'blog-post'\n   ```\n    The most common place you'll want to access `modelName` is in your serializer's `payloadKeyFromModelName` method. For example, to change payload\n   keys to underscore (instead of dasherized), you might use the following code:\n    ```javascript\n   import RESTSerializer from '@ember-data/serializer/rest';\n   import { underscore } from '<app-name>/utils/string-utils';\n    export default const PostSerializer = RESTSerializer.extend({\n     payloadKeyFromModelName(modelName) {\n       return underscore(modelName);\n     }\n   });\n   ```\n   @property modelName\n    @public\n   @readonly\n  */_defineProperty(Model,\"modelName\",null);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model,\"inverseMap\",[computeOnce]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model,\"relationships\",[computeOnce]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model,\"relationshipNames\",[computeOnce]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model,\"relatedTypes\",[computeOnce]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model,\"relationshipsByName\",[computeOnce]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model,\"relationshipsObject\",[computeOnce]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model,\"fields\",[computeOnce]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model,\"attributes\",[computeOnce]);(0,_runtime_BPCpkOf1_BKOwiRJp_js__WEBPACK_IMPORTED_MODULE_9__.d)(_Model,\"transformedAttributes\",[computeOnce]);Model.prototype.save=save;// @ts-expect-error TS doesn't know how to do `this` function overloads\nModel.prototype.destroyRecord=destroyRecord;Model.prototype.unloadRecord=unloadRecord;Model.prototype.hasMany=hasMany;Model.prototype.belongsTo=belongsTo;Model.prototype.serialize=serialize;Model.prototype._createSnapshot=createSnapshot;Model.prototype.deleteRecord=deleteRecord;Model.prototype.changedAttributes=changedAttributes;Model.prototype.rollbackAttributes=rollbackAttributes;Model.prototype.reload=reload;(0,_warp_drive_core_store_private__WEBPACK_IMPORTED_MODULE_4__.defineSignal)(Model.prototype,'isReloading',false);// this is required to prevent `init` from passing\n// the values initialized during create to `setUnknownProperty`\nModel.prototype._createProps=null;Model.prototype._secretInit=null;{const lookupDescriptor=function lookupDescriptor(obj,keyName){let current=obj;do{const descriptor=Object.getOwnPropertyDescriptor(current,keyName);if(descriptor!==undefined){return descriptor;}current=Object.getPrototypeOf(current);}while(current!==null);return null;};// eslint-disable-next-line @typescript-eslint/unbound-method\nconst init=Model.prototype.init;Model.prototype.init=function(createArgs){init.call(this,createArgs);const ourDescriptor=lookupDescriptor(Model.prototype,'currentState');const theirDescriptor=lookupDescriptor(this,'currentState');if(!ourDescriptor||!theirDescriptor){throw new Error(`Unable to determine if 'currentState' is a reserved property name on instances of classes extending Model. Please ensure that 'currentState' is not defined as a property on ${this.constructor.toString()}`);}const realState=this.___recordState;if(ourDescriptor.get!==theirDescriptor.get||realState!==this.currentState){throw new Error(`'currentState' is a reserved property name on instances of classes extending Model. Please choose a different property name for ${this.constructor.toString()}`);}const ID_DESCRIPTOR=lookupDescriptor(Model.prototype,'id');const idDesc=lookupDescriptor(this,'id');if(!ID_DESCRIPTOR||!idDesc){throw new Error(`Unable to determine if 'id' is a reserved property name on instances of classes extending Model. Please ensure that 'id' is not defined as a property on ${this.constructor.toString()}`);}if(idDesc.get!==ID_DESCRIPTOR.get){throw new Error(`You may not set 'id' as an attribute on your model. Please remove any lines that look like: \\`id: attr('<type>')\\` from ${this.constructor.toString()}`);}};delete Model.reopen;delete Model.reopenClass;}function isRelationshipSchema(meta){const hasKind=typeof meta==='object'&&meta!==null&&'kind'in meta&&'options'in meta;return hasKind&&(meta.kind==='hasMany'||meta.kind==='belongsTo');}function isAttributeSchema(meta){return typeof meta==='object'&&meta!==null&&'kind'in meta&&meta.kind==='attribute';}/*\n    In case someone defined a relationship to a mixin, for example:\n    ```ts\n      class CommentModel extends Model {\n        @belongsTo('commentable', { polymorphic: true }) owner;\n      }\n\n      let Commentable = Mixin.create({\n        @hasMany('comment') comments;\n      });\n    ```\n    we want to look up a Commentable class which has all the necessary\n    relationship meta data. Thus, we look up the mixin and create a mock\n    Model, so we can access the relationship CPs of the mixin (`comments`)\n    in this case\n  */function modelForMixin(store,normalizedModelName){const owner=(0,_ember_application__WEBPACK_IMPORTED_MODULE_0__.getOwner)(store);const MaybeMixin=owner.factoryFor(`mixin:${normalizedModelName}`);const mixin=MaybeMixin&&MaybeMixin.class;if(mixin){const ModelForMixin=Model.extend(mixin);ModelForMixin.__isMixin=true;ModelForMixin.__mixin=mixin;//Cache the class as a model\nowner.register(`model:${normalizedModelName}`,ModelForMixin);}return owner.factoryFor(`model:${normalizedModelName}`);}class ModelSchemaProvider{constructor(store){this.store=store;this._schemas=new Map();this._typeMisses=new Set();}resourceTypes(){return Array.from(this._schemas.keys());}hasTrait(type){(test=>{{throw new Error(`hasTrait is not available with @ember-data/model's SchemaService`);}})();return false;}resourceHasTrait(resource,trait){(test=>{{throw new Error(`resourceHasTrait is not available with @ember-data/model's SchemaService`);}})();return false;}transformation(field){(test=>{{throw new Error(`transformation is not available with @ember-data/model's SchemaService`);}})();}derivation(field){(test=>{{throw new Error(`derivation is not available with @ember-data/model's SchemaService`);}})();}hashFn(field){(test=>{{throw new Error(`hashFn is not available with @ember-data/model's SchemaService`);}})();}resource(resource){const type=normalizeModelName(resource.type);if(!this._schemas.has(type)){this._loadModelSchema(type);}return this._schemas.get(type).schema;}registerResources(schemas){(test=>{{throw new Error(`registerResources is not available with @ember-data/model's SchemaService`);}})();}registerResource(schema){(test=>{{throw new Error(`registerResource is not available with @ember-data/model's SchemaService`);}})();}registerTransformation(transform){(test=>{{throw new Error(`registerTransformation is not available with @ember-data/model's SchemaService`);}})();}registerDerivation(derivation){(test=>{{throw new Error(`registerDerivation is not available with @ember-data/model's SchemaService`);}})();}registerHashFn(hashFn){(test=>{{throw new Error(`registerHashFn is not available with @ember-data/model's SchemaService`);}})();}_loadModelSchema(type){const modelClass=this.store.modelFor(type);const attributeMap=modelClass.attributes;const attributes=Object.create(null);attributeMap.forEach((meta,name)=>attributes[name]=meta);const relationships=modelClass.relationshipsObject||null;const fields=new Map();for(const attr of Object.values(attributes)){fields.set(attr.name,attr);}for(const rel of Object.values(relationships)){fields.set(rel.name,rel);}const schema={legacy:true,identity:{name:'id',kind:'@id'},type,fields:Array.from(fields.values())};const internalSchema={schema,attributes,relationships,fields};this._schemas.set(type,internalSchema);return internalSchema;}fields(resource){const type=normalizeModelName(resource.type);if(!this._schemas.has(type)){this._loadModelSchema(type);}return this._schemas.get(type).fields;}hasResource(resource){const type=normalizeModelName(resource.type);if(this._schemas.has(type)){return true;}if(this._typeMisses.has(type)){return false;}const factory=getModelFactory(this.store,type);const exists=factory!==null;if(!exists){this._typeMisses.add(type);return false;}return true;}}{ModelSchemaProvider.prototype.doesTypeExist=function(type){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`Use \\`schema.hasResource({ type })\\` instead of \\`schema.doesTypeExist(type)\\``,false,{id:'ember-data:schema-service-updates',until:'6.0',for:'ember-data',since:{available:'4.13',enabled:'5.4'}});return this.hasResource({type});};ModelSchemaProvider.prototype.attributesDefinitionFor=function(resource){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`Use \\`schema.fields({ type })\\` instead of \\`schema.attributesDefinitionFor({ type })\\``,false,{id:'ember-data:schema-service-updates',until:'6.0',for:'ember-data',since:{available:'4.13',enabled:'5.4'}});const type=normalizeModelName(resource.type);// @ts-expect-error intentional use of internal API\nif(!this._schemas.has(type)){// @ts-expect-error intentional use of internal API\nthis._loadModelSchema(type);}// @ts-expect-error intentional use of internal API\nreturn this._schemas.get(type).attributes;};ModelSchemaProvider.prototype.relationshipsDefinitionFor=function(resource){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`Use \\`schema.fields({ type })\\` instead of \\`schema.relationshipsDefinitionFor({ type })\\``,false,{id:'ember-data:schema-service-updates',until:'6.0',for:'ember-data',since:{available:'4.13',enabled:'5.4'}});const type=normalizeModelName(resource.type);// @ts-expect-error intentional use of internal API\nif(!this._schemas.has(type)){// @ts-expect-error intentional use of internal API\nthis._loadModelSchema(type);}// @ts-expect-error intentional use of internal API\nreturn this._schemas.get(type).relationships;};}function buildSchema(store){return new ModelSchemaProvider(store);}function getModelFactory(store,type){if(!store._modelFactoryCache){store._modelFactoryCache=Object.create(null);}const cache=store._modelFactoryCache;let factory=cache[type];if(!factory){const owner=(0,_ember_application__WEBPACK_IMPORTED_MODULE_0__.getOwner)(store);factory=owner.factoryFor(`model:${type}`);if(!factory){//Support looking up mixins as base types for polymorphic relationships\nfactory=modelForMixin(store,type);}if(!factory){// we don't cache misses in case someone wants to register a missing model\nreturn null;}const klass=factory.class;if(klass.isModel){const hasOwnModelNameSet=klass.modelName&&Object.prototype.hasOwnProperty.call(klass,'modelName');if(!hasOwnModelNameSet){Object.defineProperty(klass,'modelName',{value:type});}}cache[type]=factory;}return factory;}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/legacy/dist/schema-provider-BdQhkT-Q.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/legacy/dist/serializer/transform.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@warp-drive/legacy/dist/serializer/transform.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanTransform: () => (/* binding */ BooleanTransform),\n/* harmony export */   DateTransform: () => (/* binding */ DateTransform),\n/* harmony export */   NumberTransform: () => (/* binding */ NumberTransform),\n/* harmony export */   StringTransform: () => (/* binding */ StringTransform),\n/* harmony export */   Transform: () => (/* binding */ Transform)\n/* harmony export */ });\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/object */ \"@ember/object\");\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_object__WEBPACK_IMPORTED_MODULE_0__);\n/**\n  The `Transform` class is used to serialize and deserialize model\n  attributes when they are saved or loaded from an\n  adapter. Subclassing `Transform` is useful for creating custom\n  attributes. All subclasses of `Transform` must implement a\n  `serialize` and a `deserialize` method.\n\n  Example\n\n  ```js [app/transforms/temperature.js]\n\n  // Converts centigrade in the JSON to fahrenheit in the app\n  export default class TemperatureTransform {\n    deserialize(serialized, options) {\n      return (serialized *  1.8) + 32;\n    }\n\n    serialize(deserialized, options) {\n      return (deserialized - 32) / 1.8;\n    }\n\n    static create() {\n      return new this();\n    }\n  }\n  ```\n\n  Usage\n\n  ```js [app/models/requirement.js]\n  import { Model, attr } from '@warp-drive/legacy/model';\n\n  export default class RequirementModel extends Model {\n    @attr('string') name;\n    @attr('temperature') temperature;\n  }\n  ```\n\n  The options passed into the `attr` function when the attribute is\n  declared on the model is also available in the transform.\n\n  ```js [app/models/post.js]\n  import { Model, attr } from '@warp-drive/legacy/model';\n\n  export default class PostModel extends Model {\n    @attr('string') title;\n    @attr('markdown', {\n      markdown: {\n        gfm: false,\n        sanitize: true\n      }\n    })\n    markdown;\n  }\n  ```\n\n  ```js [app/transforms/markdown.js]\n  export default class MarkdownTransform {\n    serialize(deserialized, options) {\n      return deserialized.raw;\n    }\n\n    deserialize(serialized, options) {\n      let markdownOptions = options.markdown || {};\n\n      return marked(serialized, markdownOptions);\n    }\n\n    static create() {\n      return new this();\n    }\n  }\n  ```\n\n  @class Transform\n  @public\n */const Transform=(_ember_object__WEBPACK_IMPORTED_MODULE_0___default());/**\n  The `BooleanTransform` class is used to serialize and deserialize\n  boolean attributes on Ember Data record objects. This transform is\n  used when `boolean` is passed as the type parameter to the\n  [attr](/ember-data/release/functions/@ember-data%2Fmodel/attr) function.\n\n  Usage\n\n  ```js [app/models/user.js]\n  import { Model, attr } from '@warp-drive/legacy/model';\n\n  export default class UserModel extends Model {\n    @attr('boolean') isAdmin;\n    @attr('string') name;\n    @attr('string') email;\n  }\n  ```\n\n  By default, the boolean transform only allows for values of `true` or\n  `false`. You can opt into allowing `null` values for\n  boolean attributes via `attr('boolean', { allowNull: true })`\n\n  ```js [app/models/user.js]\n  import { Model, attr } from '@warp-drive/legacy/model';\n\n  export default class UserModel extends Model {\n    @attr('string') email;\n    @attr('string') username;\n    @attr('boolean', { allowNull: true }) wantsWeeklyEmail;\n  }\n  ```\n\n  @public\n */class BooleanTransform{deserialize(serialized,options){if((serialized===null||serialized===undefined)&&options?.allowNull===true){return null;}if(typeof serialized==='boolean'){return serialized;}else if(typeof serialized==='string'){return /^(true|t|1)$/i.test(serialized);}else if(typeof serialized==='number'){return serialized===1;}else{return false;}}serialize(deserialized,options){if((deserialized===null||deserialized===undefined)&&options?.allowNull===true){return null;}return Boolean(deserialized);}static create(){return new this();}}/**\n The `DateTransform` class is used to serialize and deserialize\n date attributes on Ember Data record objects. This transform is used\n when `date` is passed as the type parameter to the\n [attr](/ember-data/release/functions/@ember-data%2Fmodel/attr) function. It uses the [`ISO 8601`](https://en.wikipedia.org/wiki/ISO_8601)\n standard.\n\n ```js [app/models/score.js]\n import Model, { attr, belongsTo } from '@ember-data/model';\n\n export default class ScoreModel extends Model {\n    @attr('number') value;\n    @belongsTo('player') player;\n    @attr('date') date;\n  }\n ```\n\n  @public\n */class DateTransform{deserialize(serialized,_options){if(typeof serialized==='string'){let offset=serialized.indexOf('+');if(offset!==-1&&serialized.length-5===offset){offset+=3;return new Date(serialized.slice(0,offset)+':'+serialized.slice(offset));}return new Date(serialized);}else if(typeof serialized==='number'){return new Date(serialized);}else if(serialized===null||serialized===undefined){// if the value is null return null\n// if the value is not present in the data return undefined\nreturn serialized;}else{return null;}}serialize(date,_options){// @ts-expect-error isNaN accepts date as it is coercible\nif(date instanceof Date&&!isNaN(date)){return date.toISOString();}else{return null;}}static create(){return new this();}}function isNumber(value){return value===value&&value!==Infinity&&value!==-Infinity;}/**\n  The `NumberTransform` class is used to serialize and deserialize\n  numeric attributes on Ember Data record objects. This transform is\n  used when `number` is passed as the type parameter to the\n  [attr](/ember-data/release/functions/@ember-data%2Fmodel/attr) function.\n\n  Usage\n\n  ```js [app/models/score.js]\n  import Model, { attr, belongsTo } from '@ember-data/model';\n\n  export default class ScoreModel extends Model {\n    @attr('number') value;\n    @belongsTo('player') player;\n    @attr('date') date;\n  }\n  ```\n\n  @public\n */class NumberTransform{deserialize(serialized,_options){if(serialized===''||serialized===null||serialized===undefined){return null;}else{const transformed=Number(serialized);return isNumber(transformed)?transformed:null;}}serialize(deserialized,_options){if(deserialized===''||deserialized===null||deserialized===undefined){return null;}else{const transformed=Number(deserialized);return isNumber(transformed)?transformed:null;}}static create(){return new this();}}/**\n  The `StringTransform` class is used to serialize and deserialize\n  string attributes on Ember Data record objects. This transform is\n  used when `string` is passed as the type parameter to the\n  [attr](/ember-data/release/functions/@ember-data%2Fmodel/attr) function.\n\n  Usage\n\n  ```js [app/models/user.js]\n  import Model, { attr, belongsTo } from '@ember-data/model';\n\n  export default class UserModel extends Model {\n    @attr('boolean') isAdmin;\n    @attr('string') name;\n    @attr('string') email;\n  }\n  ```\n\n  @public\n */class StringTransform{deserialize(serialized,_options){return!serialized&&serialized!==''?null:String(serialized);}serialize(deserialized,_options){return!deserialized&&deserialized!==''?null:String(deserialized);}static create(){return new this();}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/legacy/dist/serializer/transform.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/utilities/dist/-private.js":
/*!*************************************************************!*\
  !*** ./node_modules/@warp-drive/utilities/dist/-private.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InflectionRuleDefaults: () => (/* binding */ defaultRules)\n/* harmony export */ });\nconst defaultRules={plurals:[[/$/,'s'],[/s$/i,'s'],[/^(ax|test)is$/i,'$1es'],[/(octop|vir)us$/i,'$1i'],[/(octop|vir)i$/i,'$1i'],[/(alias|status|bonus)$/i,'$1es'],[/(bu)s$/i,'$1ses'],[/(buffal|tomat)o$/i,'$1oes'],[/([ti])um$/i,'$1a'],[/([ti])a$/i,'$1a'],[/sis$/i,'ses'],[/(?:([^f])fe|([lr])f)$/i,'$1$2ves'],[/(hive)$/i,'$1s'],[/([^aeiouy]|qu)y$/i,'$1ies'],[/(x|ch|ss|sh)$/i,'$1es'],[/(matr|vert|ind)(?:ix|ex)$/i,'$1ices'],[/^(m|l)ouse$/i,'$1ice'],[/^(m|l)ice$/i,'$1ice'],[/^(ox)$/i,'$1en'],[/^(oxen)$/i,'$1'],[/(quiz)$/i,'$1zes']],singular:[[/s$/i,''],[/(ss)$/i,'$1'],[/(n)ews$/i,'$1ews'],[/([ti])a$/i,'$1um'],[/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(sis|ses)$/i,'$1sis'],[/(^analy)(sis|ses)$/i,'$1sis'],[/([^f])ves$/i,'$1fe'],[/(hive)s$/i,'$1'],[/(tive)s$/i,'$1'],[/([lr])ves$/i,'$1f'],[/([^aeiouy]|qu)ies$/i,'$1y'],[/(s)eries$/i,'$1eries'],[/(m)ovies$/i,'$1ovie'],[/(x|ch|ss|sh)es$/i,'$1'],[/^(m|l)ice$/i,'$1ouse'],[/(bus)(es)?$/i,'$1'],[/(o)es$/i,'$1'],[/(shoe)s$/i,'$1'],[/(cris|test)(is|es)$/i,'$1is'],[/^(a)x[ie]s$/i,'$1xis'],[/(octop|vir)(us|i)$/i,'$1us'],[/(alias|status|bonus)(es)?$/i,'$1'],[/^(ox)en/i,'$1'],[/(vert|ind)ices$/i,'$1ex'],[/(matr)ices$/i,'$1ix'],[/(quiz)zes$/i,'$1'],[/(database)s$/i,'$1']],irregularPairs:[['person','people'],['man','men'],['child','children'],['sex','sexes'],['move','moves'],['cow','kine'],['zombie','zombies']],uncountable:['equipment','information','rice','money','species','series','fish','sheep','jeans','police']};\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/utilities/dist/-private.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/utilities/dist/inflect-BSG696t-.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@warp-drive/utilities/dist/inflect-BSG696t-.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ singular),\n/* harmony export */   b: () => (/* binding */ plural),\n/* harmony export */   c: () => (/* binding */ loadUncountable),\n/* harmony export */   d: () => (/* binding */ clear),\n/* harmony export */   e: () => (/* binding */ clearRules),\n/* harmony export */   f: () => (/* binding */ dasherize),\n/* harmony export */   g: () => (/* binding */ camelize),\n/* harmony export */   h: () => (/* binding */ capitalize),\n/* harmony export */   i: () => (/* binding */ irregular),\n/* harmony export */   j: () => (/* binding */ underscore),\n/* harmony export */   k: () => (/* binding */ setMaxLRUCacheSize),\n/* harmony export */   l: () => (/* binding */ loadIrregular),\n/* harmony export */   p: () => (/* binding */ pluralize),\n/* harmony export */   r: () => (/* binding */ resetToDefaults),\n/* harmony export */   s: () => (/* binding */ singularize),\n/* harmony export */   u: () => (/* binding */ uncountable)\n/* harmony export */ });\n/* harmony import */ var _warp_drive_core_utils_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @warp-drive/core/utils/string */ \"./node_modules/@warp-drive/core/dist/utils/string.js\");\n/* harmony import */ var _private_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./-private.js */ \"./node_modules/@warp-drive/utilities/dist/-private.js\");\n// eslint-disable-next-line no-useless-escape\nconst STRING_CAMELIZE_REGEXP_1=/(\\-|\\_|\\.|\\s)+(.)?/g;const STRING_CAMELIZE_REGEXP_2=/(^|\\/)([A-Z])/g;const CAMELIZE_CACHE=new _warp_drive_core_utils_string__WEBPACK_IMPORTED_MODULE_0__.LRUCache(key=>key.replace(STRING_CAMELIZE_REGEXP_1,(_match,_separator,chr)=>chr?chr.toUpperCase():'').replace(STRING_CAMELIZE_REGEXP_2,(match/*, separator, chr */)=>match.toLowerCase()));const STRING_UNDERSCORE_REGEXP_1=/([a-z\\d])([A-Z]+)/g;// eslint-disable-next-line no-useless-escape\nconst STRING_UNDERSCORE_REGEXP_2=/\\-|\\s+/g;const UNDERSCORE_CACHE=new _warp_drive_core_utils_string__WEBPACK_IMPORTED_MODULE_0__.LRUCache(str=>str.replace(STRING_UNDERSCORE_REGEXP_1,'$1_$2').replace(STRING_UNDERSCORE_REGEXP_2,'_').toLowerCase());const STRING_CAPITALIZE_REGEXP=/(^|\\/)([a-z\\u00C0-\\u024F])/g;const CAPITALIZE_CACHE=new _warp_drive_core_utils_string__WEBPACK_IMPORTED_MODULE_0__.LRUCache(str=>str.replace(STRING_CAPITALIZE_REGEXP,(match/*, separator, chr */)=>match.toUpperCase()));/**\n * Replaces underscores, spaces, or camelCase with dashes.\n *\n * ```js\n * import { dasherize } from '@warp-drive/utilities/string';\n *\n * dasherize('innerHTML');                // 'inner-html'\n * dasherize('action_name');              // 'action-name'\n * dasherize('css-class-name');           // 'css-class-name'\n * dasherize('my favorite items');        // 'my-favorite-items'\n * dasherize('privateDocs/ownerInvoice';  // 'private-docs/owner-invoice'\n * ```\n *\n * @public\n * @since 4.13.0\n */const dasherize=_warp_drive_core_utils_string__WEBPACK_IMPORTED_MODULE_0__.dasherize;/**\n * Returns the lowerCamelCase form of a string.\n *\n * ```js\n * import { camelize } from '@warp-drive/utilities/string';\n *\n * camelize('innerHTML');                   // 'innerHTML'\n * camelize('action_name');                 // 'actionName'\n * camelize('css-class-name');              // 'cssClassName'\n * camelize('my favorite items');           // 'myFavoriteItems'\n * camelize('My Favorite Items');           // 'myFavoriteItems'\n * camelize('private-docs/owner-invoice');  // 'privateDocs/ownerInvoice'\n * ```\n *\n * @public\n * @since 4.13.0\n */function camelize(str){return CAMELIZE_CACHE.get(str);}/**\n * Returns the lower\\_case\\_and\\_underscored form of a string.\n *\n * ```js\n * import { underscore } from '@warp-drive/utilities/string';\n *\n * underscore('innerHTML');                 // 'inner_html'\n * underscore('action_name');               // 'action_name'\n * underscore('css-class-name');            // 'css_class_name'\n * underscore('my favorite items');         // 'my_favorite_items'\n * underscore('privateDocs/ownerInvoice');  // 'private_docs/owner_invoice'\n * ```\n *\n * @public\n * @since 4.13.0\n */function underscore(str){return UNDERSCORE_CACHE.get(str);}/**\n * Returns the Capitalized form of a string\n *\n * ```js\n * import { capitalize } from '@warp-drive/utilities/string';\n *\n * capitalize('innerHTML')                 // 'InnerHTML'\n * capitalize('action_name')               // 'Action_name'\n * capitalize('css-class-name')            // 'Css-class-name'\n * capitalize('my favorite items')         // 'My favorite items'\n * capitalize('privateDocs/ownerInvoice'); // 'PrivateDocs/ownerInvoice'\n * ```\n *\n * @public\n * @since 4.13.0\n */function capitalize(str){return CAPITALIZE_CACHE.get(str);}/**\n * Sets the maximum size of the LRUCache for all string transformation functions.\n * The default size is 10,000.\n *\n * @public\n * @since 4.13.0\n */function setMaxLRUCacheSize(size){CAMELIZE_CACHE.size=size;UNDERSCORE_CACHE.size=size;CAPITALIZE_CACHE.size=size;_warp_drive_core_utils_string__WEBPACK_IMPORTED_MODULE_0__.STRING_DASHERIZE_CACHE.size=size;}const BLANK_REGEX=/^\\s*$/;const LAST_WORD_DASHED_REGEX=/([\\w/-]+[_/\\s-])([a-z\\d]+$)/;const LAST_WORD_CAMELIZED_REGEX=/([\\w/\\s-]+)([A-Z][a-z\\d]*$)/;const CAMELIZED_REGEX=/[A-Z][a-z\\d]*$/;const SINGULARS=new _warp_drive_core_utils_string__WEBPACK_IMPORTED_MODULE_0__.LRUCache(word=>{return _singularize(word);});const PLURALS=new _warp_drive_core_utils_string__WEBPACK_IMPORTED_MODULE_0__.LRUCache(word=>{return _pluralize(word);});const UNCOUNTABLE=new Set(_private_js__WEBPACK_IMPORTED_MODULE_1__.InflectionRuleDefaults.uncountable);const IRREGULAR=new Map();const INVERSE_IRREGULAR=new Map();const SINGULAR_RULES=new Map(_private_js__WEBPACK_IMPORTED_MODULE_1__.InflectionRuleDefaults.singular.reverse());const PLURAL_RULES=new Map(_private_js__WEBPACK_IMPORTED_MODULE_1__.InflectionRuleDefaults.plurals.reverse());/**\n * Marks a word as uncountable. Uncountable words are not pluralized\n * or singularized.\n *\n * @public\n * @since 4.13.0\n */function uncountable(word){UNCOUNTABLE.add(word.toLowerCase());}/**\n * Marks a list of words as uncountable. Uncountable words are not pluralized\n * or singularized.\n *\n * @public\n * @since 4.13.0\n */function loadUncountable(uncountables){uncountables.forEach(word=>{uncountable(word);});}/**\n * Marks a word as irregular. Irregular words have unique\n * pluralization and singularization rules.\n *\n * @public\n * @since 4.13.0\n */function irregular(single,plur){//pluralizing\nIRREGULAR.set(single.toLowerCase(),plur);IRREGULAR.set(plur.toLowerCase(),plur);//singularizing\nINVERSE_IRREGULAR.set(plur.toLowerCase(),single);INVERSE_IRREGULAR.set(single.toLowerCase(),single);}/**\n * Marks a list of word pairs as irregular. Irregular words have unique\n * pluralization and singularization rules.\n *\n * @public\n * @since 4.13.0\n */function loadIrregular(irregularPairs){irregularPairs.forEach(pair=>{//pluralizing\nIRREGULAR.set(pair[0].toLowerCase(),pair[1]);IRREGULAR.set(pair[1].toLowerCase(),pair[1]);//singularizing\nINVERSE_IRREGULAR.set(pair[1].toLowerCase(),pair[0]);INVERSE_IRREGULAR.set(pair[0].toLowerCase(),pair[0]);});}loadIrregular(_private_js__WEBPACK_IMPORTED_MODULE_1__.InflectionRuleDefaults.irregularPairs);/**\n * Clears the caches for singularize and pluralize.\n *\n * @public\n * @since 4.13.0\n */function clear(){SINGULARS.clear();PLURALS.clear();}/**\n * Resets the inflection rules to the defaults.\n *\n * @public\n * @since 4.13.0\n */function resetToDefaults(){clearRules();_private_js__WEBPACK_IMPORTED_MODULE_1__.InflectionRuleDefaults.uncountable.forEach(v=>UNCOUNTABLE.add(v));_private_js__WEBPACK_IMPORTED_MODULE_1__.InflectionRuleDefaults.singular.forEach(v=>SINGULAR_RULES.set(v[0],v[1]));_private_js__WEBPACK_IMPORTED_MODULE_1__.InflectionRuleDefaults.plurals.forEach(v=>PLURAL_RULES.set(v[0],v[1]));loadIrregular(_private_js__WEBPACK_IMPORTED_MODULE_1__.InflectionRuleDefaults.irregularPairs);}/**\n * Clears all inflection rules\n * and resets the caches for singularize and pluralize.\n *\n * @public\n * @since 4.13.0\n */function clearRules(){SINGULARS.clear();PLURALS.clear();UNCOUNTABLE.clear();IRREGULAR.clear();INVERSE_IRREGULAR.clear();SINGULAR_RULES.clear();PLURAL_RULES.clear();}/**\n * Singularizes a word.\n *\n * @public\n * @since 4.13.0\n */function singularize(word){(test=>{if(!test){throw new Error(`singularize expects to receive a non-empty string`);}})(typeof word==='string'&&word.length>0);if(!word)return'';return SINGULARS.get(word);}/**\n * Pluralizes a word.\n *\n * @public\n * @since 4.13.0\n */function pluralize(word){(test=>{if(!test){throw new Error(`pluralize expects to receive a non-empty string`);}})(typeof word==='string'&&word.length>0);if(!word)return'';return PLURALS.get(word);}function unshiftMap(v,map){// reorder\nconst rules=[v,...map.entries()];map.clear();rules.forEach(rule=>{map.set(rule[0],rule[1]);});}/**\n * Adds a pluralization rule.\n *\n * @public\n * @since 4.13.0\n */function plural(regex,string){// rule requires reordering if exists, so remove it first\nif(PLURAL_RULES.has(regex)){PLURAL_RULES.delete(regex);}// reorder\nunshiftMap([regex,string],PLURAL_RULES);}/**\n * Adds a singularization rule.\n *\n * @public\n * @since 4.13.0\n */function singular(regex,string){// rule requires reordering if exists, so remove it first\nif(SINGULAR_RULES.has(regex)){SINGULAR_RULES.delete(regex);}// reorder\nunshiftMap([regex,string],SINGULAR_RULES);}function _pluralize(word){return inflect(word,PLURAL_RULES,IRREGULAR);}function _singularize(word){return inflect(word,SINGULAR_RULES,INVERSE_IRREGULAR);}function inflect(word,typeRules,irregulars){// empty strings\nconst isBlank=!word||BLANK_REGEX.test(word);if(isBlank){return word;}// basic uncountables\nconst lowercase=word.toLowerCase();if(UNCOUNTABLE.has(lowercase)){return word;}// adv uncountables\nconst wordSplit=LAST_WORD_DASHED_REGEX.exec(word)||LAST_WORD_CAMELIZED_REGEX.exec(word);const lastWord=wordSplit?wordSplit[2].toLowerCase():null;if(lastWord&&UNCOUNTABLE.has(lastWord)){return word;}// handle irregulars\nconst isCamelized=CAMELIZED_REGEX.test(word);for(let[rule,substitution]of irregulars){if(lowercase.match(rule+'$')){if(isCamelized&&lastWord&&irregulars.has(lastWord)){substitution=capitalize(substitution);rule=capitalize(rule);}return word.replace(new RegExp(rule,'i'),substitution);}}// do the actual inflection\nfor(const[rule,substitution]of typeRules){if(rule.test(word)){return word.replace(rule,substitution);}}return word;}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/utilities/dist/inflect-BSG696t-.js?\n}");

/***/ }),

/***/ "./node_modules/@warp-drive/utilities/dist/string.js":
/*!***********************************************************!*\
  !*** ./node_modules/@warp-drive/utilities/dist/string.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   camelize: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   capitalize: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   clear: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   clearRules: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   dasherize: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   irregular: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   loadIrregular: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   loadUncountable: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   plural: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   pluralize: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   resetToDefaults: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   setMaxLRUCacheSize: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   singular: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   singularize: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   uncountable: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   underscore: () => (/* reexport safe */ _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__.j)\n/* harmony export */ });\n/* harmony import */ var _inflect_BSG696t_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inflect-BSG696t-.js */ \"./node_modules/@warp-drive/utilities/dist/inflect-BSG696t-.js\");\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/utilities/dist/string.js?\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/ember-welcome-page/dist/components/welcome-page.css":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/ember-welcome-page/dist/components/welcome-page.css ***!
  \****************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"body {\\n  color: rgb(28, 30, 36);\\n  background: rgb(244, 246, 248);\\n  font-family: \\\"Inter var\\\",\\\"Inter web\\\",-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;\\n  font-size: 18px;\\n  font-weight: 200;\\n  line-height: 1.5;\\n  margin: 0 auto;\\n  padding: 0;\\n}\\n#ember-welcome-page-id-selector {\\n  height: 100vh;\\n  padding: 2em;\\n}\\n#ember-welcome-page-id-selector img {\\n  max-width: 100%;\\n}\\n#ember-welcome-page-id-selector p {\\n  font-size: 1.25em;\\n  margin: 0 0 .75em;\\n}\\n#ember-welcome-page-id-selector h1 {\\n  font-size: 2.5em;\\n  font-weight: 200;\\n  line-height: 1.2;\\n  margin-top: 0;\\n}\\n#ember-welcome-page-id-selector a:link,\\n#ember-welcome-page-id-selector a:visited {\\n  color:rgb(255, 92, 68);\\n}\\n#ember-welcome-page-id-selector a:hover,\\n#ember-welcome-page-id-selector a:active {\\n  color: rgb(255, 92, 68);\\n}\\n#ember-welcome-page-id-selector .tomster {\\n  flex: 2;\\n}\\n#ember-welcome-page-id-selector .welcome {\\n  flex: 3;\\n}\\n#ember-welcome-page-id-selector .columns {\\n  display: flex;\\n  margin: 0 auto;\\n  max-width: 960px;\\n}\\n#ember-welcome-page-id-selector .welcome > ul > li {\\n  padding-bottom: 0.5em;\\n  font-size: 1.1em;\\n}\\n#ember-welcome-page-id-selector .welcome > ul > li > a {\\n  font-weight: bold;\\n}\\n#ember-welcome-page-id-selector .postscript {\\n  color: rgb(28, 30, 36);\\n  background: rgb(244, 246, 248);\\n  font-style: italic;\\n  line-height: 2;\\n  margin: 0 auto;\\n  max-width: 960px;\\n  padding-top: 3em;\\n  text-align: center;\\n}\\n#ember-welcome-page-id-selector .postscript code {\\n  color: rgb(244, 246, 248);\\n  border-radius: 3px;\\n  background-color: rgb(28, 30, 36);\\n  display: inline-block;\\n  font-family: Menlo, Courier, monospace;\\n  font-size: 0.9em;\\n  margin: 0 0.1em;\\n  padding: 0 0.5em;\\n}\\n@media (max-width: 700px) {\\n  #ember-welcome-page-id-selector {\\n    padding: 1em;\\n  }\\n  #ember-welcome-page-id-selector .columns {\\n    flex-direction: column;\\n  }\\n  #ember-welcome-page-id-selector .tomster img {\\n    display: block;\\n    margin: auto;\\n    width: 50%;\\n  }\\n  #ember-welcome-page-id-selector h2 {\\n    text-align: center;\\n  }\\n}\\n@media (max-width: 400px) {\\n  #ember-welcome-page-id-selector .tomster img {\\n    width: 60%;\\n  }\\n  #ember-welcome-page-id-selector .welcome,\\n  #ember-welcome-page-id-selector .tomster {\\n    float: none;\\n    margin: auto;\\n    width: 100%;\\n  }\\n}\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-welcome-page/dist/components/welcome-page.css?./node_modules/css-loader/dist/cjs.js\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("{/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports=function(cssWithMappingToString){var list=[];// return the list of modules as css string\nlist.toString=function toString(){return this.map(function(item){var content=cssWithMappingToString(item);if(item[2]){return\"@media \".concat(item[2],\" {\").concat(content,\"}\");}return content;}).join(\"\");};// import a list of modules into the list\n// eslint-disable-next-line func-names\nlist.i=function(modules,mediaQuery,dedupe){if(typeof modules===\"string\"){// eslint-disable-next-line no-param-reassign\nmodules=[[null,modules,\"\"]];}var alreadyImportedModules={};if(dedupe){for(var i=0;i<this.length;i++){// eslint-disable-next-line prefer-destructuring\nvar id=this[i][0];if(id!=null){alreadyImportedModules[id]=true;}}}for(var _i=0;_i<modules.length;_i++){var item=[].concat(modules[_i]);if(dedupe&&alreadyImportedModules[item[0]]){// eslint-disable-next-line no-continue\ncontinue;}if(mediaQuery){if(!item[2]){item[2]=mediaQuery;}else{item[2]=\"\".concat(mediaQuery,\" and \").concat(item[2]);}}list.push(item);}};return list;};\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/css-loader/dist/runtime/api.js?\n}");

/***/ }),

/***/ "./node_modules/ember-load-initializers/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/ember-load-initializers/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ loadInitializers)\n/* harmony export */ });\nfunction resolveInitializer(modules,moduleName){let module=modules.load(moduleName);if(!module){throw new Error(moduleName+' must export an initializer.');}let initializer=module.default;if(!initializer){throw new Error(moduleName+' must have a default export');}if(!initializer.name){initializer.name=moduleName.slice(moduleName.lastIndexOf('/')+1);}return initializer;}function registerInitializers(app,modules,moduleNames){for(let moduleName of moduleNames){app.initializer(resolveInitializer(modules,moduleName));}}function registerInstanceInitializers(app,modules,moduleNames){for(let moduleName of moduleNames){app.instanceInitializer(resolveInitializer(modules,moduleName));}}/**\n * Configure your application as it boots\n */function loadInitializers(app,prefix,explicitModules){var initializerPrefix=prefix+'/initializers/';var instanceInitializerPrefix=prefix+'/instance-initializers/';var initializers=[];var instanceInitializers=[];let modules;if(explicitModules){modules={names(){return Object.keys(explicitModules);},load(name){return explicitModules[name];}};}else{modules={names(){let requirejs=globalThis.requirejs;if(!requirejs||!requirejs._eak_seen){throw new Error(\"No global AMD loader found. To use loadInitializers without a global AMD loader you must provide explicit modules\");}return Object.keys(requirejs._eak_seen);},load(name){return globalThis.require(name,null,null,true);}};}for(let moduleName of modules.names()){if(moduleName.startsWith(initializerPrefix)&&!moduleName.endsWith('-test')){initializers.push(moduleName);}else if(moduleName.startsWith(instanceInitializerPrefix)&&!moduleName.endsWith('-test')){instanceInitializers.push(moduleName);}}registerInitializers(app,modules,initializers);registerInstanceInitializers(app,modules,instanceInitializers);}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-load-initializers/dist/index.js?\n}");

/***/ }),

/***/ "./node_modules/ember-page-title/dist/_rollupPluginBabelHelpers-9wjJaosZ.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ember-page-title/dist/_rollupPluginBabelHelpers-9wjJaosZ.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _applyDecoratedDescriptor),\n/* harmony export */   a: () => (/* binding */ _initializerDefineProperty),\n/* harmony export */   b: () => (/* binding */ _defineProperty)\n/* harmony export */ });\nfunction _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:String(i);}function _defineProperty(obj,key,value){key=_toPropertyKey(key);if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _initializerDefineProperty(target,property,descriptor,context){if(!descriptor)return;Object.defineProperty(target,property,{enumerable:descriptor.enumerable,configurable:descriptor.configurable,writable:descriptor.writable,value:descriptor.initializer?descriptor.initializer.call(context):void 0});}function _applyDecoratedDescriptor(target,property,decorators,descriptor,context){var desc={};Object.keys(descriptor).forEach(function(key){desc[key]=descriptor[key];});desc.enumerable=!!desc.enumerable;desc.configurable=!!desc.configurable;if('value'in desc||desc.initializer){desc.writable=true;}desc=decorators.slice().reverse().reduce(function(desc,decorator){return decorator(target,property,desc)||desc;},desc);if(context&&desc.initializer!==void 0){desc.value=desc.initializer?desc.initializer.call(context):void 0;desc.initializer=undefined;}if(desc.initializer===void 0){Object.defineProperty(target,property,desc);desc=null;}return desc;}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-page-title/dist/_rollupPluginBabelHelpers-9wjJaosZ.js?\n}");

/***/ }),

/***/ "./node_modules/ember-page-title/dist/helpers/page-title.js":
/*!******************************************************************!*\
  !*** ./node_modules/ember-page-title/dist/helpers/page-title.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PageTitle)\n/* harmony export */ });\n/* harmony import */ var _rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_rollupPluginBabelHelpers-9wjJaosZ.js */ \"./node_modules/ember-page-title/dist/_rollupPluginBabelHelpers-9wjJaosZ.js\");\n/* harmony import */ var _ember_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/service */ \"@ember/service\");\n/* harmony import */ var _ember_service__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_service__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ember_component_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember/component/helper */ \"@ember/component/helper\");\n/* harmony import */ var _ember_component_helper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ember_component_helper__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _ember_object_internals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ember/object/internals */ \"@ember/object/internals\");\n/* harmony import */ var _ember_object_internals__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_ember_object_internals__WEBPACK_IMPORTED_MODULE_3__);\nvar _dec,_class,_descriptor;/**\n * `{{pageTitle}}` helper used to set the title of the current route context.\n *\n * ```gjs\n * import { pageTitle } from 'ember-page-title';\n *\n * <template>\n *   {{pageTitle \"the text to set the tab's title to\"}}\n *   {{pageTitle \\@model.post.title}}\n * </template>\n * ```\n */let PageTitle=(_dec=(0,_ember_service__WEBPACK_IMPORTED_MODULE_1__.service)('page-title'),_class=class PageTitle extends (_ember_component_helper__WEBPACK_IMPORTED_MODULE_2___default()){constructor(owner){super(owner);(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.a)(this,\"tokens\",_descriptor,this);(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.b)(this,\"tokenId\",(0,_ember_object_internals__WEBPACK_IMPORTED_MODULE_3__.guidFor)(this));this.tokens.push({id:this.tokenId});}compute(params,userOptions){const options={...userOptions,id:this.tokenId,title:params.join('')};this.tokens.push(options);this.tokens.scheduleTitleUpdate();// We must return an empty value here because otherwise\n// invoking the pageTitle helper will render something\n// in the component it's used in, and we don't want that.\n//\n// pageTitle is a side-effecting helper.\n// We *synchronize* the document.title with our internal state.\nreturn'';}willDestroy(){super.willDestroy();this.tokens.remove(this.tokenId);this.tokens.scheduleTitleUpdate();}},_descriptor=(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__._)(_class.prototype,\"tokens\",[_dec],{configurable:true,enumerable:true,writable:true,initializer:null}),_class);\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-page-title/dist/helpers/page-title.js?\n}");

/***/ }),

/***/ "./node_modules/ember-page-title/dist/services/page-title.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ember-page-title/dist/services/page-title.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PageTitleService)\n/* harmony export */ });\n/* harmony import */ var _rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_rollupPluginBabelHelpers-9wjJaosZ.js */ \"./node_modules/ember-page-title/dist/_rollupPluginBabelHelpers-9wjJaosZ.js\");\n/* harmony import */ var _ember_runloop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/runloop */ \"@ember/runloop\");\n/* harmony import */ var _ember_runloop__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_runloop__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ember_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember/service */ \"@ember/service\");\n/* harmony import */ var _ember_service__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ember_service__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _ember_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ember/utils */ \"@ember/utils\");\n/* harmony import */ var _ember_utils__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_ember_utils__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_4__);\nvar _dec,_dec2,_class,_descriptor,_descriptor2;const isFastBoot=typeof FastBoot!=='undefined';const RouterEvent={ROUTE_DID_CHANGE:'routeDidChange'};function hasResolveRegistration(owner){return`resolveRegistration`in owner;}function hasPageTitleConfig(fromEnv){if(typeof fromEnv!=='object')return false;if(fromEnv===null)return false;// all properties on the pageTitle config are optional,\n// so we can't check for more\nreturn'pageTitle'in fromEnv;}const configKeys=['separator','prepend','replace'];/**\n  @class page-title\n  @extends Ember.Service\n */let PageTitleService=(_dec=(0,_ember_service__WEBPACK_IMPORTED_MODULE_2__.service)('router'),_dec2=(0,_ember_service__WEBPACK_IMPORTED_MODULE_2__.service)('-document'),_class=class PageTitleService extends (_ember_service__WEBPACK_IMPORTED_MODULE_2___default()){constructor(owner){super(owner);(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.a)(this,\"router\",_descriptor,this);// in fastboot context \"document\" is instance of\n// ember-fastboot/simple-dom document\n(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.a)(this,\"document\",_descriptor2,this);(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.b)(this,\"tokens\",[]);(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.b)(this,\"_defaultConfig\",{// The default separator to use between tokens.\nseparator:' | ',// The default prepend value to use.\nprepend:true,// The default replace value to use.\nreplace:null});(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.b)(this,\"scheduleTitleUpdate\",()=>{// eslint-disable-next-line ember/no-runloop\n(0,_ember_runloop__WEBPACK_IMPORTED_MODULE_1__.scheduleOnce)('afterRender',this,this._updateTitle);});this._validateExistingTitleElement();if(hasResolveRegistration(owner)){const config=owner.resolveRegistration('config:environment');if(hasPageTitleConfig(config)){configKeys.forEach(key=>{if(!(0,_ember_utils__WEBPACK_IMPORTED_MODULE_3__.isEmpty)(config.pageTitle[key])){const configValue=config.pageTitle[key];// SAFETY: how is one supposed to iterate over keys for an object and have it\n//         known to the compiler that both objects, having the same shape,\n//         will have the same type per-value?\n//         as-is, the `configValue` is a union of all value-types from the object.\nthis._defaultConfig[key]=configValue;}});}}this.router.on(RouterEvent.ROUTE_DID_CHANGE,this.scheduleTitleUpdate);}applyTokenDefaults(token){const defaultSeparator=this._defaultConfig.separator;const defaultPrepend=this._defaultConfig.prepend;const defaultReplace=this._defaultConfig.replace;token.previous??=null;token.next??=null;if(token.separator==null){token.separator=defaultSeparator;}if(token.prepend==null&&defaultPrepend!=null){token.prepend=defaultPrepend;}if(token.replace==null&&defaultReplace!=null){token.replace=defaultReplace;}}inheritFromPrevious(token){const previous=token.previous;if(previous){if(token.separator==null){token.separator=previous.separator;}if(token.prepend==null){token.prepend=previous.prepend;}}}push(token){const tokenForId=this._findTokenById(token.id);if(tokenForId){const index=this.tokens.indexOf(tokenForId);const tokens=[...this.tokens];const previous=tokenForId.previous;token.previous=previous;token.next=tokenForId.next;this.inheritFromPrevious(token);this.applyTokenDefaults(token);tokens.splice(index,1,token);this.tokens=tokens;return;}const previous=this.tokens.slice(-1)[0];if(previous){token.previous=previous??null;previous.next=token;this.inheritFromPrevious(token);}this.applyTokenDefaults(token);this.tokens=[...this.tokens,token];}remove(id){const token=this._findTokenById(id);if(!token)return;const{next,previous}=token;if(next){next.previous=previous;}if(previous){previous.next=next;}token.previous=token.next=null;const tokens=[...this.tokens];tokens.splice(tokens.indexOf(token),1);this.tokens=tokens;}get visibleTokens(){const tokens=this.tokens;let i=tokens?tokens.length:0;const visible=[];while(i--){const token=tokens[i];if(!token)continue;if(token.replace){visible.unshift(token);break;}else{visible.unshift(token);}}return visible;}get sortedTokens(){const visible=this.visibleTokens;if(!visible)return[];let appending=true;let group=[];const groups=[group];const frontGroups=[];visible.forEach(token=>{if(token.front){frontGroups.unshift(token);}else if(token.prepend){if(appending){appending=false;group=[];groups.push(group);}group.unshift(token);}else{if(!appending){appending=true;group=[];groups.push(group);}group.push(token);}});return frontGroups.concat(groups.reduce((E,group)=>E.concat(group),[]));}toString(){const tokens=this.sortedTokens;const title=[];for(let i=0,len=tokens.length;i<len;i++){const token=tokens[i];if(!token)continue;if(token.title){title.push(token.title);if(i+1<len){title.push(token.separator);}}}return title.join('');}willDestroy(){super.willDestroy();this.router.off(RouterEvent.ROUTE_DID_CHANGE,this.scheduleTitleUpdate);}_updateTitle(){const toBeTitle=this.toString();if(isFastBoot){this.updateFastbootTitle(toBeTitle);}else{/**\n       * When rendering app with \"?fastboot=false\" (http://ember-fastboot.com/docs/user-guide#disabling-fastboot)\n       * We will not have <title> element present in DOM.\n       *\n       * But this is fine as by HTML spec,\n       * one is created upon assigning \"document.title\" value;\n       *\n       * https://html.spec.whatwg.org/multipage/dom.html#dom-tree-accessors\n       */this.document.title=toBeTitle;}this.titleDidUpdate(toBeTitle);}/**\n   * Validate if there's more than one title element present.\n   *\n   * Example: ember-cli-head can cause conflicting updates.\n   * @private\n   */_validateExistingTitleElement(){if(isFastBoot){return;}(0,_ember_debug__WEBPACK_IMPORTED_MODULE_4__.assert)('[ember-page-title]: Multiple title elements found. Check for other addons like ember-cli-head updating <title> as well.',document.head.querySelectorAll('title').length<=1);}/**\n   * Find token by id\n   *\n   * @param {String} id\n   * @private\n   */_findTokenById(id){return this.tokens.find(token=>token.id===id);}updateFastbootTitle(toBeTitle){if(!isFastBoot){return;}const headElement=this.document.head;const headChildNodes=headElement.childNodes;// Remove existing title elements from previous render cycle\nfor(let i=0;i<headChildNodes.length;i++){const node=headChildNodes[i];if(!node)continue;if(node.nodeName.toLowerCase()==='title'){headElement.removeChild(node);}}// Add title element with latest value\nconst titleEl=this.document.createElement('title');const titleContents=this.document.createTextNode(toBeTitle);titleEl.appendChild(titleContents);headElement.appendChild(titleEl);}// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntitleDidUpdate(_title){// default is empty, meant to be overriden by user if desired\n}},_descriptor=(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__._)(_class.prototype,\"router\",[_dec],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor2=(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__._)(_class.prototype,\"document\",[_dec2],{configurable:true,enumerable:true,writable:true,initializer:null}),_class);\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-page-title/dist/services/page-title.js?\n}");

/***/ }),

/***/ "./node_modules/ember-resolver/addon/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ember-resolver/addon/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ModuleRegistry: () => (/* binding */ ModuleRegistry),\n/* harmony export */   \"default\": () => (/* binding */ Resolver)\n/* harmony export */ });\n/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./string */ \"./node_modules/ember-resolver/addon/string/index.js\");\n/* harmony import */ var _utils_class_factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/class-factory */ \"./node_modules/ember-resolver/addon/utils/class-factory.js\");\nfunction _defineProperty(e,r,t){return(r=_toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\";}function _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}class ModuleRegistry{constructor(entries){this._entries=entries||globalThis.requirejs.entries;}moduleNames(){return Object.keys(this._entries);}has(moduleName){return moduleName in this._entries;}get(...args){return globalThis.require(...args);}}/**\n * This module defines a subclass of Ember.DefaultResolver that adds two\n * important features:\n *\n *  1) The resolver makes the container aware of es6 modules via the AMD\n *     output. The loader's _moduleEntries is consulted so that classes can be\n *     resolved directly via the module loader, without needing a manual\n *     `import`.\n *  2) is able to provide injections to classes that implement `extend`\n *     (as is typical with Ember).\n */class Resolver{static create(props){return new this(props);}/**\n   A listing of functions to test for moduleName's based on the provided\n   `parsedName`. This allows easy customization of additional module based\n   lookup patterns.\n\n   @property moduleNameLookupPatterns\n   @returns {Ember.Array}\n   */static withModules(explicitModules){var _Class;return _Class=class extends this{},_defineProperty(_Class,\"explicitModules\",explicitModules),_Class;}constructor(props){_defineProperty(this,\"moduleBasedResolver\",true);_defineProperty(this,\"_deprecatedPodModulePrefix\",false);_defineProperty(this,\"_normalizeCache\",Object.create(null));_defineProperty(this,\"moduleNameLookupPatterns\",[this.podBasedModuleName,this.podBasedComponentsInSubdir,this.mainModuleName,this.defaultModuleName,this.nestedColocationComponentModuleName]);Object.assign(this,props);if(!this._moduleRegistry){let explicitModules=this.constructor.explicitModules;if(explicitModules){this._moduleRegistry={moduleNames(){return Object.keys(explicitModules);},has(name){return Boolean(explicitModules[name]);},get(name){return explicitModules[name];},addModules(modules){explicitModules=Object.assign({},explicitModules,modules);}};}else{if(typeof globalThis.requirejs.entries==='undefined'){globalThis.requirejs.entries=globalThis.requirejs._eak_seen;}this._moduleRegistry=new ModuleRegistry();}}this.pluralizedTypes=this.pluralizedTypes||Object.create(null);if(!this.pluralizedTypes.config){this.pluralizedTypes.config='config';}}makeToString(factory,fullName){return''+this.namespace.modulePrefix+'@'+fullName+':';}shouldWrapInClassFactory(/* module, parsedName */){return false;}parseName(fullName){if(fullName.parsedName===true){return fullName;}let prefix,type,name;let fullNameParts=fullName.split('@');if(fullNameParts.length===3){if(fullNameParts[0].length===0){// leading scoped namespace: `@scope/pkg@type:name`\nprefix=`@${fullNameParts[1]}`;let prefixParts=fullNameParts[2].split(':');type=prefixParts[0];name=prefixParts[1];}else{// interweaved scoped namespace: `type:@scope/pkg@name`\nprefix=`@${fullNameParts[1]}`;type=fullNameParts[0].slice(0,-1);name=fullNameParts[2];}if(type==='template:components'){name=`components/${name}`;type='template';}}else if(fullNameParts.length===2){let prefixParts=fullNameParts[0].split(':');if(prefixParts.length===2){if(prefixParts[1].length===0){type=prefixParts[0];name=`@${fullNameParts[1]}`;}else{prefix=prefixParts[1];type=prefixParts[0];name=fullNameParts[1];}}else{let nameParts=fullNameParts[1].split(':');prefix=fullNameParts[0];type=nameParts[0];name=nameParts[1];}if(type==='template'&&prefix.lastIndexOf('components/',0)===0){name=`components/${name}`;prefix=prefix.slice(11);}}else{fullNameParts=fullName.split(':');type=fullNameParts[0];name=fullNameParts[1];}let fullNameWithoutType=name;let namespace=this.namespace;let root=namespace;return{parsedName:true,fullName:fullName,prefix:prefix||this.prefix({type:type}),type:type,fullNameWithoutType:fullNameWithoutType,name:name,root:root,resolveMethodName:'resolve'+(0,_string__WEBPACK_IMPORTED_MODULE_0__.classify)(type)};}resolveOther(parsedName){assert('`modulePrefix` must be defined',this.namespace.modulePrefix);let normalizedModuleName=this.findModuleName(parsedName);if(normalizedModuleName){let defaultExport=this._extractDefaultExport(normalizedModuleName,parsedName);if(defaultExport===undefined){throw new Error(` Expected to find: '${parsedName.fullName}' within '${normalizedModuleName}' but got 'undefined'. Did you forget to 'export default' within '${normalizedModuleName}'?`);}if(this.shouldWrapInClassFactory(defaultExport,parsedName)){defaultExport=(0,_utils_class_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(defaultExport);}return defaultExport;}}normalize(fullName){return this._normalizeCache[fullName]||(this._normalizeCache[fullName]=this._normalize(fullName));}resolve(fullName){if(fullName==='resolver:current'){return{create:()=>this};}let parsedName=this.parseName(fullName);let resolveMethodName=parsedName.resolveMethodName;let resolved;if(typeof this[resolveMethodName]==='function'){resolved=this[resolveMethodName](parsedName);}if(resolved==null){resolved=this.resolveOther(parsedName);}return resolved;}addModules(modules){if(!this._moduleRegistry.addModules){throw new Error(`addModules is only supported when your Resolver has been configured to use static modules via Resolver.withModules()`);}this._moduleRegistry.addModules(modules);}_normalize(fullName){// A) Convert underscores to dashes\n// B) Convert camelCase to dash-case, except for components (their\n//    templates) and helpers where we want to avoid shadowing camelCase\n//    expressions\n// C) replace `.` with `/` in order to make nested controllers work in the following cases\n//      1. `needs: ['posts/post']`\n//      2. `{{render \"posts/post\"}}`\n//      3. `this.render('posts/post')` from Route\nlet split=fullName.split(':');if(split.length>1){let type=split[0];if(type==='component'||type==='helper'||type==='modifier'||type==='template'&&split[1].indexOf('components/')===0){return type+':'+split[1].replace(/_/g,'-');}else{return type+':'+(0,_string__WEBPACK_IMPORTED_MODULE_0__.dasherize)(split[1].replace(/\\./g,'/'));}}else{return fullName;}}pluralize(type){return this.pluralizedTypes[type]||(this.pluralizedTypes[type]=type+'s');}podBasedLookupWithPrefix(podPrefix,parsedName){let fullNameWithoutType=parsedName.fullNameWithoutType;if(parsedName.type==='template'){fullNameWithoutType=fullNameWithoutType.replace(/^components\\//,'');}return podPrefix+'/'+fullNameWithoutType+'/'+parsedName.type;}podBasedModuleName(parsedName){let podPrefix=this.namespace.podModulePrefix||this.namespace.modulePrefix;return this.podBasedLookupWithPrefix(podPrefix,parsedName);}podBasedComponentsInSubdir(parsedName){let podPrefix=this.namespace.podModulePrefix||this.namespace.modulePrefix;podPrefix=podPrefix+'/components';if(parsedName.type==='component'||/^components/.test(parsedName.fullNameWithoutType)){return this.podBasedLookupWithPrefix(podPrefix,parsedName);}}resolveEngine(parsedName){let engineName=parsedName.fullNameWithoutType;let engineModule=engineName+'/engine';if(this._moduleRegistry.has(engineModule)){return this._extractDefaultExport(engineModule);}}resolveRouteMap(parsedName){let engineName=parsedName.fullNameWithoutType;let engineRoutesModule=engineName+'/routes';if(this._moduleRegistry.has(engineRoutesModule)){let routeMap=this._extractDefaultExport(engineRoutesModule);assert(`The route map for ${engineName} should be wrapped by 'buildRoutes' before exporting.`,routeMap.isRouteMap);return routeMap;}}resolveTemplate(parsedName){return this.resolveOther(parsedName);}mainModuleName(parsedName){if(parsedName.fullNameWithoutType==='main'){// if router:main or adapter:main look for a module with just the type first\nreturn parsedName.prefix+'/'+parsedName.type;}}defaultModuleName(parsedName){return parsedName.prefix+'/'+this.pluralize(parsedName.type)+'/'+parsedName.fullNameWithoutType;}nestedColocationComponentModuleName(parsedName){if(parsedName.type==='component'){return parsedName.prefix+'/'+this.pluralize(parsedName.type)+'/'+parsedName.fullNameWithoutType+'/index';}}prefix(parsedName){let tmpPrefix=this.namespace.modulePrefix;if(this.namespace[parsedName.type+'Prefix']){tmpPrefix=this.namespace[parsedName.type+'Prefix'];}return tmpPrefix;}findModuleName(parsedName){let moduleNameLookupPatterns=this.moduleNameLookupPatterns;let moduleName;for(let index=0,length=moduleNameLookupPatterns.length;index<length;index++){let item=moduleNameLookupPatterns[index];let tmpModuleName=item.call(this,parsedName);// allow treat all dashed and all underscored as the same thing\n// supports components with dashes and other stuff with underscores.\nif(tmpModuleName){tmpModuleName=this.chooseModuleName(tmpModuleName);}if(tmpModuleName&&this._moduleRegistry.has(tmpModuleName)){moduleName=tmpModuleName;}if(moduleName){return moduleName;}}}chooseModuleName(moduleName){let underscoredModuleName=(0,_string__WEBPACK_IMPORTED_MODULE_0__.underscore)(moduleName);if(moduleName!==underscoredModuleName&&this._moduleRegistry.has(moduleName)&&this._moduleRegistry.has(underscoredModuleName)){throw new TypeError(`Ambiguous module names: '${moduleName}' and '${underscoredModuleName}'`);}if(this._moduleRegistry.has(moduleName)){return moduleName;}else if(this._moduleRegistry.has(underscoredModuleName)){return underscoredModuleName;}}knownForType(type){let moduleKeys=this._moduleRegistry.moduleNames();let items=Object.create(null);for(let index=0,length=moduleKeys.length;index<length;index++){let moduleName=moduleKeys[index];let fullname=this.translateToContainerFullname(type,moduleName);if(fullname){items[fullname]=true;}}return items;}translateToContainerFullname(type,moduleName){let prefix=this.prefix({type});// Note: using string manipulation here rather than regexes for better performance.\n// pod modules\n// '^' + prefix + '/(.+)/' + type + '$'\nlet podPrefix=prefix+'/';let podSuffix='/'+type;let start=moduleName.indexOf(podPrefix);let end=moduleName.indexOf(podSuffix);if(start===0&&end===moduleName.length-podSuffix.length&&moduleName.length>podPrefix.length+podSuffix.length){return type+':'+moduleName.slice(start+podPrefix.length,end);}// non-pod modules\n// '^' + prefix + '/' + pluralizedType + '/(.+)$'\nlet pluralizedType=this.pluralize(type);let nonPodPrefix=prefix+'/'+pluralizedType+'/';if(moduleName.indexOf(nonPodPrefix)===0&&moduleName.length>nonPodPrefix.length){return type+':'+moduleName.slice(nonPodPrefix.length);}}_extractDefaultExport(normalizedModuleName){let module=this._moduleRegistry.get(normalizedModuleName,null,null,true/* force sync */);if(module&&module['default']){module=module['default'];}return module;}}_defineProperty(Resolver,\"moduleBasedResolver\",true);function assert(message,check){if(!check){throw new Error(message);}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-resolver/addon/index.js?\n}");

/***/ }),

/***/ "./node_modules/ember-resolver/addon/string/cache.js":
/*!***********************************************************!*\
  !*** ./node_modules/ember-resolver/addon/string/cache.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Cache)\n/* harmony export */ });\nclass Cache{constructor(limit,func,store){this.limit=limit;this.func=func;this.store=store;this.size=0;this.misses=0;this.hits=0;this.store=store||new Map();}get(key){let value=this.store.get(key);if(this.store.has(key)){this.hits++;return this.store.get(key);}else{this.misses++;value=this.set(key,this.func(key));}return value;}set(key,value){if(this.limit>this.size){this.size++;this.store.set(key,value);}return value;}purge(){this.store.clear();this.size=0;this.hits=0;this.misses=0;}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-resolver/addon/string/cache.js?\n}");

/***/ }),

/***/ "./node_modules/ember-resolver/addon/string/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ember-resolver/addon/string/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   classify: () => (/* binding */ classify),\n/* harmony export */   dasherize: () => (/* binding */ dasherize),\n/* harmony export */   decamelize: () => (/* binding */ decamelize),\n/* harmony export */   getString: () => (/* binding */ getString),\n/* harmony export */   getStrings: () => (/* binding */ getStrings),\n/* harmony export */   setStrings: () => (/* binding */ setStrings),\n/* harmony export */   underscore: () => (/* binding */ underscore)\n/* harmony export */ });\n/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cache */ \"./node_modules/ember-resolver/addon/string/cache.js\");\n/* eslint-disable no-useless-escape */let STRINGS={};function setStrings(strings){STRINGS=strings;}function getStrings(){return STRINGS;}function getString(name){return STRINGS[name];}const STRING_DASHERIZE_REGEXP=/[ _]/g;const STRING_DASHERIZE_CACHE=new _cache__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1000,key=>decamelize(key).replace(STRING_DASHERIZE_REGEXP,'-'));const STRING_CLASSIFY_REGEXP_1=/^(\\-|_)+(.)?/;const STRING_CLASSIFY_REGEXP_2=/(.)(\\-|\\_|\\.|\\s)+(.)?/g;const STRING_CLASSIFY_REGEXP_3=/(^|\\/|\\.)([a-z])/g;const CLASSIFY_CACHE=new _cache__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1000,str=>{const replace1=(_match,_separator,chr)=>chr?`_${chr.toUpperCase()}`:'';const replace2=(_match,initialChar,_separator,chr)=>initialChar+(chr?chr.toUpperCase():'');const parts=str.split('/');for(let i=0;i<parts.length;i++){parts[i]=parts[i].replace(STRING_CLASSIFY_REGEXP_1,replace1).replace(STRING_CLASSIFY_REGEXP_2,replace2);}return parts.join('/').replace(STRING_CLASSIFY_REGEXP_3,(match/*, separator, chr */)=>match.toUpperCase());});const STRING_UNDERSCORE_REGEXP_1=/([a-z\\d])([A-Z]+)/g;const STRING_UNDERSCORE_REGEXP_2=/\\-|\\s+/g;const UNDERSCORE_CACHE=new _cache__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1000,str=>str.replace(STRING_UNDERSCORE_REGEXP_1,'$1_$2').replace(STRING_UNDERSCORE_REGEXP_2,'_').toLowerCase());const STRING_DECAMELIZE_REGEXP=/([a-z\\d])([A-Z])/g;const DECAMELIZE_CACHE=new _cache__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1000,str=>str.replace(STRING_DECAMELIZE_REGEXP,'$1_$2').toLowerCase());/**\n  Converts a camelized string into all lower case separated by underscores.\n\n  ```javascript\n  import { decamelize } from '@ember/string';\n\n  decamelize('innerHTML');          // 'inner_html'\n  decamelize('action_name');        // 'action_name'\n  decamelize('css-class-name');     // 'css-class-name'\n  decamelize('my favorite items');  // 'my favorite items'\n  ```\n\n  @method decamelize\n  @param {String} str The string to decamelize.\n  @return {String} the decamelized string.\n  @public\n*/function decamelize(str){return DECAMELIZE_CACHE.get(str);}/**\n  Replaces underscores, spaces, or camelCase with dashes.\n\n  ```javascript\n  import { dasherize } from '@ember/string';\n\n  dasherize('innerHTML');                // 'inner-html'\n  dasherize('action_name');              // 'action-name'\n  dasherize('css-class-name');           // 'css-class-name'\n  dasherize('my favorite items');        // 'my-favorite-items'\n  dasherize('privateDocs/ownerInvoice';  // 'private-docs/owner-invoice'\n  ```\n\n  @method dasherize\n  @param {String} str The string to dasherize.\n  @return {String} the dasherized string.\n  @public\n*/function dasherize(str){return STRING_DASHERIZE_CACHE.get(str);}/**\n  Returns the UpperCamelCase form of a string.\n\n  ```javascript\n  import { classify } from '@ember/string';\n\n  classify('innerHTML');                   // 'InnerHTML'\n  classify('action_name');                 // 'ActionName'\n  classify('css-class-name');              // 'CssClassName'\n  classify('my favorite items');           // 'MyFavoriteItems'\n  classify('private-docs/owner-invoice');  // 'PrivateDocs/OwnerInvoice'\n  ```\n\n  @method classify\n  @param {String} str the string to classify\n  @return {String} the classified string\n  @public\n*/function classify(str){return CLASSIFY_CACHE.get(str);}/**\n  More general than decamelize. Returns the lower\\_case\\_and\\_underscored\n  form of a string.\n\n  ```javascript\n  import { underscore } from '@ember/string';\n\n  underscore('innerHTML');                 // 'inner_html'\n  underscore('action_name');               // 'action_name'\n  underscore('css-class-name');            // 'css_class_name'\n  underscore('my favorite items');         // 'my_favorite_items'\n  underscore('privateDocs/ownerInvoice');  // 'private_docs/owner_invoice'\n  ```\n\n  @method underscore\n  @param {String} str The string to underscore.\n  @return {String} the underscored string.\n  @public\n*/function underscore(str){return UNDERSCORE_CACHE.get(str);}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-resolver/addon/string/index.js?\n}");

/***/ }),

/***/ "./node_modules/ember-resolver/addon/utils/class-factory.js":
/*!******************************************************************!*\
  !*** ./node_modules/ember-resolver/addon/utils/class-factory.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ classFactory)\n/* harmony export */ });\nfunction classFactory(klass){return{create(injections){if(typeof klass.extend==='function'){return klass.extend(injections);}else{return klass;}}};}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-resolver/addon/utils/class-factory.js?\n}");

/***/ }),

/***/ "./node_modules/ember-welcome-page/dist/components/welcome-page.css":
/*!**************************************************************************!*\
  !*** ./node_modules/ember-welcome-page/dist/components/welcome-page.css ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_cjs_js_welcome_page_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!./welcome-page.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/ember-welcome-page/dist/components/welcome-page.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_welcome_page_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_welcome_page_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-welcome-page/dist/components/welcome-page.css?\n}");

/***/ }),

/***/ "./node_modules/ember-welcome-page/dist/components/welcome-page.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ember-welcome-page/dist/components/welcome-page.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WelcomePageComponent)\n/* harmony export */ });\n/* harmony import */ var _ember_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/component */ \"@ember/component\");\n/* harmony import */ var _ember_component__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_component__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/application */ \"@ember/application\");\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_application__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ember_version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember/version */ \"@ember/version\");\n/* harmony import */ var _ember_version__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ember_version__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _glimmer_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @glimmer/component */ \"./node_modules/@glimmer/component/dist/index.js\");\n/* harmony import */ var _welcome_page_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./welcome-page.css */ \"./node_modules/ember-welcome-page/dist/components/welcome-page.css\");\n/* harmony import */ var _ember_template_factory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ember/template-factory */ \"@ember/template-factory\");\n/* harmony import */ var _ember_template_factory__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_ember_template_factory__WEBPACK_IMPORTED_MODULE_5__);\nvar TEMPLATE=(0,_ember_template_factory__WEBPACK_IMPORTED_MODULE_5__.createTemplateFactory)(/*\n  <main id=\"ember-welcome-page-id-selector\">\n  <div class=\"columns\">\n    <div class=\"tomster\">\n      <img src=\"{{this.rootURL}}ember-welcome-page/images/construction.png\" alt=\"Under construction\">\n    </div>\n    <div class=\"welcome\">\n      <h1 id=\"title\">Congratulations, you made it!</h1>\n\n      <p>You&rsquo;ve officially spun up your Ember app. You&rsquo;ve got one more decision to make: what do you want to do next? We&rsquo;d suggest one of the following to help you get going:</p>\n      <ul>\n        <li><a href=\"{{this.urlForEmberGuides}}/getting-started/quick-start/\">Quick Start</a> - a quick introduction to how Ember works. Learn about defining your first route, writing a UI component and deploying your application.</li>\n        <li><a href=\"{{this.urlForEmberGuides}}/tutorial/\">Tutorial</a> - this is our more thorough, hands-on intro to Ember. Your crash course in Ember philosophy, background and some in-depth discussion of how things work (and why they work the way they do).</li>\n      </ul>\n      <p>If you run into problems, please join <a href=\"https://discord.gg/emberjs\">our community's Discord server</a> or visit <a href=\"http://discuss.emberjs.com/\">our forums</a> for ideas and answers— our community is filled with friendly folks who are willing to help! We enjoy helping new Ember developers get started, and our <a href=\"https://emberjs.com/community/\">Ember Community</a> is incredibly supportive.</p>\n    </div>\n  </div>\n  <p class=\"postscript\">To remove this welcome message, remove the\n    <code>\n      &lt;WelcomePage /&gt;\n    </code>\n    component from your\n    <code>\n      app/templates/application.hbs\n    </code>\n    file and save it...you'll see this page update soon after!\n  </p>\n</main>\n\n\n*/{\"id\":\"r8b/QxFX\",\"block\":\"[[[10,\\\"main\\\"],[14,1,\\\"ember-welcome-page-id-selector\\\"],[12],[1,\\\"\\\\n  \\\"],[10,0],[14,0,\\\"columns\\\"],[12],[1,\\\"\\\\n    \\\"],[10,0],[14,0,\\\"tomster\\\"],[12],[1,\\\"\\\\n      \\\"],[10,\\\"img\\\"],[15,\\\"src\\\",[29,[[30,0,[\\\"rootURL\\\"]],\\\"ember-welcome-page/images/construction.png\\\"]]],[14,\\\"alt\\\",\\\"Under construction\\\"],[12],[13],[1,\\\"\\\\n    \\\"],[13],[1,\\\"\\\\n    \\\"],[10,0],[14,0,\\\"welcome\\\"],[12],[1,\\\"\\\\n      \\\"],[10,\\\"h1\\\"],[14,1,\\\"title\\\"],[12],[1,\\\"Congratulations, you made it!\\\"],[13],[1,\\\"\\\\n\\\\n      \\\"],[10,2],[12],[1,\\\"You’ve officially spun up your Ember app. You’ve got one more decision to make: what do you want to do next? We’d suggest one of the following to help you get going:\\\"],[13],[1,\\\"\\\\n      \\\"],[10,\\\"ul\\\"],[12],[1,\\\"\\\\n        \\\"],[10,\\\"li\\\"],[12],[10,3],[15,6,[29,[[30,0,[\\\"urlForEmberGuides\\\"]],\\\"/getting-started/quick-start/\\\"]]],[12],[1,\\\"Quick Start\\\"],[13],[1,\\\" - a quick introduction to how Ember works. Learn about defining your first route, writing a UI component and deploying your application.\\\"],[13],[1,\\\"\\\\n        \\\"],[10,\\\"li\\\"],[12],[10,3],[15,6,[29,[[30,0,[\\\"urlForEmberGuides\\\"]],\\\"/tutorial/\\\"]]],[12],[1,\\\"Tutorial\\\"],[13],[1,\\\" - this is our more thorough, hands-on intro to Ember. Your crash course in Ember philosophy, background and some in-depth discussion of how things work (and why they work the way they do).\\\"],[13],[1,\\\"\\\\n      \\\"],[13],[1,\\\"\\\\n      \\\"],[10,2],[12],[1,\\\"If you run into problems, please join \\\"],[10,3],[14,6,\\\"https://discord.gg/emberjs\\\"],[12],[1,\\\"our community's Discord server\\\"],[13],[1,\\\" or visit \\\"],[10,3],[14,6,\\\"http://discuss.emberjs.com/\\\"],[12],[1,\\\"our forums\\\"],[13],[1,\\\" for ideas and answers— our community is filled with friendly folks who are willing to help! We enjoy helping new Ember developers get started, and our \\\"],[10,3],[14,6,\\\"https://emberjs.com/community/\\\"],[12],[1,\\\"Ember Community\\\"],[13],[1,\\\" is incredibly supportive.\\\"],[13],[1,\\\"\\\\n    \\\"],[13],[1,\\\"\\\\n  \\\"],[13],[1,\\\"\\\\n  \\\"],[10,2],[14,0,\\\"postscript\\\"],[12],[1,\\\"To remove this welcome message, remove the\\\\n    \\\"],[10,\\\"code\\\"],[12],[1,\\\"\\\\n      <WelcomePage />\\\\n    \\\"],[13],[1,\\\"\\\\n    component from your\\\\n    \\\"],[10,\\\"code\\\"],[12],[1,\\\"\\\\n      app/templates/application.hbs\\\\n    \\\"],[13],[1,\\\"\\\\n    file and save it...you'll see this page update soon after!\\\\n  \\\"],[13],[1,\\\"\\\\n\\\"],[13],[1,\\\"\\\\n\\\\n\\\"]],[],[\\\"main\\\",\\\"div\\\",\\\"img\\\",\\\"h1\\\",\\\"p\\\",\\\"ul\\\",\\\"li\\\",\\\"a\\\",\\\"code\\\"]]\",\"moduleName\":\"d:\\\\study\\\\projects\\\\bill maker\\\\bill-maker\\\\node_modules\\\\ember-welcome-page\\\\dist\\\\components\\\\welcome-page.js\",\"isStrictMode\":false});function isLatestVersion(){const stableRegex=/^\\d+\\.\\d+\\.\\d+$/;return!stableRegex.test(_ember_version__WEBPACK_IMPORTED_MODULE_2__.VERSION);}/* eslint-disable-next-line @typescript-eslint/no-empty-interface */class WelcomePageComponent extends _glimmer_component__WEBPACK_IMPORTED_MODULE_3__[\"default\"]{get rootURL(){const config=(0,_ember_application__WEBPACK_IMPORTED_MODULE_1__.getOwner)(this).factoryFor('config:environment');if(config){return config.class.rootURL;}return'/';}get urlForEmberGuides(){if(isLatestVersion()){return`https://guides.emberjs.com/release`;}const[majorVersion,minorVersion]=_ember_version__WEBPACK_IMPORTED_MODULE_2__.VERSION.split('.');const emberVersion=`${majorVersion}.${minorVersion}.0`;return`https://guides.emberjs.com/v${emberVersion}`;}}(0,_ember_component__WEBPACK_IMPORTED_MODULE_0__.setComponentTemplate)(TEMPLATE,WelcomePageComponent);\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-welcome-page/dist/components/welcome-page.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?\n}");

/***/ })

}]);