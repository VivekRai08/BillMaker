import { isResourceSchema } from './types/schema/fields.js';
import { E as withSignalStore, Q as isExtensionProp, T as performExtensionSet, G as consumeInternalSignal, U as performArrayExtensionGet, x as entangleSignal, V as performObjectExtensionGet, d as SOURCE$1, f as fastPush, y as defineSignal, l as RelatedCollection, H as getOrCreateInternalSignal, F as notifyInternalSignal, A as Signals, h as setRecordIdentifier, r as recordIdentifierFor } from "./request-state-CjLph1LP.js";
import { EnableHydration, STRUCTURED } from './types/request.js';
import { macroCondition, getGlobalConfig } from '@embroider/macros';
import { deprecate } from '@ember/debug';
import './utils/string.js';
import { A as ARRAY_SIGNAL, O as OBJECT_SIGNAL, c as createMemo } from "./configure-B48bFHOl.js";
import { RecordStore, Type } from './types/symbols.js';
import { getOrSetGlobal } from './types/-private.js';
import { S as SOURCE, E as Editable, L as Legacy, I as Identifier, P as Parent, a as EmbeddedPath, D as Destroy, C as Checkout, b as EmbeddedField } from "./symbols-SIstXMLI.js";
import './index.js';
const ARRAY_GETTER_METHODS = new Set([Symbol.iterator, 'concat', 'entries', 'every', 'fill', 'filter', 'find', 'findIndex', 'flat', 'flatMap', 'forEach', 'includes', 'indexOf', 'join', 'keys', 'lastIndexOf', 'map', 'reduce', 'reduceRight', 'slice', 'some', 'values']);
// const ARRAY_SETTER_METHODS = new Set<KeyType>(['push', 'pop', 'unshift', 'shift', 'splice', 'sort']);
const SYNC_PROPS = new Set(['[]', 'length']);
function isArrayGetter(prop) {
  return ARRAY_GETTER_METHODS.has(prop);
}
const ARRAY_SETTER_METHODS = new Set(['push', 'pop', 'unshift', 'shift', 'splice', 'sort']);
function isArraySetter(prop) {
  return ARRAY_SETTER_METHODS.has(prop);
}

// function isSelfProp<T extends object>(self: T, prop: KeyType): prop is keyof T {
//   return prop in self;
// }

function convertToInt(prop) {
  if (typeof prop === 'symbol') return null;
  const num = Number(prop);
  if (isNaN(num)) return null;
  return num % 1 === 0 ? num : null;
}
function safeForEach(instance, arr, store, callback, target) {
  if (target === undefined) {
    target = null;
  }
  // clone to prevent mutation
  arr = arr.slice();
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error('`forEach` expects a function as first argument.');
    }
  })(typeof callback === 'function') : {};

  // because we retrieveLatest above we need not worry if array is mutated during iteration
  // by unloadRecord/rollbackAttributes
  // push/add/removeObject may still be problematic
  // but this is a more traditionally expected forEach bug.
  const length = arr.length; // we need to access length to ensure we are consumed

  for (let index = 0; index < length; index++) {
    callback.call(target, arr[index], index, instance);
  }
  return instance;
}
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class ManagedArray {
  constructor(store, schema, cache, field, data, identifier, path, owner, isSchemaArray, editable, legacy) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const self = this;
    this[SOURCE] = data?.slice();
    const IS_EDITABLE = this[Editable] = editable ?? false;
    this[Legacy] = legacy;
    const signals = withSignalStore(this);
    let _SIGNAL = null;
    const boundFns = new Map();
    this.identifier = identifier;
    this.path = path;
    this.owner = owner;
    let transaction = false;
    const mode = field.options?.key ?? '@identity';
    const RefStorage = mode === '@identity' ? WeakMap :
    // CAUTION CAUTION CAUTION
    // this is a pile of lies
    // the Map is Map<string, WeakRef<ReactiveResource>>
    // but TS does not understand how to juggle modes like this
    // internal to a method like ours without us duplicating the code
    // into two separate methods.
    Map;
    const ManagedRecordRefs = isSchemaArray ? new RefStorage() : null;
    const extensions = legacy ? schema.CAUTION_MEGA_DANGER_ZONE_arrayExtensions(field) : null;
    const proxy = new Proxy(this[SOURCE], {
      get(target, prop, receiver) {
        if (prop === ARRAY_SIGNAL) {
          return _SIGNAL;
        }
        if (prop === 'identifier') {
          return self.identifier;
        }
        if (prop === 'owner') {
          return self.owner;
        }
        const index = convertToInt(prop);
        if (_SIGNAL.isStale && (index !== null || SYNC_PROPS.has(prop) || isArrayGetter(prop))) {
          _SIGNAL.isStale = false;
          const newData = cache.getAttr(identifier, path);
          if (newData && newData !== self[SOURCE]) {
            self[SOURCE].length = 0;
            self[SOURCE].push(...newData);
          }
        }
        if (prop === 'length') {
          return consumeInternalSignal(_SIGNAL), target.length;
        }
        if (prop === '[]') return consumeInternalSignal(_SIGNAL), receiver;
        if (index !== null) {
          let val;
          if (mode === '@hash') {
            val = target[index];
            const hashField = schema.resource({
              type: field.type
            }).identity;
            const hashFn = schema.hashFn(hashField);
            val = hashFn(val, null, null);
          } else {
            // if mode is not @identity or @index, then access the key path.
            // we should assert that `mode` is a string
            // it should read directly from the cache value for that field (e.g. no derivation, no transformation)
            // and, we likely should lookup the associated field and throw an error IF
            // the given field does not exist OR
            // the field is anything other than a GenericField or LegacyAttributeField.
            if (mode !== '@identity' && mode !== '@index') {
              macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                if (!test) {
                  throw new Error('mode must be a string');
                }
              })(typeof mode === 'string') : {};
              const modeField = schema.resource({
                type: field.type
              }).fields.find(f => f.name === mode);
              macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                if (!test) {
                  throw new Error('field must exist in schema');
                }
              })(modeField) : {};
              macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                if (!test) {
                  throw new Error('field must be a GenericField or LegacyAttributeField');
                }
              })(modeField.kind === 'field' || modeField.kind === 'attribute') : {};
            }
            val = mode === '@identity' ? target[index] : mode === '@index' ? '@index' : target[index][mode];
          }
          if (isSchemaArray) {
            if (!transaction) {
              consumeInternalSignal(_SIGNAL);
            }
            if (val) {
              const recordRef = ManagedRecordRefs.get(val);
              let record = recordRef?.deref();
              if (!record) {
                const recordPath = path.slice();
                // this is a dirty lie since path is string[] but really we
                // should change the types for paths to `Array<string | number>`
                // TODO we should allow the schema for the field to define a "key"
                // for stability. Default should be `@identity` which means that
                // same object reference from cache should result in same ReactiveResource
                // embedded object.
                recordPath.push(index);
                const recordIdentifier = self.owner[Identifier] || self.owner[Parent];
                record = new ReactiveResource(store, recordIdentifier, {
                  [Editable]: self.owner[Editable],
                  [Legacy]: self.owner[Legacy]
                }, true, field, recordPath);
                // if mode is not @identity or @index, then access the key path now
                // to determine the key value.
                // chris says we can implement this as a special kind `@hash` which
                // would be a function that only has access to the cache value and not
                // the record itself, so derivation is possible but intentionally limited
                // and non-reactive?
                ManagedRecordRefs.set(val, new WeakRef(record));
              }
              return record;
            }
            return val;
          }
          if (!transaction) {
            consumeInternalSignal(_SIGNAL);
          }
          if (field.type) {
            const transform = schema.transformation(field);
            return transform.hydrate(val, field.options ?? null, self.owner);
          }
          return val;
        }
        if (isArrayGetter(prop)) {
          let fn = boundFns.get(prop);
          if (fn === undefined) {
            if (prop === 'forEach') {
              fn = function () {
                consumeInternalSignal(_SIGNAL);
                transaction = true;
                const result = safeForEach(receiver, target, store, arguments[0], arguments[1]);
                transaction = false;
                return result;
              };
            } else {
              fn = function () {
                consumeInternalSignal(_SIGNAL);
                // array functions must run through Reflect to work properly
                // binding via other means will not work.
                transaction = true;
                const result = Reflect.apply(target[prop], receiver, arguments);
                transaction = false;
                return result;
              };
            }
            boundFns.set(prop, fn);
          }
          return fn;
        }
        if (isArraySetter(prop)) {
          let fn = boundFns.get(prop);
          if (fn === undefined) {
            fn = function () {
              if (!IS_EDITABLE) {
                throw new Error(`Mutating this array via ${String(prop)} is not allowed because the record is not editable`);
              }
              consumeInternalSignal(_SIGNAL);
              transaction = true;
              const result = Reflect.apply(target[prop], receiver, arguments);
              transaction = false;
              return result;
            };
            boundFns.set(prop, fn);
          }
          return fn;
        }
        if (isExtensionProp(extensions, prop)) {
          return performArrayExtensionGet(receiver, extensions, signals, prop, _SIGNAL, boundFns, v => void (transaction = v));
        }
        return Reflect.get(target, prop, receiver);
      },
      set(target, prop, value, receiver) {
        if (!IS_EDITABLE) {
          let errorPath = identifier.type;
          if (path) {
            errorPath = path[path.length - 1];
          }
          throw new Error(`Cannot set ${String(prop)} on ${errorPath} because the record is not editable`);
        }
        if (prop === 'identifier') {
          self.identifier = value;
          return true;
        }
        if (prop === 'owner') {
          self.owner = value;
          return true;
        }
        if (isExtensionProp(extensions, prop)) {
          return performExtensionSet(receiver, extensions, signals, prop, value);
        }
        const reflect = Reflect.set(target, prop, value, receiver);
        if (reflect) {
          if (!field.type) {
            cache.setAttr(identifier, path, self[SOURCE]);
            _SIGNAL.isStale = true;
            return true;
          }
          let rawValue = self[SOURCE];
          if (!isSchemaArray) {
            const transform = schema.transformation(field);
            if (!transform) {
              throw new Error(`No '${field.type}' transform defined for use by ${identifier.type}.${String(prop)}`);
            }
            rawValue = self[SOURCE].map(item => transform.serialize(item, field.options ?? null, self.owner));
          }
          cache.setAttr(identifier, path, rawValue);
          _SIGNAL.isStale = true;
        }
        return reflect;
      },
      has(target, prop) {
        if (prop === 'identifier' || prop === 'owner' || prop === ARRAY_SIGNAL) {
          return true;
        }
        return Reflect.has(target, prop);
      }
    });

    // we entangle the signal on the returned proxy since that is
    // the object that other code will be interfacing with.
    _SIGNAL = entangleSignal(signals, proxy, ARRAY_SIGNAL, undefined);
    return proxy;
  }
}

// this will error if someone tries to call
// A(identifierArray) since it is not configurable
// which is preferable to the `meta` override we used
// before which required importing all of Ember
const desc = {
  enumerable: true,
  configurable: false,
  get: function () {
    // here to support computed chains
    // and {{#each}}
    if (macroCondition(getGlobalConfig().WarpDrive.deprecations.DEPRECATE_COMPUTED_CHAINS)) {
      return this;
    }
  }
};
// compat(desc);
Object.defineProperty(ManagedArray.prototype, '[]', desc);
const ObjectSymbols = new Set([OBJECT_SIGNAL, Parent, SOURCE, Editable, EmbeddedPath]);

// const ignoredGlobalFields = new Set<string>(['setInterval', 'nodeType', 'nodeName', 'length', 'document', STRUCTURED]);

// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class ManagedObject {
  constructor(schema, cache, field, data, identifier, path, owner, editable, legacy) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const self = this;
    this[SOURCE] = {
      ...data
    };
    const signals = withSignalStore(this);
    const _SIGNAL = this[OBJECT_SIGNAL] = entangleSignal(signals, this, OBJECT_SIGNAL, undefined);
    this[Editable] = editable;
    this[Legacy] = legacy;
    this[Parent] = identifier;
    this[EmbeddedPath] = path;

    // prettier-ignore
    const extensions = !legacy ? null : schema.CAUTION_MEGA_DANGER_ZONE_objectExtensions(field);
    const proxy = new Proxy(this[SOURCE], {
      ownKeys() {
        return Object.keys(self[SOURCE]);
      },
      has(target, prop) {
        return prop in self[SOURCE];
      },
      getOwnPropertyDescriptor(target, prop) {
        return {
          writable: editable,
          enumerable: true,
          configurable: true
        };
      },
      get(target, prop, receiver) {
        if (ObjectSymbols.has(prop)) {
          return self[prop];
        }
        if (prop === Symbol.toPrimitive) {
          return () => null;
        }
        if (prop === Symbol.toStringTag) {
          return `ManagedObject<${identifier.type}:${identifier.id} (${identifier.lid})>`;
        }
        if (prop === 'constructor') {
          return Object;
        }
        if (prop === 'toString') {
          return function () {
            return `ManagedObject<${identifier.type}:${identifier.id} (${identifier.lid})>`;
          };
        }
        if (prop === 'toHTML') {
          return function () {
            return '<span>ManagedObject</span>';
          };
        }
        if (_SIGNAL.isStale) {
          _SIGNAL.isStale = false;
          let newData = cache.getAttr(identifier, path);
          if (newData && newData !== self[SOURCE]) {
            if (field.type) {
              const transform = schema.transformation(field);
              newData = transform.hydrate(newData, field.options ?? null, owner);
            }
            self[SOURCE] = {
              ...newData
            }; // Add type assertion for newData
          }
        }

        // toJSON and extensions need to come after we update data if stale
        if (prop === 'toJSON') {
          return function () {
            return structuredClone(self[SOURCE]);
          };
        }

        // we always defer to data before extensions
        if (prop in self[SOURCE]) {
          consumeInternalSignal(_SIGNAL);
          return self[SOURCE][prop];
        }
        if (isExtensionProp(extensions, prop)) {
          return performObjectExtensionGet(receiver, extensions, signals, prop);
        }
        return Reflect.get(target, prop, receiver);
      },
      set(target, prop, value, receiver) {
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`Cannot set read-only property '${String(prop)}' on ManagedObject`);
          }
        })(editable) : {};

        // since objects function as dictionaries, we can't defer to schema/data before extensions
        // unless the prop is in the existing data.
        if (!(prop in self[SOURCE]) && isExtensionProp(extensions, prop)) {
          return performExtensionSet(receiver, extensions, signals, prop, value);
        }
        const reflect = Reflect.set(target, prop, value, receiver);
        if (!reflect) {
          return false;
        }
        if (!field.type) {
          cache.setAttr(identifier, path, self[SOURCE]);
        } else {
          const transform = schema.transformation(field);
          const val = transform.serialize(self[SOURCE], field.options ?? null, owner);
          cache.setAttr(identifier, path, val);
        }
        _SIGNAL.isStale = true;
        return true;
      }
    });
    return proxy;
  }
}
class ManyArrayManager {
  constructor(record, editable) {
    this.record = record;
    this.store = record[RecordStore];
    this.identifier = record[Identifier];
    this.editable = editable;
  }
  _syncArray(array) {
    const method = this.editable ? 'getRelationship' : 'getRemoteRelationship';
    const rawValue = this.store.cache[method](this.identifier, array.key);
    if (rawValue.meta) {
      array.meta = rawValue.meta;
    }
    if (rawValue.links) {
      array.links = rawValue.links;
    }
    const currentState = array[SOURCE$1];

    // unlike in the normal RecordArray case, we don't need to divorce the reference
    // because we don't need to worry about associate/disassociate since the graph
    // takes care of that for us
    if (currentState !== rawValue.data) {
      currentState.length = 0;
      fastPush(currentState, rawValue.data);
    }
  }
  reloadHasMany(key, options) {
    const field = this.store.schema.fields(this.identifier).get(key);
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected a hasMany field for ${key}`);
      }
    })(field?.kind === 'hasMany') : {};
    const cacheOptions = options ? extractCacheOptions(options) : {
      reload: true
    };
    cacheOptions.types = [field.type];
    const rawValue = this.store.cache.getRelationship(this.identifier, key);
    const req = {
      url: getRelatedLink(rawValue),
      op: 'findHasMany',
      method: 'GET',
      records: rawValue.data,
      cacheOptions,
      options: {
        field,
        identifier: this.identifier,
        links: rawValue.links,
        meta: rawValue.meta
      },
      [EnableHydration]: false
    };
    return this.store.request(req);
  }
  mutate(mutation) {
    this.store.cache.mutate(mutation);
  }
}
function getRelatedLink(resource) {
  const related = resource.links?.related;
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`Expected a related link`);
    }
  })(related) : {};
  return typeof related === 'object' ? related.href : related;
}
function extractCacheOptions(options) {
  const cacheOptions = {};
  if ('reload' in options) {
    cacheOptions.reload = options.reload;
  }
  if ('backgroundReload' in options) {
    cacheOptions.backgroundReload = options.backgroundReload;
  }
  return cacheOptions;
}
const ManagedArrayMap = getOrSetGlobal('ManagedArrayMap', new Map());
const ManagedObjectMap = getOrSetGlobal('ManagedObjectMap', new Map());
function computeLocal(record, field, prop) {
  const signals = withSignalStore(record);
  const signal = getOrCreateInternalSignal(signals, record, prop, field.options?.defaultValue ?? null);
  consumeInternalSignal(signal);
  return signal.value;
}
function peekManagedArray(record, field) {
  const managedArrayMapForRecord = ManagedArrayMap.get(record);
  if (managedArrayMapForRecord) {
    return managedArrayMapForRecord.get(field.name);
  }
}
function peekManagedObject(record, field) {
  const managedObjectMapForRecord = ManagedObjectMap.get(record);
  if (managedObjectMapForRecord) {
    return managedObjectMapForRecord.get(field.name);
  }
}
function computeField(schema, cache, record, identifier, field, prop, editable) {
  const rawValue = editable ? cache.getAttr(identifier, prop) : cache.getRemoteAttr(identifier, prop);
  if (!field.type) {
    return rawValue;
  }
  const transform = schema.transformation(field);
  return transform.hydrate(rawValue, field.options ?? null, record);
}
function computeArray(store, schema, cache, record, identifier, field, path, editable, legacy) {
  const isSchemaArray = field.kind === 'schema-array';
  // the thing we hand out needs to know its owner and path in a private manner
  // its "address" is the parent identifier (identifier) + field name (field.name)
  //  in the nested object case field name here is the full dot path from root resource to this value
  // its "key" is the field on the parent record
  // its "owner" is the parent record

  const managedArrayMapForRecord = ManagedArrayMap.get(record);
  let managedArray;
  if (managedArrayMapForRecord) {
    managedArray = managedArrayMapForRecord.get(field.name);
  }
  if (managedArray) {
    return managedArray;
  } else {
    const rawValue = editable ? cache.getAttr(identifier, path) : cache.getRemoteAttr(identifier, path);
    if (!rawValue) {
      return null;
    }
    managedArray = new ManagedArray(store, schema, cache, field, rawValue, identifier, path, record, isSchemaArray, editable, legacy);
    if (!managedArrayMapForRecord) {
      ManagedArrayMap.set(record, new Map([[field.name, managedArray]]));
    } else {
      managedArrayMapForRecord.set(field.name, managedArray);
    }
  }
  return managedArray;
}
function computeObject(schema, cache, record, identifier, field, path, editable, legacy) {
  const managedObjectMapForRecord = ManagedObjectMap.get(record);
  let managedObject;
  if (managedObjectMapForRecord) {
    managedObject = managedObjectMapForRecord.get(field.name);
  }
  if (managedObject) {
    return managedObject;
  } else {
    let rawValue = editable ? cache.getAttr(identifier, path) : cache.getRemoteAttr(identifier, path);
    if (!rawValue) {
      return null;
    }
    if (field.type) {
      const transform = schema.transformation(field);
      rawValue = transform.hydrate(rawValue, field.options ?? null, record);
    }
    managedObject = new ManagedObject(schema, cache, field, rawValue, identifier, path, record, editable, legacy);
    if (!managedObjectMapForRecord) {
      ManagedObjectMap.set(record, new Map([[field.name, managedObject]]));
    } else {
      managedObjectMapForRecord.set(field.name, managedObject);
    }
  }
  return managedObject;
}
function computeSchemaObject(store, cache, record, identifier, field, path, legacy, editable) {
  const schemaObjectMapForRecord = ManagedObjectMap.get(record);
  let schemaObject;
  if (schemaObjectMapForRecord) {
    schemaObject = schemaObjectMapForRecord.get(field.name);
  }
  if (schemaObject) {
    return schemaObject;
  } else {
    const rawValue = editable ? cache.getAttr(identifier, path) : cache.getRemoteAttr(identifier, path);
    if (!rawValue) {
      return null;
    }
    const embeddedPath = path.slice();
    schemaObject = new ReactiveResource(store, identifier, {
      [Editable]: editable,
      [Legacy]: legacy
    }, true, field, embeddedPath);
  }
  if (!schemaObjectMapForRecord) {
    ManagedObjectMap.set(record, new Map([[field.name, schemaObject]]));
  } else {
    schemaObjectMapForRecord.set(field.name, schemaObject);
  }
  return schemaObject;
}
function computeAttribute(cache, identifier, prop, editable) {
  return editable ? cache.getAttr(identifier, prop) : cache.getRemoteAttr(identifier, prop);
}
function computeDerivation(schema, record, identifier, field, prop) {
  return schema.derivation(field)(record, field.options ?? null, prop);
}
// TODO probably this should just be a Document
// but its separate until we work out the lid situation
class ResourceRelationship {
  constructor(store, cache, parent, identifier, field, name, editable) {
    const rawValue = editable ? cache.getRelationship(identifier, name) : cache.getRemoteRelationship(identifier, name);

    // TODO setup true lids for relationship documents
    // @ts-expect-error we need to give relationship documents a lid
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    this.lid = rawValue.lid ?? rawValue.links?.self ?? `relationship:${identifier.lid}.${name}`;
    this.data = rawValue.data ? store.peekRecord(rawValue.data) : null;
    this.name = name;
    if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
      this.links = Object.freeze(Object.assign({}, rawValue.links));
      this.meta = Object.freeze(Object.assign({}, rawValue.meta));
    } else {
      this.links = rawValue.links ?? {};
      this.meta = rawValue.meta ?? {};
    }
    this[RecordStore] = store;
    this[Parent] = parent;
  }
  fetch(options) {
    const url = options?.url ?? getHref(this.links.related) ?? getHref(this.links.self) ?? null;
    if (!url) {
      throw new Error(`Cannot ${options?.method ?? 'fetch'} ${this[Parent][Identifier].type}.${String(this.name)} because it has no related link`);
    }
    const request = Object.assign({
      url,
      method: 'GET'
    }, options);
    return this[RecordStore].request(request);
  }
}
defineSignal(ResourceRelationship.prototype, 'data', null);
defineSignal(ResourceRelationship.prototype, 'links', null);
defineSignal(ResourceRelationship.prototype, 'meta', null);
function getHref(link) {
  if (!link) {
    return null;
  }
  if (typeof link === 'string') {
    return link;
  }
  return link.href;
}
function computeResource(store, cache, parent, identifier, field, prop, editable) {
  if (field.kind !== 'resource') {
    throw new Error(`The schema for ${identifier.type}.${String(prop)} is not a resource relationship`);
  }
  return new ResourceRelationship(store, cache, parent, identifier, field, prop, editable);
}
function computeHasMany(store, schema, cache, record, identifier, field, path, editable, legacy) {
  // the thing we hand out needs to know its owner and path in a private manner
  // its "address" is the parent identifier (identifier) + field name (field.name)
  //  in the nested object case field name here is the full dot path from root resource to this value
  // its "key" is the field on the parent record
  // its "owner" is the parent record

  const managedArrayMapForRecord = ManagedArrayMap.get(record);
  let managedArray;
  if (managedArrayMapForRecord) {
    managedArray = managedArrayMapForRecord.get(field.name);
  }
  if (managedArray) {
    return managedArray;
  } else {
    const rawValue = cache.getRelationship(identifier, field.name);
    if (!rawValue) {
      return null;
    }
    managedArray = new RelatedCollection({
      store,
      type: field.type,
      identifier,
      cache,
      field: legacy ? field : undefined,
      // we divorce the reference here because ManyArray mutates the target directly
      // before sending the mutation op to the cache. We may be able to avoid this in the future
      identifiers: rawValue.data?.slice(),
      key: field.name,
      meta: rawValue.meta || null,
      links: rawValue.links || null,
      isPolymorphic: field.options.polymorphic ?? false,
      isAsync: field.options.async ?? false,
      // TODO: Grab the proper value
      _inverseIsAsync: false,
      // @ts-expect-error Typescript doesn't have a way for us to thread the generic backwards so it infers unknown instead of T
      manager: new ManyArrayManager(record, editable),
      isLoaded: true,
      allowMutation: editable
    });
    if (!managedArrayMapForRecord) {
      ManagedArrayMap.set(record, new Map([[field.name, managedArray]]));
    } else {
      managedArrayMapForRecord.set(field.name, managedArray);
    }
  }
  return managedArray;
}
const IgnoredGlobalFields = new Set(['length', 'nodeType', 'then', 'setInterval', 'document', STRUCTURED]);
const symbolList = [Destroy, RecordStore, Identifier, Editable, Parent, Checkout, Legacy, EmbeddedPath, EmbeddedField];
const RecordSymbols = new Set(symbolList);
function isPathMatch(a, b) {
  return a.length === b.length && a.every((v, i) => v === b[i]);
}
function isNonEnumerableProp(prop) {
  return prop === 'constructor' || prop === 'prototype' || prop === '__proto__' || prop === 'toString' || prop === 'toJSON' || prop === 'toHTML' || typeof prop === 'symbol';
}
const Editables = new WeakMap();
/**
 * A class that uses a the ResourceSchema for a ResourceType
 * and a ResouceKey to transform data from the cache into a rich, reactive
 * object.
 *
 * This class is not directly instantiable. To use it, you should
 * configure the store's `instantiateRecord` and `teardownRecord` hooks
 * with the matching hooks provided by this package.
 *
 * @hideconstructor
 * @public
 */
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class ReactiveResource {
  constructor(store, identifier, Mode, isEmbedded = false, embeddedField = null, embeddedPath = null) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const self = this;
    this[RecordStore] = store;
    if (isEmbedded) {
      this[Parent] = identifier;
    } else {
      this[Identifier] = identifier;
    }
    const IS_EDITABLE = this[Editable] = Mode[Editable] ?? false;
    this[Legacy] = Mode[Legacy] ?? false;
    const schema = store.schema;
    const cache = store.cache;
    const identityField = schema.resource(isEmbedded ? embeddedField : identifier).identity;
    const BoundFns = new Map();

    // prettier-ignore
    const extensions = !Mode[Legacy] ? null : isEmbedded ? schema.CAUTION_MEGA_DANGER_ZONE_objectExtensions(embeddedField) : schema.CAUTION_MEGA_DANGER_ZONE_resourceExtensions(identifier);
    this[EmbeddedField] = embeddedField;
    this[EmbeddedPath] = embeddedPath;
    const fields = isEmbedded ? schema.fields(embeddedField) : schema.fields(identifier);
    const signals = withSignalStore(this);
    const proxy = new Proxy(this, {
      ownKeys() {
        const identityKey = identityField?.name;
        const keys = Array.from(fields.keys());
        if (identityKey) {
          keys.unshift(identityKey);
        }
        return keys;
      },
      has(target, prop) {
        if (prop === Destroy || prop === Checkout) {
          return true;
        }
        return fields.has(prop);
      },
      getOwnPropertyDescriptor(target, prop) {
        const schemaForField = prop === identityField?.name ? identityField : fields.get(prop);
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`No field named ${String(prop)} on ${identifier.type}`);
          }
        })(schemaForField) : {};
        if (isNonEnumerableProp(prop)) {
          return {
            writable: false,
            enumerable: false,
            configurable: true
          };
        }
        switch (schemaForField.kind) {
          case 'derived':
            return {
              writable: false,
              enumerable: true,
              configurable: true
            };
          case '@id':
            return {
              writable: identifier.id === null,
              enumerable: true,
              configurable: true
            };
          case '@local':
          case 'field':
          case 'attribute':
          case 'resource':
          case 'alias':
          case 'belongsTo':
          case 'hasMany':
          case 'collection':
          case 'schema-array':
          case 'array':
          case 'schema-object':
          case 'object':
            return {
              writable: IS_EDITABLE,
              enumerable: true,
              configurable: true
            };
          default:
            return {
              writable: false,
              enumerable: false,
              configurable: false
            };
        }
      },
      get(target, prop, receiver) {
        if (RecordSymbols.has(prop)) {
          if (prop === Destroy) {
            return () => _DESTROY(receiver);
          }
          if (prop === Checkout) {
            return () => _CHECKOUT(receiver);
          }
          return target[prop];
        }
        if (prop === Signals) {
          return signals;
        }

        // TODO make this a symbol
        if (prop === '___notifications') {
          return target.___notifications;
        }

        // ReactiveResource reserves use of keys that begin with these characters
        // for its own usage.
        // _, @, $, *

        const maybeField = prop === identityField?.name ? identityField : fields.get(prop);
        if (!maybeField) {
          if (IgnoredGlobalFields.has(prop)) {
            return undefined;
          }

          /////////////////////////////////////////////////////////////
          //// Note these bound function behaviors are essentially ////
          //// built-in but overrideable derivations.              ////
          ////                                                     ////
          //// The bar for this has to be "basic expectations of   ////
          ///  an object" – very, very high                        ////
          /////////////////////////////////////////////////////////////

          if (prop === Symbol.toStringTag || prop === 'toString') {
            let fn = BoundFns.get('toString');
            if (!fn) {
              fn = function () {
                entangleSignal(signals, receiver, '@identity', null);
                return `Record<${identifier.type}:${identifier.id} (${identifier.lid})>`;
              };
              BoundFns.set(prop, fn);
            }
            return fn;
          }
          if (prop === 'toHTML') {
            let fn = BoundFns.get('toHTML');
            if (!fn) {
              fn = function () {
                entangleSignal(signals, receiver, '@identity', null);
                return `<span>Record<${identifier.type}:${identifier.id} (${identifier.lid})></span>`;
              };
              BoundFns.set(prop, fn);
            }
            return fn;
          }
          if (prop === 'toJSON') {
            let fn = BoundFns.get('toJSON');
            if (!fn) {
              fn = function () {
                const json = {};
                for (const key in receiver) {
                  json[key] = receiver[key];
                }
                return json;
              };
              BoundFns.set(prop, fn);
            }
            return fn;
          }
          if (prop === Symbol.toPrimitive) return () => null;
          if (prop === Symbol.iterator) {
            let fn = BoundFns.get(Symbol.iterator);
            if (!fn) {
              fn = function* () {
                for (const key in receiver) {
                  yield [key, receiver[key]];
                }
              };
              BoundFns.set(Symbol.iterator, fn);
            }
            return fn;
          }
          if (prop === 'constructor') {
            return ReactiveResource;
          }
          if (isExtensionProp(extensions, prop)) {
            return performObjectExtensionGet(receiver, extensions, signals, prop);
          }

          // too many things check for random symbols
          if (typeof prop === 'symbol') return undefined;
          macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
            {
              throw new Error(`No field named ${String(prop)} on ${isEmbedded ? embeddedField.type : identifier.type}`);
            }
          })() : {};
          return undefined;
        }
        const field = maybeField.kind === 'alias' ? maybeField.options : maybeField;
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`Alias fields cannot alias '@id' '@local' '@hash' or 'derived' fields`);
          }
        })(maybeField.kind !== 'alias' || !['@id', '@local', '@hash', 'derived'].includes(maybeField.options.kind)) : {};
        const propArray = isEmbedded ? embeddedPath.slice() : [];
        // we use the field.name instead of prop here because we want to use the cache-path not
        // the record path.
        propArray.push(field.name);
        // propArray.push(prop as string);

        switch (field.kind) {
          case '@id':
            entangleSignal(signals, receiver, '@identity', null);
            return identifier.id;
          case '@hash':
            // TODO pass actual cache value not {}
            return schema.hashFn(field)({}, field.options ?? null, field.name ?? null);
          case '@local':
            {
              return computeLocal(receiver, field, prop);
            }
          case 'field':
            entangleSignal(signals, receiver, field.name, null);
            return computeField(schema, cache, target, identifier, field, propArray, IS_EDITABLE);
          case 'attribute':
            entangleSignal(signals, receiver, field.name, null);
            return computeAttribute(cache, identifier, prop, IS_EDITABLE);
          case 'resource':
            entangleSignal(signals, receiver, field.name, null);
            return computeResource(store, cache, target, identifier, field, prop, IS_EDITABLE);
          case 'derived':
            return computeDerivation(schema, receiver, identifier, field, prop);
          case 'schema-array':
          case 'array':
            entangleSignal(signals, receiver, field.name, null);
            return computeArray(store, schema, cache, target, identifier, field, propArray, Mode[Editable], Mode[Legacy]);
          case 'object':
            entangleSignal(signals, receiver, field.name, null);
            return computeObject(schema, cache, target, identifier, field, propArray, Mode[Editable], Mode[Legacy]);
          case 'schema-object':
            entangleSignal(signals, receiver, field.name, null);
            // run transform, then use that value as the object to manage
            return computeSchemaObject(store, cache, target, identifier, field, propArray, Mode[Legacy], Mode[Editable]);
          case 'belongsTo':
            if (field.options.linksMode) {
              entangleSignal(signals, receiver, field.name, null);
              const rawValue = IS_EDITABLE ? cache.getRelationship(identifier, field.name) : cache.getRemoteRelationship(identifier, field.name);

              // eslint-disable-next-line @typescript-eslint/no-unsafe-return
              return rawValue.data ? store.peekRecord(rawValue.data) : null;
            }
            macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
              if (!test) {
                throw new Error(`Can only use belongsTo fields when the resource is in legacy mode`);
              }
            })(Mode[Legacy]) : {};
            entangleSignal(signals, receiver, field.name, null);
            return schema._kind('@legacy', 'belongsTo').get(store, receiver, identifier, field);
          case 'hasMany':
            if (field.options.linksMode) {
              entangleSignal(signals, receiver, field.name, null);
              return computeHasMany(store, schema, cache, target, identifier, field, propArray, Mode[Editable], Mode[Legacy]);
            }
            macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
              if (!test) {
                throw new Error(`Can only use hasMany fields when the resource is in legacy mode`);
              }
            })(Mode[Legacy]) : {};
            entangleSignal(signals, receiver, field.name, null);
            return schema._kind('@legacy', 'hasMany').get(store, receiver, identifier, field);
          default:
            throw new Error(`Field '${String(prop)}' on '${identifier.type}' has the unknown kind '${field.kind}'`);
        }
      },
      set(target, prop, value, receiver) {
        if (!IS_EDITABLE) {
          const type = isEmbedded ? embeddedField.type : identifier.type;
          throw new Error(`Cannot set ${String(prop)} on ${type} because the record is not editable`);
        }
        const maybeField = prop === identityField?.name ? identityField : fields.get(prop);
        if (!maybeField) {
          const type = isEmbedded ? embeddedField.type : identifier.type;
          if (isExtensionProp(extensions, prop)) {
            return performExtensionSet(receiver, extensions, signals, prop, value);
          }
          macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
            {
              throw new Error(`There is no settable field named ${String(prop)} on ${type}`);
            }
          })() : {};
          return false;
        }
        const field = maybeField.kind === 'alias' ? maybeField.options : maybeField;
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`Alias fields cannot alias '@id' '@local' '@hash' or 'derived' fields`);
          }
        })(maybeField.kind !== 'alias' || !['@id', '@local', '@hash', 'derived'].includes(maybeField.options.kind)) : {};
        const propArray = isEmbedded ? embeddedPath.slice() : [];
        // we use the field.name instead of prop here because we want to use the cache-path not
        // the record path.
        propArray.push(field.name);
        // propArray.push(prop as string);

        switch (field.kind) {
          case '@id':
            {
              macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                if (!test) {
                  throw new Error(`Expected to receive a string id`);
                }
              })(typeof value === 'string' && value.length) : {};
              const normalizedId = String(value);
              const didChange = normalizedId !== identifier.id;
              macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                if (!test) {
                  throw new Error(`Cannot set ${identifier.type} record's id to ${normalizedId}, because id is already ${identifier.id}`);
                }
              })(!didChange || identifier.id === null) : {};
              if (normalizedId !== null && didChange) {
                store._instanceCache.setRecordId(identifier, normalizedId);
                store.notifications.notify(identifier, 'identity');
              }
              return true;
            }
          case '@local':
            {
              const signal = getOrCreateInternalSignal(signals, receiver, prop, field.options?.defaultValue ?? null);
              if (signal.value !== value) {
                signal.value = value;
                notifyInternalSignal(signal);
              }
              return true;
            }
          case 'field':
            {
              if (!field.type) {
                cache.setAttr(identifier, propArray, value);
                return true;
              }
              const transform = schema.transformation(field);
              const rawValue = transform.serialize(value, field.options ?? null, target);
              cache.setAttr(identifier, propArray, rawValue);
              return true;
            }
          case 'attribute':
            {
              cache.setAttr(identifier, propArray, value);
              return true;
            }
          case 'array':
            {
              if (!field.type) {
                cache.setAttr(identifier, propArray, value?.slice());
                const peeked = peekManagedArray(self, field);
                if (peeked) {
                  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                    if (!test) {
                      throw new Error(`Expected the peekManagedArray for ${field.kind} to return a ManagedArray`);
                    }
                  })(ARRAY_SIGNAL in peeked) : {};
                  const arrSignal = peeked[ARRAY_SIGNAL];
                  arrSignal.isStale = true;
                }
                if (!Array.isArray(value)) {
                  ManagedArrayMap.delete(target);
                }
                return true;
              }
              const transform = schema.transformation(field);
              const rawValue = value.map(item => transform.serialize(item, field.options ?? null, target));
              cache.setAttr(identifier, propArray, rawValue);
              const peeked = peekManagedArray(self, field);
              if (peeked) {
                macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                  if (!test) {
                    throw new Error(`Expected the peekManagedArray for ${field.kind} to return a ManagedArray`);
                  }
                })(ARRAY_SIGNAL in peeked) : {};
                const arrSignal = peeked[ARRAY_SIGNAL];
                arrSignal.isStale = true;
              }
              return true;
            }
          case 'schema-array':
            {
              const arrayValue = value?.slice();
              if (!Array.isArray(arrayValue)) {
                ManagedArrayMap.delete(target);
              }
              cache.setAttr(identifier, propArray, arrayValue);
              const peeked = peekManagedArray(self, field);
              if (peeked) {
                macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                  if (!test) {
                    throw new Error(`Expected the peekManagedArray for ${field.kind} to return a ManagedArray`);
                  }
                })(ARRAY_SIGNAL in peeked) : {};
                const arrSignal = peeked[ARRAY_SIGNAL];
                arrSignal.isStale = true;
              }
              if (!Array.isArray(value)) {
                ManagedArrayMap.delete(target);
              }
              return true;
            }
          case 'object':
            {
              if (!field.type) {
                let newValue = value;
                if (value !== null) {
                  newValue = {
                    ...value
                  };
                } else {
                  ManagedObjectMap.delete(target);
                }
                cache.setAttr(identifier, propArray, newValue);
                const peeked = peekManagedObject(self, field);
                if (peeked) {
                  const objSignal = peeked[OBJECT_SIGNAL];
                  objSignal.isStale = true;
                }
                return true;
              }
              const transform = schema.transformation(field);
              const rawValue = transform.serialize({
                ...value
              }, field.options ?? null, target);
              cache.setAttr(identifier, propArray, rawValue);
              const peeked = peekManagedObject(self, field);
              if (peeked) {
                const objSignal = peeked[OBJECT_SIGNAL];
                objSignal.isStale = true;
              }
              return true;
            }
          case 'schema-object':
            {
              let newValue = value;
              if (value !== null) {
                macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                  if (!test) {
                    throw new Error(`Expected value to be an object`);
                  }
                })(typeof value === 'object') : {};
                newValue = {
                  ...value
                };
                const schemaFields = schema.fields({
                  type: field.type
                });
                for (const key of Object.keys(newValue)) {
                  if (!schemaFields.has(key)) {
                    throw new Error(`Field ${key} does not exist on schema object ${field.type}`);
                  }
                }
              } else {
                ManagedObjectMap.delete(target);
              }
              cache.setAttr(identifier, propArray, newValue);
              // const peeked = peekManagedObject(self, field);
              // if (peeked) {
              //   const objSignal = peeked[OBJECT_SIGNAL];
              //   objSignal.isStale = true;
              // }
              return true;
            }
          case 'derived':
            {
              throw new Error(`Cannot set ${String(prop)} on ${identifier.type} because it is derived`);
            }
          case 'belongsTo':
            macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
              if (!test) {
                throw new Error(`Can only use belongsTo fields when the resource is in legacy mode`);
              }
            })(Mode[Legacy]) : {};
            schema._kind('@legacy', 'belongsTo').set(store, receiver, identifier, field, value);
            return true;
          case 'hasMany':
            macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
              if (!test) {
                throw new Error(`Can only use hasMany fields when the resource is in legacy mode`);
              }
            })(Mode[Legacy]) : {};
            macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
              if (!test) {
                throw new Error(`You must pass an array of records to set a hasMany relationship`);
              }
            })(Array.isArray(value)) : {};
            schema._kind('@legacy', 'hasMany').set(store, receiver, identifier, field, value);
            return true;
          default:
            throw new Error(`Unknown field kind ${field.kind}`);
        }
      }
    });

    // what signal do we need for embedded record?
    this.___notifications = store.notifications.subscribe(identifier, (_, type, key) => {
      switch (type) {
        case 'identity':
          {
            if (isEmbedded || !identityField) return; // base paths never apply to embedded records

            if (identityField.name && identityField.kind === '@id') {
              const signal = signals.get('@identity');
              if (signal) {
                notifyInternalSignal(signal);
              }
            }
            break;
          }
        case 'attributes':
          if (key) {
            if (Array.isArray(key)) {
              if (!isEmbedded) return; // deep paths will be handled by embedded records
              // TODO we should have the notification manager
              // ensure it is safe for each callback to mutate this array
              if (isPathMatch(embeddedPath, key)) {
                // handle the notification
                // TODO we should likely handle this notification here
                // also we should add a LOGGING flag
                // eslint-disable-next-line no-console
                console.warn(`Notification unhandled for ${key.join(',')} on ${identifier.type}`, self);
                return;
              }

              // TODO we should add a LOGGING flag
              // console.log(`Deep notification skipped for ${key.join('.')} on ${identifier.type}`, self);
              // deep notify the key path
            } else {
              if (isEmbedded) return; // base paths never apply to embedded records

              // TODO determine what LOGGING flag to wrap this in if any
              // console.log(`Notification for ${key} on ${identifier.type}`, self);
              const signal = signals.get(key);
              if (signal) {
                notifyInternalSignal(signal);
              }
              const field = fields.get(key);
              if (field?.kind === 'array' || field?.kind === 'schema-array') {
                const peeked = peekManagedArray(self, field);
                if (peeked) {
                  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                    if (!test) {
                      throw new Error(`Expected the peekManagedArray for ${field.kind} to return a ManagedArray`);
                    }
                  })(ARRAY_SIGNAL in peeked) : {};
                  const arrSignal = peeked[ARRAY_SIGNAL];
                  notifyInternalSignal(arrSignal);
                }
              }
              if (field?.kind === 'object') {
                const peeked = peekManagedObject(self, field);
                if (peeked) {
                  const objSignal = peeked[OBJECT_SIGNAL];
                  notifyInternalSignal(objSignal);
                }
              }
            }
          }
          break;
        case 'relationships':
          if (key) {
            if (Array.isArray(key)) ;else {
              if (isEmbedded) return; // base paths never apply to embedded records

              const field = fields.get(key);
              macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                if (!test) {
                  throw new Error(`Expected relationshp ${key} to be the name of a field`);
                }
              })(field) : {};
              if (field.kind === 'belongsTo') {
                // TODO determine what LOGGING flag to wrap this in if any
                // console.log(`Notification for ${key} on ${identifier.type}`, self);
                const signal = signals.get(key);
                if (signal) {
                  notifyInternalSignal(signal);
                }
                // FIXME
              } else if (field.kind === 'resource') ;else if (field.kind === 'hasMany') {
                if (field.options.linksMode) {
                  const peeked = peekManagedArray(self, field);
                  if (peeked) {
                    notifyInternalSignal(peeked[ARRAY_SIGNAL]);
                  }
                  return;
                }
                macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                  if (!test) {
                    throw new Error(`Can only use hasMany fields when the resource is in legacy mode`);
                  }
                })(Mode[Legacy]) : {};
                if (schema._kind('@legacy', 'hasMany').notify(store, proxy, identifier, field)) {
                  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                    if (!test) {
                      throw new Error(`Expected options to exist on relationship meta`);
                    }
                  })(field.options) : {};
                  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
                    if (!test) {
                      throw new Error(`Expected async to exist on relationship meta options`);
                    }
                  })('async' in field.options) : {};
                  if (field.options.async) {
                    const signal = signals.get(key);
                    if (signal) {
                      notifyInternalSignal(signal);
                    }
                  }
                }
              } else if (field.kind === 'collection') ;
            }
          }
          break;
      }
    });
    if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
      Object.defineProperty(this, '__SHOW_ME_THE_DATA_(debug mode only)__', {
        enumerable: false,
        configurable: true,
        get() {
          const data = {};
          for (const key of fields.keys()) {
            data[key] = proxy[key];
          }
          return data;
        }
      });
    }
    return proxy;
  }
}
function _CHECKOUT(record) {
  // IF we are already the editable record, throw an error
  if (record[Editable]) {
    throw new Error(`Cannot checkout an already editable record`);
  }
  const editable = Editables.get(record);
  if (editable) {
    return Promise.resolve(editable);
  }
  const embeddedType = record[EmbeddedField];
  const embeddedPath = record[EmbeddedPath];
  const isEmbedded = embeddedType !== null && embeddedPath !== null;
  if (isEmbedded) {
    throw new Error(`Cannot checkout an embedded record (yet)`);
  }
  const editableRecord = new ReactiveResource(record[RecordStore], record[Identifier], {
    [Editable]: true,
    [Legacy]: record[Legacy]
  }, isEmbedded, embeddedType, embeddedPath);
  setRecordIdentifier(editableRecord, recordIdentifierFor(record));
  return Promise.resolve(editableRecord);
}
function _DESTROY(record) {
  if (record[Legacy]) {
    // @ts-expect-error
    record.isDestroying = true;
    // @ts-expect-error
    record.isDestroyed = true;
  }
  record[RecordStore].notifications.unsubscribe(record.___notifications);
}
function instantiateRecord(store, identifier, createArgs) {
  const schema = store.schema;
  const resourceSchema = schema.resource(identifier);
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`Expected a resource schema`);
    }
  })(isResourceSchema(resourceSchema)) : {};
  const isLegacy = resourceSchema?.legacy ?? false;
  const isEditable = isLegacy || store.cache.isNew(identifier);
  const record = new ReactiveResource(store, identifier, {
    [Editable]: isEditable,
    [Legacy]: isLegacy
  });
  if (createArgs) {
    Object.assign(record, createArgs);
  }
  return record;
}
function assertReactiveResource(record) {
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error('Expected a ReactiveResource');
    }
  })(record && typeof record === 'object' && Destroy in record) : {};
}
function teardownRecord(record) {
  assertReactiveResource(record);
  record[Destroy]();
}
const Support = getOrSetGlobal('Support', new WeakMap());
const ConstructorField = {
  type: '@constructor',
  name: 'constructor',
  kind: 'derived'
};
const TypeField = {
  type: '@identity',
  name: '$type',
  kind: 'derived',
  options: {
    key: 'type'
  }
};
const DefaultIdentityField = {
  name: 'id',
  kind: '@id'
};
function _constructor(record) {
  let state = Support.get(record);
  if (!state) {
    state = {};
    Support.set(record, state);
  }
  return state._constructor = state._constructor || {
    name: `ReactiveResource<${recordIdentifierFor(record).type}>`,
    get modelName() {
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        {
          throw new Error(`record.constructor.modelName is not available outside of legacy mode`);
        }
      })() : {};
      return undefined;
    }
  };
}
_constructor[Type] = '@constructor';

/**
 * Extensions allow providing non-schema driven behaviors to
 * reactive resources and arrays.
 */

const BannedKeys = ['constructor', '__proto__'];
function processExtension(extension) {
  const {
    kind,
    name
  } = extension;
  const features = new Map();
  const baseFeatures = typeof extension.features === 'function' ? extension.features.prototype : extension.features;
  for (const key of Object.getOwnPropertyNames(baseFeatures)) {
    if (BannedKeys.includes(key)) continue;
    const decl = Object.getOwnPropertyDescriptor(baseFeatures, key);
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected to find a declaration for ${key} on extension ${name}`);
      }
    })(decl) : {};
    if (decl.value) {
      const {
        value
      } = decl;
      features.set(key, typeof value === 'function' ? {
        kind: 'method',
        fn: value
      } : decl.writable ? {
        kind: 'mutable-value',
        value
      } : {
        kind: 'readonly-value',
        value
      });
      continue;
    }
    if (decl.get || decl.set) {
      const {
        get,
        set
      } = decl;
      features.set(key,
      // prettier-ignore
      get && set ? {
        kind: 'mutable-field',
        get,
        set
      } : get ? {
        kind: 'readonly-field',
        get
      } : {
        kind: 'writeonly-field',
        set: set
      });
      continue;
    }
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`The feature ${key} on extension ${name} is of an unknown variety.`);
      }
    })() : {};
  }
  return {
    kind,
    name,
    features
  };
}
function getExt(extCache, type, extName) {
  const ext = extCache[type].get(extName);
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`expected to have an extension named ${String(extName)} available for ${type}s`);
    }
  })(ext) : {};
  return ext?.features ?? null;
}
function hasObjectSchema(field) {
  return 'kind' in field && (field.kind === 'schema-array' || field.kind === 'schema-object');
}
function processExtensions(schema, field, scenario) {
  // if we're looking up extensions for a resource, there is no
  // merging required so if we have no objectExtensions
  // we are done.
  if (scenario === 'resource') {
    if (!('objectExtensions' in field || !field.objectExtensions?.length)) {
      return null;
    }
  }
  const type = scenario === 'resource' ? 'object' : scenario;
  const extCache = schema._extensions;
  const fieldCache = schema._cachedFieldExtensionsByField;
  if (fieldCache[type].has(field)) {
    return fieldCache[type].get(field);
  }

  // prettier-ignore
  const extensions = (scenario === 'resource' ? field.objectExtensions : scenario === 'object' ? field.options?.objectExtensions : field.options?.arrayExtensions) || null;

  // if we are a resource scenario, we know from the first check we do have extensions
  // if we are an object scenario, we can now return the resource scenario.
  // if we are an array scenario, there is nothing more to process.
  if (!extensions) {
    if (scenario === 'array') return null;
    if (!hasObjectSchema(field)) {
      return null;
    }
    return schema.CAUTION_MEGA_DANGER_ZONE_resourceExtensions(field);
  }

  // if we have made it here, we have extensions, lets check if there's
  // a cached version we can use
  const baseExtensions = scenario === 'resource' && hasObjectSchema(field) ? schema.CAUTION_MEGA_DANGER_ZONE_resourceExtensions(field) : scenario === 'object' && hasObjectSchema(field) ? schema.CAUTION_MEGA_DANGER_ZONE_resourceExtensions(field) : null;
  if (!baseExtensions && extensions.length === 1) {
    const value = getExt(extCache, type, extensions[0]);
    fieldCache[type].set(field, value);
    return value;
  }
  const features = new Map(baseExtensions);
  for (const extName of extensions) {
    const value = getExt(extCache, type, extName);
    if (value) {
      for (const [feature, desc] of value) {
        features.set(feature, desc);
      }
    }
  }
  const value = features.size ? features : null;
  fieldCache[type].set(field, value);
  return value;
}

/**
 * Utility for constructing a ResourceSchema with the recommended
 * fields for the PolarisMode experience.
 *
 * Using this requires registering the PolarisMode derivations
 *
 * ```ts
 * import { registerDerivations } from '@warp-drive/schema-record';
 *
 * registerDerivations(schema);
 * ```
 *
 * @public
 * @param schema
 * @return {PolarisResourceSchema}
 */
function withDefaults(schema) {
  schema.identity = schema.identity || DefaultIdentityField;

  // because fields gets iterated in definition order,
  // we add TypeField to the beginning so that it will
  // appear right next to the identity field
  schema.fields.unshift(TypeField);
  schema.fields.push(ConstructorField);
  return schema;
}
/**
 * A derivation that computes its value from the
 * record's identity.
 *
 * It can be used via a derived field definition like:
 *
 * ```ts
 * {
 *   kind: 'derived',
 *   name: 'id',
 *   type: '@identity',
 *   options: { key: 'id' }
 * }
 * ```
 *
 * Valid keys are `'id'`, `'lid'`, `'type'`, and `'^'`.
 *
 * `^` returns the entire identifier object.
 *
 * @public
 */
const fromIdentity = (record, options, key) => {
  const identifier = record[Identifier];
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`Cannot compute @identity for a record without an identifier`);
    }
  })(identifier) : {};
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`Expected to receive a key to compute @identity, but got ${String(options)}`);
    }
  })(options?.key && ['lid', 'id', 'type', '^'].includes(options.key)) : {};
  return options.key === '^' ? identifier : identifier[options.key];
};
fromIdentity[Type] = '@identity';

/**
 * Registers the default derivations for records that want
 * to use the PolarisMode defaults provided by
 *
 * ```ts
 * import { withDefaults } from '@warp-drive/schema-record';
 * ```
 *
 * @public
 * @param {SchemaService} schema
 */
function registerDerivations(schema) {
  schema.registerDerivation(fromIdentity);
  schema.registerDerivation(_constructor);
}
/**
 * Wraps a derivation in a new function with Derivation signature but that looks
 * up the value in the cache before recomputing.
 *
 * @internal
 */
function makeCachedDerivation(derivation) {
  const memoizedDerivation = (record, options, prop) => {
    const signals = withSignalStore(record);
    let signal = signals.get(prop);
    if (!signal) {
      signal = createMemo(record, prop, () => {
        return derivation(record, options, prop);
      }); // a total lie, for convenience of reusing the storage
      signals.set(prop, signal);
    }
    return signal();
  };
  memoizedDerivation[Type] = derivation[Type];
  return memoizedDerivation;
}
/**
 * A SchemaService designed to work with dynamically registered schemas.
 *
 * @class SchemaService
 * @public
 */
class SchemaService {
  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any

  /** @internal */

  /** @internal */

  /** @internal */

  constructor() {
    this._schemas = new Map();
    this._transforms = new Map();
    this._hashFns = new Map();
    this._derivations = new Map();
    this._traits = new Set();
    this._modes = new Map();
    this._extensions = {
      object: new Map(),
      array: new Map()
    };
    this._cachedFieldExtensionsByField = {
      object: new Map(),
      array: new Map()
    };
  }
  resourceTypes() {
    return Array.from(this._schemas.keys());
  }
  hasTrait(type) {
    return this._traits.has(type);
  }
  resourceHasTrait(resource, trait) {
    return this._schemas.get(resource.type).traits.has(trait);
  }
  transformation(field) {
    const kind = 'kind' in field ? field.kind : '<unknown kind>';
    const name = 'name' in field ? field.name : '<unknown name>';
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`'${kind}' fields cannot be transformed. Only fields of kind 'field' 'object' or 'array' can specify a transformation. Attempted to find '${field.type ?? '<unknown type>'}' on field '${name}'.`);
      }
    })(!('kind' in field) || ['field', 'object', 'array'].includes(kind)) : {};
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected the '${kind}' field '${name}' to specify a transformation via 'field.type', but none was present`);
      }
    })(field.type) : {};
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`No transformation registered with name '${field.type}' for '${kind}' field '${name}'`);
      }
    })(this._transforms.has(field.type)) : {};
    return this._transforms.get(field.type);
  }
  derivation(field) {
    const kind = 'kind' in field ? field.kind : '<unknown kind>';
    const name = 'name' in field ? field.name : '<unknown name>';
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`The '${kind}' field '${name}' is not derived and so cannot be used to lookup a derivation`);
      }
    })(!('kind' in field) || kind === 'derived') : {};
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected the '${kind}' field '${name}' to specify a derivation via 'field.type', but no value was present`);
      }
    })(field.type) : {};
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`No '${field.type}' derivation registered for use by the '${kind}' field '${name}'`);
      }
    })(this._derivations.has(field.type)) : {};
    return this._derivations.get(field.type);
  }
  hashFn(field) {
    const kind = 'kind' in field ? field.kind : '<unknown kind>';
    const name = 'name' in field ? field.name : '<unknown name>';
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`The '${kind}' field '${name}' is not a HashField and so cannot be used to lookup a hash function`);
      }
    })(!('kind' in field) || kind === '@hash') : {};
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected the '${kind}' field '${name}' to specify a hash function via 'field.type', but no value was present`);
      }
    })(field.type) : {};
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`No '${field.type}' hash function is registered for use by the '${kind}' field '${name}'`);
      }
    })(this._hashFns.has(field.type)) : {};
    return this._hashFns.get(field.type);
  }
  resource(resource) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`No resource registered with name '${resource.type}'`);
      }
    })(this._schemas.has(resource.type)) : {};
    return this._schemas.get(resource.type).original;
  }
  registerResources(schemas) {
    schemas.forEach(schema => {
      this.registerResource(schema);
    });
  }
  registerResource(schema) {
    const fields = new Map();
    const relationships = {};
    const attributes = {};
    schema.fields.forEach(field => {
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        if (!test) {
          throw new Error(`${field.kind} is not valid inside a ResourceSchema's fields.`);
        }
      })(
      // @ts-expect-error we are checking for mistakes at runtime
      field.kind !== '@id' && field.kind !== '@hash') : {};
      fields.set(field.name, field);
      if (field.kind === 'attribute') {
        attributes[field.name] = field;
      } else if (field.kind === 'belongsTo' || field.kind === 'hasMany') {
        relationships[field.name] = field;
      }
    });
    const traits = new Set(isResourceSchema(schema) ? schema.traits : []);
    traits.forEach(trait => {
      this._traits.add(trait);
    });
    const internalSchema = {
      original: schema,
      fields,
      relationships,
      attributes,
      traits
    };
    this._schemas.set(schema.type, internalSchema);
  }
  registerTransformation(transformation) {
    this._transforms.set(transformation[Type], transformation);
  }
  registerDerivation(derivation) {
    this._derivations.set(derivation[Type], makeCachedDerivation(derivation));
  }
  CAUTION_MEGA_DANGER_ZONE_registerExtension(extension) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`an extension named ${extension.name} for ${extension.kind} already exists!`);
      }
    })(!this._extensions[extension.kind].has(extension.name)) : {};
    this._extensions[extension.kind].set(extension.name, processExtension(extension));
  }
  CAUTION_MEGA_DANGER_ZONE_resourceExtensions(resource) {
    const schema = this.resource(resource);
    return processExtensions(this, schema, 'resource');
  }
  CAUTION_MEGA_DANGER_ZONE_objectExtensions(field) {
    return processExtensions(this, field, 'object');
  }
  CAUTION_MEGA_DANGER_ZONE_arrayExtensions(field) {
    return processExtensions(this, field, 'array');
  }

  /**
   * This is an internal method used to register behaviors for legacy mode.
   * It is not intended for public use.
   *
   * We do think a generalized `kind` registration system would be useful,
   * but we have not yet designed it.
   *
   * See https://github.com/emberjs/data/issues/9534
   *
   * @internal
   */
  _registerMode(mode, kinds) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Mode '${mode}' is already registered`);
      }
    })(!this._modes.has(mode)) : {};
    this._modes.set(mode, kinds);
  }

  /**
   * This is an internal method used to enable legacy behaviors for legacy mode.
   * It is not intended for public use.
   *
   * We do think a generalized `kind` registration system would be useful,
   * but we have not yet designed it.
   *
   * See https://github.com/emberjs/data/issues/9534
   *
   * @internal
   */
  _kind(mode, kind) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Mode '${mode}' is not registered`);
      }
    })(this._modes.has(mode)) : {};
    const kinds = this._modes.get(mode);
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Kind '${kind}' is not registered for mode '${mode}'`);
      }
    })(kinds[kind]) : {};
    return kinds[kind];
  }
  registerHashFn(hashFn) {
    this._hashFns.set(hashFn[Type], hashFn);
  }
  fields({
    type
  }) {
    const schema = this._schemas.get(type);
    if (!schema) {
      throw new Error(`No schema defined for ${type}`);
    }
    return schema.fields;
  }
  hasResource(resource) {
    return this._schemas.has(resource.type);
  }
}
if (macroCondition(getGlobalConfig().WarpDrive.deprecations.ENABLE_LEGACY_SCHEMA_SERVICE)) {
  SchemaService.prototype.attributesDefinitionFor = function ({
    type
  }) {
    deprecate(`Use \`schema.fields({ type })\` instead of \`schema.attributesDefinitionFor({ type })\``, false, {
      id: 'ember-data:schema-service-updates',
      until: '6.0',
      for: 'ember-data',
      since: {
        available: '4.13',
        enabled: '5.4'
      }
    });
    const schema = this._schemas.get(type);
    if (!schema) {
      throw new Error(`No schema defined for ${type}`);
    }
    return schema.attributes;
  };
  SchemaService.prototype.relationshipsDefinitionFor = function ({
    type
  }) {
    deprecate(`Use \`schema.fields({ type })\` instead of \`schema.relationshipsDefinitionFor({ type })\``, false, {
      id: 'ember-data:schema-service-updates',
      until: '6.0',
      for: 'ember-data',
      since: {
        available: '4.13',
        enabled: '5.4'
      }
    });
    const schema = this._schemas.get(type);
    if (!schema) {
      throw new Error(`No schema defined for ${type}`);
    }
    return schema.relationships;
  };
  SchemaService.prototype.doesTypeExist = function (type) {
    deprecate(`Use \`schema.hasResource({ type })\` instead of \`schema.doesTypeExist(type)\``, false, {
      id: 'ember-data:schema-service-updates',
      until: '6.0',
      for: 'ember-data',
      since: {
        available: '4.13',
        enabled: '5.4'
      }
    });
    return this._schemas.has(type);
  };
}
export { Checkout, SchemaService, fromIdentity, instantiateRecord, registerDerivations, teardownRecord, withDefaults };