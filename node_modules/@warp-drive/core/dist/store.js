import { deprecate } from '@ember/debug';
import { LRUCache } from './utils/string.js';
import { macroCondition, getGlobalConfig } from '@embroider/macros';
const NUMERIC_KEYS = new Set(['max-age', 's-maxage', 'stale-if-error', 'stale-while-revalidate']);

/**
 *  Parses a string Cache-Control header value into an object with the following structure:
 *
 * ```ts
 * interface CacheControlValue {
 *   immutable?: boolean;
 *   'max-age'?: number;
 *   'must-revalidate'?: boolean;
 *   'must-understand'?: boolean;
 *   'no-cache'?: boolean;
 *   'no-store'?: boolean;
 *   'no-transform'?: boolean;
 *   'only-if-cached'?: boolean;
 *   private?: boolean;
 *   'proxy-revalidate'?: boolean;
 *   public?: boolean;
 *   's-maxage'?: number;
 *   'stale-if-error'?: number;
 *   'stale-while-revalidate'?: number;
 * }
 * ```
 *
 * @public
 * @param {String} header
 * @return {CacheControlValue}
 */
function parseCacheControl(header) {
  return CACHE_CONTROL_CACHE.get(header);
}
const CACHE_CONTROL_CACHE = new LRUCache(header => {
  let key = '';
  let value = '';
  let isParsingKey = true;
  const cacheControlValue = {};
  for (let i = 0; i < header.length; i++) {
    const char = header.charAt(i);
    if (char === ',') {
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        if (!test) {
          throw new Error(`Invalid Cache-Control value, expected a value`);
        }
      })(!isParsingKey || !NUMERIC_KEYS.has(key)) : {};
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        if (!test) {
          throw new Error(`Invalid Cache-Control value, expected a value after "=" but got ","`);
        }
      })(i === 0 || header.charAt(i - 1) !== '=') : {};
      isParsingKey = true;
      // @ts-expect-error TS incorrectly thinks that optional keys must have a type that includes undefined
      cacheControlValue[key] = NUMERIC_KEYS.has(key) ? parseCacheControlValue(value) : true;
      key = '';
      value = '';
      continue;
    } else if (char === '=') {
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        if (!test) {
          throw new Error(`Invalid Cache-Control value, expected a value after "="`);
        }
      })(i + 1 !== header.length) : {};
      isParsingKey = false;
    } else if (char === ' ' || char === `\t` || char === `\n`) {
      continue;
    } else if (isParsingKey) {
      key += char;
    } else {
      value += char;
    }
    if (i === header.length - 1) {
      // @ts-expect-error TS incorrectly thinks that optional keys must have a type that includes undefined
      cacheControlValue[key] = NUMERIC_KEYS.has(key) ? parseCacheControlValue(value) : true;
    }
  }
  return cacheControlValue;
}, 200);
function parseCacheControlValue(stringToParse) {
  const parsedValue = Number.parseInt(stringToParse);
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`Invalid Cache-Control value, expected a number but got - ${stringToParse}`);
    }
  })(!Number.isNaN(parsedValue)) : {};
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`Invalid Cache-Control value, expected a number greater than 0 but got - ${stringToParse}`);
    }
  })(parsedValue >= 0) : {};
  if (Number.isNaN(parsedValue) || parsedValue < 0) {
    return 0;
  }
  return parsedValue;
}
function isExpired(identifier, request, config) {
  const {
    constraints
  } = config;
  if (constraints?.isExpired) {
    const result = constraints.isExpired(request);
    if (result !== null) {
      if (macroCondition(getGlobalConfig().WarpDrive.activeLogging.LOG_CACHE_POLICY)) {
        if (getGlobalConfig().WarpDrive.debug.LOG_CACHE_POLICY || globalThis.getWarpDriveRuntimeConfig().debug.LOG_CACHE_POLICY) {
          // eslint-disable-next-line no-console
          console.log(`CachePolicy: ${identifier.lid} is ${result ? 'EXPIRED' : 'NOT expired'} because constraints.isExpired returned ${result}`);
        }
      }
      return result;
    }
  }
  const {
    headers
  } = request.response;
  if (!headers) {
    if (macroCondition(getGlobalConfig().WarpDrive.activeLogging.LOG_CACHE_POLICY)) {
      if (getGlobalConfig().WarpDrive.debug.LOG_CACHE_POLICY || globalThis.getWarpDriveRuntimeConfig().debug.LOG_CACHE_POLICY) {
        // eslint-disable-next-line no-console
        console.log(`CachePolicy: ${identifier.lid} is EXPIRED because no headers were provided`);
      }
    }

    // if we have no headers then both the headers based expiration
    // and the time based expiration will be considered expired
    return true;
  }

  // check for X-WarpDrive-Expires
  const now = Date.now();
  const date = headers.get('Date');
  if (constraints?.headers) {
    if (constraints.headers['X-WarpDrive-Expires']) {
      const xWarpDriveExpires = headers.get('X-WarpDrive-Expires');
      if (xWarpDriveExpires) {
        const expirationTime = new Date(xWarpDriveExpires).getTime();
        const result = now >= expirationTime;
        if (macroCondition(getGlobalConfig().WarpDrive.activeLogging.LOG_CACHE_POLICY)) {
          if (getGlobalConfig().WarpDrive.debug.LOG_CACHE_POLICY || globalThis.getWarpDriveRuntimeConfig().debug.LOG_CACHE_POLICY) {
            // eslint-disable-next-line no-console
            console.log(`CachePolicy: ${identifier.lid} is ${result ? 'EXPIRED' : 'NOT expired'} because the time set by X-WarpDrive-Expires header is ${result ? 'in the past' : 'in the future'}`);
          }
        }
        return result;
      }
    }

    // check for Cache-Control
    if (constraints.headers['Cache-Control']) {
      const cacheControl = headers.get('Cache-Control');
      const age = headers.get('Age');
      if (cacheControl && age && date) {
        const cacheControlValue = parseCacheControl(cacheControl);

        // max-age and s-maxage are stored in
        const maxAge = cacheControlValue['max-age'] || cacheControlValue['s-maxage'];
        if (maxAge) {
          // age is stored in seconds
          const ageValue = parseInt(age, 10);
          macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
            if (!test) {
              throw new Error(`Invalid Cache-Control value, expected a number but got - ${age}`);
            }
          })(!Number.isNaN(ageValue)) : {};
          macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
            if (!test) {
              throw new Error(`Invalid Cache-Control value, expected a number greater than 0 but got - ${age}`);
            }
          })(ageValue >= 0) : {};
          if (!Number.isNaN(ageValue) && ageValue >= 0) {
            const dateValue = new Date(date).getTime();
            const expirationTime = dateValue + (maxAge - ageValue) * 1000;
            const result = now >= expirationTime;
            if (macroCondition(getGlobalConfig().WarpDrive.activeLogging.LOG_CACHE_POLICY)) {
              if (getGlobalConfig().WarpDrive.debug.LOG_CACHE_POLICY || globalThis.getWarpDriveRuntimeConfig().debug.LOG_CACHE_POLICY) {
                // eslint-disable-next-line no-console
                console.log(`CachePolicy: ${identifier.lid} is ${result ? 'EXPIRED' : 'NOT expired'} because the time set by Cache-Control header is ${result ? 'in the past' : 'in the future'}`);
              }
            }
            return result;
          }
        }
      }
    }

    // check for Expires
    if (constraints.headers.Expires) {
      const expires = headers.get('Expires');
      if (expires) {
        const expirationTime = new Date(expires).getTime();
        const result = now >= expirationTime;
        if (macroCondition(getGlobalConfig().WarpDrive.activeLogging.LOG_CACHE_POLICY)) {
          if (getGlobalConfig().WarpDrive.debug.LOG_CACHE_POLICY || globalThis.getWarpDriveRuntimeConfig().debug.LOG_CACHE_POLICY) {
            // eslint-disable-next-line no-console
            console.log(`CachePolicy: ${identifier.lid} is ${result ? 'EXPIRED' : 'NOT expired'} because the time set by Expires header is ${result ? 'in the past' : 'in the future'}`);
          }
        }
        return result;
      }
    }
  }

  // check for Date
  if (!date) {
    if (macroCondition(getGlobalConfig().WarpDrive.activeLogging.LOG_CACHE_POLICY)) {
      if (getGlobalConfig().WarpDrive.debug.LOG_CACHE_POLICY || globalThis.getWarpDriveRuntimeConfig().debug.LOG_CACHE_POLICY) {
        // eslint-disable-next-line no-console
        console.log(`CachePolicy: ${identifier.lid} is EXPIRED because no Date header was provided`);
      }
    }
    return true;
  }
  let expirationTime = config.apiCacheHardExpires;
  if (macroCondition(getGlobalConfig().WarpDrive.env.TESTING)) {
    if (!config.disableTestOptimization) {
      expirationTime = config.apiCacheSoftExpires;
    }
  }
  const time = new Date(date).getTime();
  const deadline = time + expirationTime;
  const result = now >= deadline;
  if (macroCondition(getGlobalConfig().WarpDrive.activeLogging.LOG_CACHE_POLICY)) {
    if (getGlobalConfig().WarpDrive.debug.LOG_CACHE_POLICY || globalThis.getWarpDriveRuntimeConfig().debug.LOG_CACHE_POLICY) {
      // eslint-disable-next-line no-console
      console.log(`CachePolicy: ${identifier.lid} is ${result ? 'EXPIRED' : 'NOT expired'} because the apiCacheHardExpires time since the response's Date header is ${result ? 'in the past' : 'in the future'}`);
    }
  }
  return result;
}

/**
 * The configuration options for the {@link DefaultCachePolicy}
 *
 * ```ts
 * import { DefaultCachePolicy } from '@warp-drive/core/store';
 *
 * new DefaultCachePolicy({
 *   // ... PolicyConfig Settings ... //
 * });
 * ```
 *
 */

/**
 * A basic CachePolicy that can be added to the Store service.
 *
 * Determines staleness based on time since the request was last received from the API
 * using the `date` header.
 *
 * Determines expiration based on configured constraints as well as a time based
 * expiration strategy based on the `date` header.
 *
 * In order expiration is determined by:
 *
 * - Is explicitly invalidated
 * -  ↳ (if null) isExpired function \<IF Constraint Active>
 * -  ↳ (if null) X-WarpDrive-Expires header \<IF Constraint Active>
 * -  ↳ (if null) Cache-Control header \<IF Constraint Active>
 * -  ↳ (if null) Expires header \<IF Constraint Active>
 * -  ↳ (if null) Date header + apiCacheHardExpires \< current time
 *
 * Invalidates any request for which `cacheOptions.types` was provided when a createRecord
 * request for that type is successful.
 *
 * For this to work, the `createRecord` request must include the `cacheOptions.types` array
 * with the types that should be invalidated, or its request should specify the identifiers
 * of the records that are being created via `records`. Providing both is valid.
 *
 * > [!NOTE]
 * > only requests that had specified `cacheOptions.types` and occurred prior to the
 * > createRecord request will be invalidated. This means that a given request should always
 * > specify the types that would invalidate it to opt into this behavior. Abstracting this
 * > behavior via builders is recommended to ensure consistency.
 *
 * This allows the Store's CacheHandler to determine if a request is expired and
 * should be refetched upon next request.
 *
 * The `Fetch` handler provided by `@warp-drive/core` will automatically
 * add the `date` header to responses if it is not present.
 *
 * > [!NOTE]
 * > Date headers do not have millisecond precision, so expiration times should
 * > generally be larger than 1000ms.
 *
 * Usage:
 *
 * ```ts
 * import { Store } from '@warp-drive/core';
 * import { DefaultCachePolicy } from '@warp-drive/core/store';
 *
 * export class AppStore extends Store {
 *   lifetimes = new DefaultCachePolicy({
 *     apiCacheSoftExpires: 30_000,
 *     apiCacheHardExpires: 60_000
 *   });
 * }
 * ```
 *
 * In Testing environments, the `apiCacheSoftExpires` will always be `false`
 * and `apiCacheHardExpires` will use the `apiCacheSoftExpires` value.
 *
 * This helps reduce flakiness and produce predictably rendered results in test suites.
 *
 * Requests that specifically set `cacheOptions.backgroundReload = true` will
 * still be background reloaded in tests.
 *
 * This behavior can be opted out of by setting `disableTestOptimization = true`
 * in the policy config.
 *
 * @public
 */
class DefaultCachePolicy {
  _getStore(store) {
    let set = this._stores.get(store);
    if (!set) {
      set = {
        invalidated: new Set(),
        types: new Map()
      };
      this._stores.set(store, set);
    }
    return set;
  }
  constructor(config) {
    this._stores = new WeakMap();
    const _config = arguments.length === 1 ? config : arguments[1];
    deprecate(`Passing a Store to the CachePolicy is deprecated, please pass only a config instead.`, arguments.length === 1, {
      id: 'ember-data:request-utils:lifetimes-service-store-arg',
      since: {
        enabled: '5.4',
        available: '4.13'
      },
      for: '@ember-data/request-utils',
      until: '6.0'
    });
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`You must pass a config to the CachePolicy`);
      }
    })(_config) : {};
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`You must pass a apiCacheSoftExpires to the CachePolicy`);
      }
    })(typeof _config.apiCacheSoftExpires === 'number') : {};
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`You must pass a apiCacheHardExpires to the CachePolicy`);
      }
    })(typeof _config.apiCacheHardExpires === 'number') : {};
    this.config = _config;
  }

  /**
   * Invalidate a request by its identifier for a given store instance.
   *
   * While the store argument may seem redundant, the CachePolicy
   * is designed to be shared across multiple stores / forks
   * of the store.
   *
   * ```ts
   * store.lifetimes.invalidateRequest(store, identifier);
   * ```
   *
   * @public
   * @param {StableDocumentIdentifier} identifier
   * @param {Store} store
   */
  invalidateRequest(identifier, store) {
    this._getStore(store).invalidated.add(identifier);
  }

  /**
   * Invalidate all requests associated to a specific type
   * for a given store instance.
   *
   * While the store argument may seem redundant, the CachePolicy
   * is designed to be shared across multiple stores / forks
   * of the store.
   *
   * This invalidation is done automatically when using this service
   * for both the CacheHandler and the LegacyNetworkHandler.
   *
   * ```ts
   * store.lifetimes.invalidateRequestsForType(store, 'person');
   * ```
   *
   * @public
   * @param {String} type
   * @param {Store} store
   */
  invalidateRequestsForType(type, store) {
    const storeCache = this._getStore(store);
    const set = storeCache.types.get(type);
    const notifications = store.notifications;
    if (set) {
      // TODO batch notifications
      set.forEach(id => {
        storeCache.invalidated.add(id);
        notifications.notify(id, 'invalidated');
      });
    }
  }

  /**
   * Invoked when a request has been fulfilled from the configured request handlers.
   * This is invoked by the CacheHandler for both foreground and background requests
   * once the cache has been updated.
   *
   * Note, this is invoked by the CacheHandler regardless of whether
   * the request has a cache-key.
   *
   * This method should not be invoked directly by consumers.
   *
   * @public
   * @param {ImmutableRequestInfo} request
   * @param {ImmutableResponse} response
   * @param {Store} store
   * @param {StableDocumentIdentifier | null} identifier
   * @return {void}
   */
  didRequest(request, response, identifier, store) {
    // if this is a successful createRecord request, invalidate the cacheKey for the type
    if (request.op === 'createRecord') {
      const statusNumber = response?.status ?? 0;
      if (statusNumber >= 200 && statusNumber < 400) {
        const types = new Set(request.records?.map(r => r.type));
        const additionalTypes = request.cacheOptions?.types;
        additionalTypes?.forEach(type => {
          types.add(type);
        });
        types.forEach(type => {
          this.invalidateRequestsForType(type, store);
        });
      }

      // add this document's cacheKey to a map for all associated types
      // it is recommended to only use this for queries
    } else if (identifier && request.cacheOptions?.types?.length) {
      const storeCache = this._getStore(store);
      request.cacheOptions?.types.forEach(type => {
        const set = storeCache.types.get(type);
        if (set) {
          set.add(identifier);
          storeCache.invalidated.delete(identifier);
        } else {
          storeCache.types.set(type, new Set([identifier]));
        }
      });
    }
  }

  /**
   * Invoked to determine if the request may be fulfilled from cache
   * if possible.
   *
   * Note, this is only invoked by the CacheHandler if the request has
   * a cache-key.
   *
   * If no cache entry is found or the entry is hard expired,
   * the request will be fulfilled from the configured request handlers
   * and the cache will be updated before returning the response.
   *
   * @public
   * @param {StableDocumentIdentifier} identifier
   * @param {Store} store
   * @return {Boolean} true if the request is considered hard expired
   */
  isHardExpired(identifier, store) {
    // if we are explicitly invalidated, we are hard expired
    const storeCache = this._getStore(store);
    if (storeCache.invalidated.has(identifier)) {
      return true;
    }
    const cache = store.cache;
    const cached = cache.peekRequest(identifier);
    if (!cached?.response) {
      if (macroCondition(getGlobalConfig().WarpDrive.activeLogging.LOG_CACHE_POLICY)) {
        if (getGlobalConfig().WarpDrive.debug.LOG_CACHE_POLICY || globalThis.getWarpDriveRuntimeConfig().debug.LOG_CACHE_POLICY) {
          // eslint-disable-next-line no-console
          console.log(`CachePolicy: ${identifier.lid} is EXPIRED because no cache entry was found`);
        }
      }
      return true;
    }
    return isExpired(identifier, cached, this.config);
  }

  /**
   * Invoked if `isHardExpired` is false to determine if the request
   * should be update behind the scenes if cache data is already available.
   *
   * Note, this is only invoked by the CacheHandler if the request has
   * a cache-key.
   *
   * If true, the request will be fulfilled from cache while a backgrounded
   * request is made to update the cache via the configured request handlers.
   *
   * @public
   * @param {StableDocumentIdentifier} identifier
   * @param {Store} store
   * @return {Boolean} true if the request is considered soft expired
   */
  isSoftExpired(identifier, store) {
    if (macroCondition(getGlobalConfig().WarpDrive.env.TESTING)) {
      if (!this.config.disableTestOptimization) {
        return false;
      }
    }
    const cache = store.cache;
    const cached = cache.peekRequest(identifier);
    if (cached?.response) {
      const date = cached.response.headers.get('date');
      if (!date) {
        if (macroCondition(getGlobalConfig().WarpDrive.activeLogging.LOG_CACHE_POLICY)) {
          if (getGlobalConfig().WarpDrive.debug.LOG_CACHE_POLICY || globalThis.getWarpDriveRuntimeConfig().debug.LOG_CACHE_POLICY) {
            // eslint-disable-next-line no-console
            console.log(`CachePolicy: ${identifier.lid} is STALE because no date header was found`);
          }
        }
        return true;
      } else {
        const time = new Date(date).getTime();
        const now = Date.now();
        const deadline = time + this.config.apiCacheSoftExpires;
        const result = now >= deadline;
        if (macroCondition(getGlobalConfig().WarpDrive.activeLogging.LOG_CACHE_POLICY)) {
          if (getGlobalConfig().WarpDrive.debug.LOG_CACHE_POLICY || globalThis.getWarpDriveRuntimeConfig().debug.LOG_CACHE_POLICY) {
            // eslint-disable-next-line no-console
            console.log(`CachePolicy: ${identifier.lid} is ${result ? 'STALE' : 'NOT stale'}. Expiration time: ${deadline}, now: ${now}`);
          }
        }
        return result;
      }
    }
    if (macroCondition(getGlobalConfig().WarpDrive.activeLogging.LOG_CACHE_POLICY)) {
      if (getGlobalConfig().WarpDrive.debug.LOG_CACHE_POLICY || globalThis.getWarpDriveRuntimeConfig().debug.LOG_CACHE_POLICY) {
        // eslint-disable-next-line no-console
        console.log(`CachePolicy: ${identifier.lid} is STALE because no cache entry was found`);
      }
    }
    return true;
  }
}
export { DefaultCachePolicy, parseCacheControl };