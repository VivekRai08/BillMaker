import { setLogging, getRuntimeConfig } from './types/runtime.js';
import { a as cloneResponseProperties, I as IS_CACHE_HANDLER, b as assertValidRequest, e as executeNextHandler, d as getRequestResult, u as upgradePromise, s as setPromiseResult, f as clearRequestResult } from "./context-COmAnXUQ.js";
import { macroCondition, getGlobalConfig } from '@embroider/macros';
import { w as waitFor } from "./configure-B48bFHOl.js";
import { peekUniversalTransient, setUniversalTransient } from './types/-private.js';
export { S as Store, r as recordIdentifierFor, N as setIdentifierForgetMethod, K as setIdentifierGenerationMethod, O as setIdentifierResetMethod, L as setIdentifierUpdateMethod, P as setKeyInfoForResource, s as storeFor } from "./request-state-CjLph1LP.js";
export { C as CacheHandler } from "./handler-C2T-IyJK.js";
import '@ember/debug';
import './utils/string.js';

// Lazily close over fetch to avoid breaking Mirage
const _fetch = typeof fetch !== 'undefined' ? (...args) => fetch(...args) : typeof FastBoot !== 'undefined' ? (...args) => FastBoot.require('node-fetch')(...args) : () => {
  throw new Error('No Fetch Implementation Found');
};

// clones a response in a way that should still
// allow it to stream
function cloneResponse(response, overrides) {
  const props = cloneResponseProperties(response);
  return new Response(response.body, Object.assign(props, overrides));
}
let IS_MAYBE_MIRAGE = () => false;
if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
  IS_MAYBE_MIRAGE = () => Boolean(typeof window !== 'undefined' && (window.server?.pretender || window.fetch.toString().replace(/\s+/g, '') !== 'function fetch() { [native code] }'.replace(/\s+/g, '')));
}
const MUTATION_OPS = new Set(['updateRecord', 'createRecord', 'deleteRecord']);
const ERROR_STATUS_CODE_FOR = new Map([[400, 'Bad Request'], [401, 'Unauthorized'], [402, 'Payment Required'], [403, 'Forbidden'], [404, 'Not Found'], [405, 'Method Not Allowed'], [406, 'Not Acceptable'], [407, 'Proxy Authentication Required'], [408, 'Request Timeout'], [409, 'Conflict'], [410, 'Gone'], [411, 'Length Required'], [412, 'Precondition Failed'], [413, 'Payload Too Large'], [414, 'URI Too Long'], [415, 'Unsupported Media Type'], [416, 'Range Not Satisfiable'], [417, 'Expectation Failed'], [419, 'Page Expired'], [420, 'Enhance Your Calm'], [421, 'Misdirected Request'], [422, 'Unprocessable Entity'], [423, 'Locked'], [424, 'Failed Dependency'], [425, 'Too Early'], [426, 'Upgrade Required'], [428, 'Precondition Required'], [429, 'Too Many Requests'], [430, 'Request Header Fields Too Large'], [431, 'Request Header Fields Too Large'], [450, 'Blocked By Windows Parental Controls'], [451, 'Unavailable For Legal Reasons'], [500, 'Internal Server Error'], [501, 'Not Implemented'], [502, 'Bad Gateway'], [503, 'Service Unavailable'], [504, 'Gateway Timeout'], [505, 'HTTP Version Not Supported'], [506, 'Variant Also Negotiates'], [507, 'Insufficient Storage'], [508, 'Loop Detected'], [509, 'Bandwidth Limit Exceeded'], [510, 'Not Extended'], [511, 'Network Authentication Required']]);

/**
 * ```ts
 * import { Fetch } from '@warp-drive/core';
 * ```
 *
 * A basic Fetch Handler which converts a request into a
 * `fetch` call presuming the response to be `json`.
 *
 * ```ts
 * import { RequestManager, Fetch } from '@warp-drive/core';
 *
 * const manager = new RequestManager()
 *   .use([Fetch]);
 * ```
 *
 * @public
 */
const Fetch = {
  async request(context) {
    let response;
    try {
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        if (!test) {
          throw new Error('The Fetch handler expects the request to have a URL, none was provided.');
        }
      })(context.request.url && typeof context.request.url === 'string') : {};
      response = await _fetch(context.request.url, context.request);
    } catch (e) {
      if (e instanceof DOMException && e.name === 'AbortError') {
        e.statusText = 'Aborted';
        e.status = 20;
        e.isRequestError = true;
      } else {
        e.statusText = 'Unknown Network Error';
        e.status = 0;
        e.isRequestError = true;
      }
      throw e;
    }
    const isError = !response.ok || response.status >= 400;
    const op = context.request.op;
    const isMutationOp = Boolean(op && MUTATION_OPS.has(op));
    if (!isError && !isMutationOp && response.status !== 204 && !response.headers.has('date')) {
      if (IS_MAYBE_MIRAGE()) {
        response.headers.set('date', new Date().toUTCString());
      } else {
        const headers = new Headers(response.headers);
        headers.set('date', new Date().toUTCString());
        response = cloneResponse(response, {
          headers
        });
      }
    }
    context.setResponse(response);
    if (response.status === 204) {
      return null;
    }
    let text = '';
    // if we are in a mirage context, we cannot support streaming
    if (IS_MAYBE_MIRAGE()) {
      text = await response.text();
    } else {
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let isStreaming = context.hasRequestedStream;
      let stream = isStreaming ? new TransformStream() : null;
      let writer = stream?.writable.getWriter();
      if (isStreaming) {
        // Listen for the abort event on the AbortSignal
        context.request.signal?.addEventListener('abort', () => {
          if (!isStreaming) {
            return;
          }
          void stream.writable.abort('Request Aborted');
          void stream.readable.cancel('Request Aborted');
        });
        context.setStream(stream.readable);
      }
      while (true) {
        // we manually read the stream instead of using `response.json()`
        // or `response.text()` because if we need to stream the body
        // we need to be able to pass the stream along efficiently.
        const {
          done,
          value
        } = await reader.read();
        if (done) {
          if (isStreaming) {
            isStreaming = false;
            await writer.ready;
            await writer.close();
          }
          break;
        }
        text += decoder.decode(value, {
          stream: true
        });

        // if we are streaming, we want to pass the stream along
        if (isStreaming) {
          await writer.ready;
          await writer.write(value);
        } else if (context.hasRequestedStream) {
          const encode = new TextEncoder();
          isStreaming = true;
          stream = new TransformStream();
          // Listen for the abort event on the AbortSignal
          // eslint-disable-next-line @typescript-eslint/no-loop-func
          context.request.signal?.addEventListener('abort', () => {
            if (!isStreaming) {
              return;
            }
            void stream.writable.abort('Request Aborted');
            void stream.readable.cancel('Request Aborted');
          });
          context.setStream(stream.readable);
          writer = stream.writable.getWriter();
          await writer.ready;
          await writer.write(encode.encode(text));
          await writer.ready;
          await writer.write(value);
        }
      }
      if (isStreaming) {
        isStreaming = false;
        await writer.ready;
        await writer.close();
      }
    }
    // if we are an error, we will want to throw
    if (isError) {
      let errorPayload;
      try {
        errorPayload = JSON.parse(text);
      } catch {
        // void;
      }
      // attempt errors discovery
      const errors = Array.isArray(errorPayload) ? errorPayload : isDict(errorPayload) && Array.isArray(errorPayload.errors) ? errorPayload.errors : null;
      const statusText = response.statusText || ERROR_STATUS_CODE_FOR.get(response.status) || 'Unknown Request Error';
      const msg = `[${response.status} ${statusText}] ${context.request.method ?? 'GET'} (${response.type}) - ${response.url}`;
      const error = errors ? new AggregateError(errors, msg) : new Error(msg);
      error.status = response.status;
      error.statusText = statusText;
      error.isRequestError = true;
      error.code = error.status;
      error.name = error.statusText.replaceAll(' ', '') + 'Error';
      error.content = errorPayload;
      throw error;
    } else {
      return JSON.parse(text);
    }
  }
};
function isDict(v) {
  return v !== null && typeof v === 'object';
}
class RequestManager {
  #handlers = [];
  /** @internal */

  /**
   * A map of pending requests from request.id to their
   * associated CacheHandler promise.
   *
   * This queue is managed by the CacheHandler
   *
   * @internal
   */

  /** @internal */

  constructor(options) {
    Object.assign(this, options);
    this._pending = new Map();
    this._deduped = new Map();
  }

  /**
   * Register a handler to use for primary cache intercept.
   *
   * Only one such handler may exist. If using the same
   * RequestManager as the Store instance the Store
   * registers itself as a Cache handler.
   *
   * @public
   */
  useCache(cacheHandler) {
    if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
      if (this._hasCacheHandler) {
        throw new Error(`\`RequestManager.useCache(<handler>)\` May only be invoked once.`);
      }
      if (Object.isFrozen(this.#handlers)) {
        throw new Error(`\`RequestManager.useCache(<handler>)\` May only be invoked prior to any request having been made.`);
      }
      this._hasCacheHandler = true;
    }
    cacheHandler[IS_CACHE_HANDLER] = true;
    this.#handlers.unshift(cacheHandler);
    return this;
  }

  /**
   * Register handler(s) to use when a request is issued.
   *
   * Handlers will be invoked in the order they are registered.
   * Each Handler is given the opportunity to handle the request,
   * curry the request, or pass along a modified request.
   *
   * @public
   * @param {Handler[]} newHandlers
   * @return {ThisType}
   */
  use(newHandlers) {
    const handlers = this.#handlers;
    if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
      if (Object.isFrozen(handlers)) {
        throw new Error(`Cannot add a Handler to a RequestManager after a request has been made`);
      }
      if (!Array.isArray(newHandlers)) {
        throw new Error(`\`RequestManager.use(<Handler[]>)\` expects an array of handlers, but was called with \`${typeof newHandlers}\``);
      }
      newHandlers.forEach((handler, index) => {
        if (!handler || typeof handler !== 'function' && typeof handler !== 'object' || typeof handler.request !== 'function') {
          throw new Error(`\`RequestManager.use(<Handler[]>)\` expected to receive an array of handler objects with request methods, by the handler at index ${index} does not conform.`);
        }
      });
    }
    handlers.push(...newHandlers);
    return this;
  }

  /**
   * Issue a Request.
   *
   * Returns a Future that fulfills with a StructuredDocument
   *
   * @public
   * @param {RequestInfo} request
   * @return {Future}
   */
  request(request) {
    const handlers = this.#handlers;
    if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
      if (!Object.isFrozen(handlers)) {
        Object.freeze(handlers);
      }
      assertValidRequest(request, true);
    }
    const controller = request.controller || new AbortController();
    if (request.controller) {
      delete request.controller;
    }
    const requestId = peekUniversalTransient('REQ_ID') ?? 0;
    setUniversalTransient('REQ_ID', requestId + 1);
    const context = {
      controller,
      response: null,
      stream: null,
      hasRequestedStream: false,
      id: requestId,
      identifier: null
    };
    const promise = executeNextHandler(handlers, request, 0, context);

    // the cache handler will set the result of the request synchronously
    // if it is able to fulfill the request from the cache
    const cacheResult = getRequestResult(requestId);
    if (macroCondition(getGlobalConfig().WarpDrive.env.TESTING)) {
      if (!request.disableTestWaiter) {
        const newPromise = waitFor(promise);
        const finalPromise = upgradePromise(newPromise.then(result => {
          setPromiseResult(finalPromise, {
            isError: false,
            result
          });
          clearRequestResult(requestId);
          return result;
        }, error => {
          setPromiseResult(finalPromise, {
            isError: true,
            result: error
          });
          clearRequestResult(requestId);
          throw error;
        }), promise);
        if (cacheResult) {
          setPromiseResult(finalPromise, cacheResult);
        }
        return finalPromise;
      }
    }

    // const promise1 = store.request(myRequest);
    // const promise2 = store.request(myRequest);
    // promise1 === promise2; // false
    // either we need to make promise1 === promise2, or we need to make sure that
    // we need to have a way to key from request to result
    // such that we can lookup the result here and return it if it exists
    const finalPromise = upgradePromise(promise.then(result => {
      setPromiseResult(finalPromise, {
        isError: false,
        result
      });
      clearRequestResult(requestId);
      return result;
    }, error => {
      setPromiseResult(finalPromise, {
        isError: true,
        result: error
      });
      clearRequestResult(requestId);
      throw error;
    }), promise);
    if (cacheResult) {
      setPromiseResult(finalPromise, cacheResult);
    }
    return finalPromise;
  }

  /**
   * This method exists so that the RequestManager can be created
   * can be created by container/factory systems that expect to
   * call a static `create` method to instantiate the class.
   *
   * Using `new RequestManager()` directly is preferred.
   *
   * @private
   */
  static create(options) {
    return new this(options);
  }
}

/**
 * @module
 * @mergeModuleWith <project>
 */

// @ts-expect-error adding to globalThis
globalThis.setWarpDriveLogging = setLogging;

// @ts-expect-error adding to globalThis
globalThis.getWarpDriveRuntimeConfig = getRuntimeConfig;
export { Fetch, RequestManager };