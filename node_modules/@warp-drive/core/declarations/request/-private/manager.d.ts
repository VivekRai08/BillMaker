import type { StableDocumentIdentifier } from "../../types/identifier.js";
import type { RequestInfo } from "../../types/request.js";
import type { CacheHandler, Future, GenericCreateArgs, Handler, ManagedRequestPriority } from "./types.js";
import { IS_CACHE_HANDLER } from "./utils.js";
/**
* ## Import
*
* ```js
* import { RequestManager } from '@warp-drive/core';
* ```
*
* For complete usage guide see the [RequestManager Documentation](/guides/).
*
* ## How It Works
*
* ```ts
* interface RequestManager {
*   request<T>(req: RequestInfo): Future<T>;
* }
* ```
*
* A RequestManager provides a request/response flow in which configured
* handlers are successively given the opportunity to handle, modify, or
* pass-along a request.
*
* <img src="/images/handlers-all-labeled.gif" alt="RequestManager Flow Animation" width="100%" />
*
* For example:
*
* ::: code-group
*
* ```ts [Setup.ts]
* import { RequestManager, Fetch } from '@warp-drive/core';
* import { AutoCompress } from '@warp-drive/utilities/handlers';
* import Auth from 'ember-simple-auth/handler';
*
* // ... create manager
* const manager = new RequestManager()
*    .use([Auth, new AutoCompress(), Fetch]); // [!code focus]
* ```
*
* ```ts [Usage.ts]
* import Config from './config';
*
* const { apiUrl } = Config;
*
* // ... execute a request
* const response = await manager.request({
*   url: `${apiUrl}/users`
* });
* ```
*
* :::
*
* ### Futures
*
* The return value of `manager.request` is a `Future`, which allows
* access to limited information about the request while it is still
* pending and fulfills with the final state when the request completes.
*
* A `Future` is cancellable via `abort`.
*
* Handlers may optionally expose a `ReadableStream` to the `Future` for
* streaming data; however, when doing so the future should not resolve
* until the response stream is fully read.
*
* ```ts
* interface Future<T> extends Promise<StructuredDocument<T>> {
*   abort(): void;
*
*   async getStream(): ReadableStream | null;
* }
* ```
*
* ### StructuredDocuments
*
* A Future resolves with a `StructuredDataDocument` or rejects with a `StructuredErrorDocument`.
*
* ```ts
* interface StructuredDataDocument<T> {
*   request: ImmutableRequestInfo;
*   response: ImmutableResponseInfo;
*   content: T;
* }
* interface StructuredErrorDocument extends Error {
*   request: ImmutableRequestInfo;
*   response: ImmutableResponseInfo;
*   error: string | object;
* }
* type StructuredDocument<T> = StructuredDataDocument<T> | StructuredErrorDocument;
* ```
*
* @class RequestManager
* @public
*/
export declare class RequestManager {
	#private;
	/** @internal */
	_hasCacheHandler: boolean;
	/**
	* A map of pending requests from request.id to their
	* associated CacheHandler promise.
	*
	* This queue is managed by the CacheHandler
	*
	* @internal
	*/
	_pending: Map<number, Promise<unknown>>;
	/** @internal */
	_deduped: Map<StableDocumentIdentifier, {
		priority: ManagedRequestPriority;
		promise: Promise<unknown>;
	}>;
	constructor(options?: GenericCreateArgs);
	/**
	* Register a handler to use for primary cache intercept.
	*
	* Only one such handler may exist. If using the same
	* RequestManager as the Store instance the Store
	* registers itself as a Cache handler.
	*
	* @public
	*/
	useCache(cacheHandler: CacheHandler & {
		[IS_CACHE_HANDLER]?: true;
	}): this;
	/**
	* Register handler(s) to use when a request is issued.
	*
	* Handlers will be invoked in the order they are registered.
	* Each Handler is given the opportunity to handle the request,
	* curry the request, or pass along a modified request.
	*
	* @public
	* @param {Handler[]} newHandlers
	* @return {ThisType}
	*/
	use(newHandlers: Handler[]): this;
	/**
	* Issue a Request.
	*
	* Returns a Future that fulfills with a StructuredDocument
	*
	* @public
	* @param {RequestInfo} request
	* @return {Future}
	*/
	request<
		RT,
		T = unknown
	>(request: RequestInfo<RT, T>): Future<RT>;
	/**
	* This method exists so that the RequestManager can be created
	* can be created by container/factory systems that expect to
	* call a static `create` method to instantiate the class.
	*
	* Using `new RequestManager()` directly is preferred.
	*
	* @private
	*/
	static create(options?: GenericCreateArgs): RequestManager;
}
