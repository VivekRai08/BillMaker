import type { Store } from "../../store/-private.js";
import type { SchemaService as SchemaServiceInterface } from "../../types.js";
import type { StableRecordIdentifier } from "../../types/identifier.js";
import type { ObjectValue, Value } from "../../types/json/raw.js";
import type { Derivation, HashFn } from "../../types/schema/concepts.js";
import { type ArrayField, type DerivedField, type FieldSchema, type GenericField, type HashField, type LegacyAttributeField, type LegacyBelongsToField, type LegacyHasManyField, type LegacyRelationshipField, type ObjectField, type ObjectSchema, type PolarisResourceSchema, type ResourceSchema } from "../../types/schema/fields.js";
import { Type } from "../../types/symbols.js";
import type { WithPartial } from "../../types/utils.js";
import type { ReactiveResource } from "./record.js";
/**
* Extensions allow providing non-schema driven behaviors to
* reactive resources and arrays.
*/
export interface CAUTION_MEGA_DANGER_ZONE_Extension {
	/**
	* Whether this extension extends the behaviors of objects
	* or of arrays.
	*/
	kind: "object" | "array";
	/**
	* The name of the extension, to be used when specifying
	* either `objectExtensions` or `arrayExtensions`
	*/
	name: string;
	/**
	* An object with iterable keys whose values are the getters
	* or methods to expose on the object or array.
	*
	* or
	*
	* A constructable such as a Function or Class whose prototype
	* will be iterated with getOwnPropertyNames.
	*/
	// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
	features: Record<string | symbol, unknown> | Function;
}
export type ExtensionDef = {
	kind: "method";
	// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
	fn: Function;
} | {
	kind: "readonly-value";
	value: unknown;
} | {
	kind: "mutable-value";
	value: unknown;
} | {
	kind: "readonly-field";
	get: () => unknown;
} | {
	kind: "mutable-field";
	get: () => unknown;
	set: (value: unknown) => void;
} | {
	kind: "writeonly-field";
	set: (value: unknown) => void;
};
export interface ProcessedExtension {
	kind: "object" | "array";
	name: string;
	features: Map<string | symbol, ExtensionDef>;
}
export interface ExtensibleField {
	kind: "schema-object" | "schema-array" | "array" | "object" | "hasMany";
	options?: {
		objectExtensions?: string[];
		arrayExtensions?: string[];
	};
}
/**
* Utility for constructing a ResourceSchema with the recommended
* fields for the PolarisMode experience.
*
* Using this requires registering the PolarisMode derivations
*
* ```ts
* import { registerDerivations } from '@warp-drive/schema-record';
*
* registerDerivations(schema);
* ```
*
* @public
* @param schema
* @return {PolarisResourceSchema}
*/
export declare function withDefaults(schema: WithPartial<PolarisResourceSchema, "identity">): ResourceSchema;
interface FromIdentityDerivation {
	(record: ReactiveResource, options: {
		key: "lid";
	} | {
		key: "type";
	}, key: string): string;
	(record: ReactiveResource, options: {
		key: "id";
	}, key: string): string | null;
	(record: ReactiveResource, options: {
		key: "^";
	}, key: string): StableRecordIdentifier;
	(record: ReactiveResource, options: null, key: string): asserts options;
	(record: ReactiveResource, options: {
		key: "id" | "lid" | "type" | "^";
	} | null, key: string): StableRecordIdentifier | string | null;
	[Type]: "@identity";
}
/**
* A derivation that computes its value from the
* record's identity.
*
* It can be used via a derived field definition like:
*
* ```ts
* {
*   kind: 'derived',
*   name: 'id',
*   type: '@identity',
*   options: { key: 'id' }
* }
* ```
*
* Valid keys are `'id'`, `'lid'`, `'type'`, and `'^'`.
*
* `^` returns the entire identifier object.
*
* @public
*/
export declare const fromIdentity: FromIdentityDerivation;
/**
* Registers the default derivations for records that want
* to use the PolarisMode defaults provided by
*
* ```ts
* import { withDefaults } from '@warp-drive/schema-record';
* ```
*
* @public
* @param {SchemaService} schema
*/
export declare function registerDerivations(schema: SchemaServiceInterface): void;
interface InternalSchema {
	original: ResourceSchema | ObjectSchema;
	traits: Set<string>;
	fields: Map<string, FieldSchema>;
	attributes: Record<string, LegacyAttributeField>;
	relationships: Record<string, LegacyRelationshipField>;
}
export type Transformation<
	T extends Value = Value,
	PT = unknown
> = {
	serialize(value: PT, options: Record<string, unknown> | null, record: ReactiveResource): T;
	hydrate(value: T | undefined, options: Record<string, unknown> | null, record: ReactiveResource): PT;
	defaultValue?(options: Record<string, unknown> | null, identifier: StableRecordIdentifier): T;
	[Type]: string;
};
interface KindFns {
	belongsTo: {
		get: (store: Store, record: object, resourceKey: StableRecordIdentifier, field: LegacyBelongsToField) => unknown;
		set: (store: Store, record: object, cacheKey: StableRecordIdentifier, field: LegacyBelongsToField, value: unknown) => void;
	};
	hasMany: {
		get: (store: Store, record: object, resourceKey: StableRecordIdentifier, field: LegacyHasManyField) => unknown;
		set: (store: Store, record: object, cacheKey: StableRecordIdentifier, field: LegacyHasManyField, value: unknown) => void;
		notify: (store: Store, record: object, cacheKey: StableRecordIdentifier, field: LegacyHasManyField) => boolean;
	};
}
export interface SchemaService {
	doesTypeExist(type: string): boolean;
	attributesDefinitionFor(identifier: {
		type: string;
	}): InternalSchema["attributes"];
	relationshipsDefinitionFor(identifier: {
		type: string;
	}): InternalSchema["relationships"];
}
/**
* A SchemaService designed to work with dynamically registered schemas.
*
* @class SchemaService
* @public
*/
export declare class SchemaService implements SchemaServiceInterface {
	/** @internal */
	_schemas: Map<string, InternalSchema>;
	/** @internal */
	_transforms: Map<string, Transformation>;
	/** @internal */
	_hashFns: Map<string, HashFn>;
	/** @internal */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	_derivations: Map<string, Derivation<any, any, any>>;
	/** @internal */
	_traits: Set<string>;
	/** @internal */
	_modes: Map<string, KindFns>;
	/** @internal */
	_extensions: {
		object: Map<string, ProcessedExtension>;
		array: Map<string, ProcessedExtension>;
	};
	_cachedFieldExtensionsByField: {
		object: Map<object, ProcessedExtension["features"] | null>;
		array: Map<object, ProcessedExtension["features"] | null>;
	};
	constructor();
	resourceTypes(): Readonly<string[]>;
	hasTrait(type: string): boolean;
	resourceHasTrait(resource: StableRecordIdentifier | {
		type: string;
	}, trait: string): boolean;
	transformation(field: GenericField | ObjectField | ArrayField | {
		type: string;
	}): Transformation;
	derivation(field: DerivedField | {
		type: string;
	}): Derivation;
	hashFn(field: HashField | {
		type: string;
	}): HashFn;
	resource(resource: StableRecordIdentifier | {
		type: string;
	}): ResourceSchema | ObjectSchema;
	registerResources(schemas: Array<ResourceSchema | ObjectSchema>): void;
	registerResource(schema: ResourceSchema | ObjectSchema): void;
	registerTransformation<
		T extends Value = string,
		PT = unknown
	>(transformation: Transformation<T, PT>): void;
	registerDerivation<
		R,
		T,
		FM extends ObjectValue | null
	>(derivation: Derivation<R, T, FM>): void;
	CAUTION_MEGA_DANGER_ZONE_registerExtension(extension: CAUTION_MEGA_DANGER_ZONE_Extension): void;
	CAUTION_MEGA_DANGER_ZONE_resourceExtensions(resource: StableRecordIdentifier | {
		type: string;
	}): null | ProcessedExtension["features"];
	CAUTION_MEGA_DANGER_ZONE_objectExtensions(field: ExtensibleField): null | ProcessedExtension["features"];
	CAUTION_MEGA_DANGER_ZONE_arrayExtensions(field: ExtensibleField): null | ProcessedExtension["features"];
	/**
	* This is an internal method used to register behaviors for legacy mode.
	* It is not intended for public use.
	*
	* We do think a generalized `kind` registration system would be useful,
	* but we have not yet designed it.
	*
	* See https://github.com/emberjs/data/issues/9534
	*
	* @internal
	*/
	_registerMode(mode: string, kinds: KindFns): void;
	/**
	* This is an internal method used to enable legacy behaviors for legacy mode.
	* It is not intended for public use.
	*
	* We do think a generalized `kind` registration system would be useful,
	* but we have not yet designed it.
	*
	* See https://github.com/emberjs/data/issues/9534
	*
	* @internal
	*/
	_kind<T extends keyof KindFns>(mode: string, kind: T): KindFns[T];
	registerHashFn<T extends object>(hashFn: HashFn<T>): void;
	fields({ type }: {
		type: string;
	}): InternalSchema["fields"];
	hasResource(resource: {
		type: string;
	}): boolean;
}
export {};
