import type { StableRecordIdentifier } from "../../../types/identifier.js";
import type { SingleResourceDocument } from "../../../types/spec/json-api-raw.js";
import type { OpaqueRecordInstance } from "../../-types/q/record-instance.js";
import type { Store } from "../store-service.js";
/**
A `RecordReference` is a low-level API that allows users and
addon authors to perform meta-operations on a record.

@hideconstructor
@public
*/
export default class RecordReference {
	private store;
	// unsubscribe token given to us by the notification manager
	private ___token;
	private ___identifier;
	private _ref;
	constructor(store: Store, identifier: StableRecordIdentifier);
	/** @internal */
	destroy(): void;
	get type(): string;
	/**
	The `id` of the record that this reference refers to.
	
	Together, the `type` and `id` properties form a composite key for
	the identity map.
	
	Example
	
	```javascript
	let userRef = store.getReference('user', 1);
	
	userRef.id(); // '1'
	```
	
	@public
	*/
	id(): string | null;
	/**
	The `identifier` of the record that this reference refers to.
	
	Together, the `type` and `id` properties form a composite key for
	the identity map.
	
	Example
	
	```javascript
	let userRef = store.getReference('user', 1);
	
	userRef.identifier(); // '1'
	```
	
	@public
	*/
	identifier(): StableRecordIdentifier;
	/**
	How the reference will be looked up when it is loaded. Currently
	this always returns `identity` to signify that a record will be
	loaded by its `type` and `id`.
	
	Example
	
	```javascript
	const userRef = store.getReference('user', 1);
	
	userRef.remoteType(); // 'identity'
	```
	
	@public
	*/
	remoteType(): "identity";
	/**
	This API allows you to provide a reference with new data. The
	simplest usage of this API is similar to `store.push`: you provide a
	normalized hash of data and the object represented by the reference
	will update.
	
	If you pass a promise to `push`, Ember Data will not ask the adapter
	for the data if another attempt to fetch it is made in the
	interim. When the promise resolves, the underlying object is updated
	with the new data, and the promise returned by *this function* is resolved
	with that object.
	
	For example, `recordReference.push(promise)` will be resolved with a
	record.
	
	Example
	
	```javascript
	let userRef = store.getReference('user', 1);
	
	// provide data for reference
	userRef.push({
	data: {
	id: "1",
	type: "user",
	attributes: {
	username: "@user"
	}
	}
	}).then(function(user) {
	userRef.value() === user;
	});
	```
	
	@public
	@param objectOrPromise a JSON:API ResourceDocument or a promise resolving to one
	@return a promise for the value (record or relationship)
	*/
	push(objectOrPromise: SingleResourceDocument | Promise<SingleResourceDocument>): Promise<OpaqueRecordInstance>;
	/**
	If the entity referred to by the reference is already loaded, it is
	present as `reference.value`. Otherwise the value returned by this function
	is `null`.
	
	Example
	
	```javascript
	let userRef = store.getReference('user', 1);
	
	userRef.value(); // user
	```
	
	@public
	*/
	value(): OpaqueRecordInstance | null;
	/**
	Triggers a fetch for the backing entity based on its `remoteType`
	(see `remoteType` definitions per reference type).
	
	Example
	
	```javascript
	let userRef = store.getReference('user', 1);
	
	// load user (via store.find)
	userRef.load().then(...)
	```
	
	@public
	*/
	load(): Promise<OpaqueRecordInstance>;
	/**
	Reloads the record if it is already loaded. If the record is not
	loaded it will load the record via `store.findRecord`
	
	Example
	
	```javascript
	let userRef = store.getReference('user', 1);
	
	// or trigger a reload
	userRef.reload().then(...)
	```
	
	@public
	*/
	reload(): Promise<OpaqueRecordInstance>;
}
