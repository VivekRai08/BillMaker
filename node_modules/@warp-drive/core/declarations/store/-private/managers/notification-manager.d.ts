import type { StableDocumentIdentifier, StableRecordIdentifier } from "../../../types/identifier.js";
import type { Store } from "../store-service.js";
export type UnsubscribeToken = object;
export type CacheOperation = "added" | "removed" | "updated" | "state";
export type DocumentCacheOperation = "invalidated" | "added" | "removed" | "updated" | "state";
export type NotificationType = "attributes" | "relationships" | "identity" | "errors" | "meta" | CacheOperation;
export interface NotificationCallback {
	(identifier: StableRecordIdentifier, notificationType: "attributes" | "relationships", key?: string): void;
	(identifier: StableRecordIdentifier, notificationType: "errors" | "meta" | "identity" | "state"): void;
	(identifier: StableRecordIdentifier, notificationType: CacheOperation): void;
}
export interface ResourceOperationCallback {
	// resource updates
	(identifier: StableRecordIdentifier, notificationType: CacheOperation): void;
}
export interface DocumentOperationCallback {
	// document updates
	(identifier: StableDocumentIdentifier, notificationType: DocumentCacheOperation): void;
}
/**
* The NotificationManager provides the ability to subscribe to
* changes to Cache state.
*
* This Feature is what allows WarpDrive to create subscriptions that
* work with any framework or change-notification system.
*
* @hideconstructor
* @public
*/
export default class NotificationManager {
	/** @internal */
	private store;
	/** @internal */
	private isDestroyed;
	/** @internal */
	private _buffered;
	/** @internal */
	private _cache;
	/** @internal */
	private _hasFlush;
	/** @internal */
	private _onFlushCB?;
	constructor(store: Store);
	/**
	* Subscribe to changes for a given resource identifier, resource addition/removal, or document addition/removal.
	*
	* ```ts
	* export type CacheOperation = 'added' | 'removed' | 'updated' | 'state';
	*
	* export interface NotificationCallback {
	*   (identifier: StableRecordIdentifier, notificationType: 'attributes' | 'relationships', key?: string): void;
	*   (identifier: StableRecordIdentifier, notificationType: 'errors' | 'meta' | 'identity' | 'state'): void;
	*   (identifier: StableRecordIdentifier, notificationType: NotificationType, key?: string): void;
	* }
	* export interface ResourceOperationCallback {
	*   // resource updates
	*   (identifier: StableRecordIdentifier, notificationType: CacheOperation): void;
	* }
	* export interface DocumentOperationCallback {
	*   // document updates
	*   (identifier: StableDocumentIdentifier, notificationType: CacheOperation): void;
	* }
	* ```
	*
	* @public
	* @param {StableDocumentIdentifier | StableRecordIdentifier | 'resource' | 'document'} identifier
	* @param {NotificationCallback | ResourceOperationCallback | DocumentOperationCallback} callback
	* @return {UnsubscribeToken} an opaque token to be used with unsubscribe
	*/
	subscribe(identifier: StableRecordIdentifier, callback: NotificationCallback): UnsubscribeToken;
	subscribe(identifier: "resource", callback: ResourceOperationCallback): UnsubscribeToken;
	subscribe(identifier: "document" | StableDocumentIdentifier, callback: DocumentOperationCallback): UnsubscribeToken;
	/**
	* remove a previous subscription
	*
	* @public
	*/
	unsubscribe(token: UnsubscribeToken): void;
	/**
	* Custom Caches and Application Code should not call this method directly.
	*
	* @private
	*/
	notify(identifier: StableRecordIdentifier, value: "attributes" | "relationships", key?: string): boolean;
	notify(identifier: StableRecordIdentifier, value: "errors" | "meta" | "identity" | "state"): boolean;
	notify(identifier: StableRecordIdentifier, value: CacheOperation): boolean;
	notify(identifier: StableDocumentIdentifier, value: DocumentCacheOperation): boolean;
	/** @internal */
	_onNextFlush(cb: () => void): void;
	private _scheduleNotify;
	/** @internal */
	_flush(): void;
	private _flushNotification;
	private _flushNotification;
	private _flushNotification;
	/** @internal */
	destroy(): void;
}
