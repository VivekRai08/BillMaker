import type { LocalRelationshipOperation } from "../../../types/graph.js";
import type { StableDocumentIdentifier, StableRecordIdentifier } from "../../../types/identifier.js";
import type { ImmutableRequestInfo } from "../../../types/request.js";
import type { CollectionResourceDocument } from "../../../types/spec/json-api-raw.js";
import { Collection, IdentifierArray } from "../record-arrays/identifier-array.js";
import type { Store } from "../store-service.js";
import type { UnsubscribeToken } from "./notification-manager.js";
/**
* This is a clever optimization.
*
* clever optimizations rarely stand the test of time, so if you're
* ever curious or think something better is possible please benchmark
* and discuss. The benchmark for this at the time of writing is in
* `scripts/benchmark-push.js`
*
* This approach turns out to be 150x faster in Chrome and node than
* simply using push or concat. It's highly susceptible to the specifics
* of the batch size, and may require tuning.
*
* Clever optimizations should always come with a `why`. This optimization
* exists for two reasons.
*
* 1) array.push(...objects) and Array.prototype.push.apply(arr, objects)
*   are susceptible to stack overflows. The size of objects at which this
*   occurs varies by environment, browser, and current stack depth and memory
*   pressure; however, it occurs in all browsers in fairly pristine conditions
*   somewhere around 125k to 200k elements. Since WarpDrive regularly encounters
*   arrays larger than this in size, we cannot use push.
*
* 2) `array.concat` or simply setting the array to a new reference is often an
*   easier approach; however, native Proxy to an array cannot swap it's target array
*   and attempts at juggling multiple array sources have proven to be victim to a number
*   of browser implementation bugs. Should these bugs be addressed then we could
*   simplify to using `concat`, however, do note this is currently 150x faster
*   than concat, and due to the overloaded signature of concat will likely always
*   be faster.
*
* Sincerely,
*   - runspired (Chris Thoburn) 08/21/2022
*
* @function fastPush
* @internal
* @param target the array to push into
* @param source the items to push into target
*/
export declare function fastPush<T>(target: T[], source: T[]): void;
type ChangeSet = Map<StableRecordIdentifier, "add" | "del">;
/**
@class RecordArrayManager
@internal
*/
export declare class RecordArrayManager {
	store: Store;
	isDestroying: boolean;
	isDestroyed: boolean;
	_set: Map<IdentifierArray, Set<StableRecordIdentifier>>;
	_live: Map<string, IdentifierArray>;
	_managed: Set<IdentifierArray>;
	_pending: Map<IdentifierArray, ChangeSet>;
	_identifiers: Map<StableRecordIdentifier, Set<Collection>>;
	_staged: Map<string, ChangeSet>;
	_subscription: UnsubscribeToken;
	_documentSubscription: UnsubscribeToken;
	_keyedArrays: Map<string, Collection>;
	_visibilitySet: Map<StableRecordIdentifier, boolean>;
	constructor(options: {
		store: Store;
	});
	_syncArray(array: IdentifierArray | Collection): void;
	mutate(mutation: LocalRelationshipOperation): void;
	/**
	Get the `RecordArray` for a modelName, which contains all loaded records of
	given modelName.
	
	@internal
	@param {String} modelName
	@return {RecordArray}
	*/
	liveArrayFor(type: string): IdentifierArray;
	getCollection(config: {
		type?: string;
		query?: ImmutableRequestInfo | Record<string, unknown>;
		identifiers?: StableRecordIdentifier[];
		doc?: CollectionResourceDocument;
		identifier?: StableDocumentIdentifier | null;
	}): Collection;
	dirtyArray(array: IdentifierArray, delta: number, shouldSyncFromCache: boolean): void;
	_getPendingFor(identifier: StableRecordIdentifier, includeManaged: boolean, isRemove?: boolean): Map<IdentifierArray, ChangeSet> | void;
	populateManagedArray(array: Collection, identifiers: StableRecordIdentifier[], payload: CollectionResourceDocument | null): void;
	identifierAdded(identifier: StableRecordIdentifier): void;
	identifierRemoved(identifier: StableRecordIdentifier): void;
	identifierChanged(identifier: StableRecordIdentifier): void;
	clear(isClear?: boolean): void;
	destroy(): void;
}
export declare function disassociateIdentifier(ArraysCache: Map<StableRecordIdentifier, Set<Collection>>, array: Collection, identifier: StableRecordIdentifier): void;
export {};
