import type { StableRecordIdentifier } from "../../../types/identifier.js";
import type { FindRecordOptions } from "../../-types/q/store.js";
import type { Store } from "../store-service.js";
declare const Touching: "___(unique) Symbol(Touching)";
export declare const RequestPromise: "___(unique) Symbol(RequestPromise)";
export interface Operation {
	op: string;
	options: FindRecordOptions | undefined;
	recordIdentifier: StableRecordIdentifier;
}
export interface FindRecordQuery extends Operation {
	op: "findRecord";
}
export interface SaveRecordMutation extends Operation {
	op: "saveRecord";
}
export interface Request {
	data: Operation[];
	options?: Record<string, unknown>;
}
export type RequestStates = "pending" | "fulfilled" | "rejected";
export interface RequestCacheRequestState {
	state: RequestStates;
	type: "query" | "mutation";
	request: Request;
	response?: Response;
}
export interface Response {
	// rawData: unknown;
	data: unknown;
}
interface InternalRequest extends RequestCacheRequestState {
	[Touching]: StableRecordIdentifier[];
	[RequestPromise]?: Promise<unknown>;
}
export type RequestSubscription = (requestState: RequestCacheRequestState) => void;
/**
* The RequestStateService is used to track the state of requests
* for fetching or updating known resource identifies that are inflight.
*
* @hideconstructor
* @public
*/
export declare class RequestStateService {
	/** @internal */
	_pending: Map<StableRecordIdentifier, InternalRequest[]>;
	private _done;
	private _subscriptions;
	private _toFlush;
	private _store;
	constructor(store: Store);
	/** @internal */
	_clearEntries(identifier: StableRecordIdentifier): void;
	/** @internal */
	_enqueue<T>(promise: Promise<T>, queryRequest: Request): Promise<T>;
	private _triggerSubscriptions;
	private _flush;
	private _flushRequest;
	private _dequeue;
	private _addDone;
	/**
	* Subscribe to requests for a given resource identity.
	*
	* The callback will receive the current state of the request.
	*
	* ```ts
	* interface RequestState {
	*   state: 'pending' | 'fulfilled' | 'rejected';
	*   type: 'query' | 'mutation';
	*   request: Request;
	*   response?: { data: unknown };
	* }
	* ```
	*
	* Note: It should be considered dangerous to use this API for more than simple
	* state derivation or debugging. The `request` and `response` properties are poorly
	* spec'd and may change unexpectedly when shifting what Handlers are in use or how
	* requests are issued from the Store.
	*
	* We expect to revisit this API in the near future as we continue to refine the
	* RequestManager ergonomics, as a simpler but more powerful direct integration
	* with the RequestManager for these purposes is likely to be a better long-term
	* design.
	*
	* @public
	* @param {StableRecordIdentifier} identifier
	* @param {(state: RequestCacheRequestState) => void} callback
	*/
	subscribeForRecord(identifier: StableRecordIdentifier, callback: RequestSubscription): void;
	/**
	* Retrieve all active requests for a given resource identity.
	*
	* @public
	* @param {StableRecordIdentifier} identifier
	* @return {RequestCacheRequestState[]} an array of request states for any pending requests for the given identifier
	*/
	getPendingRequestsForRecord(identifier: StableRecordIdentifier): RequestCacheRequestState[];
	/**
	* Retrieve the last completed request for a given resource identity.
	*
	* @public
	* @param {StableRecordIdentifier} identifier
	* @return {RequestCacheRequestState | null} the state of the most recent request for the given identifier
	*/
	getLastRequestForRecord(identifier: StableRecordIdentifier): RequestCacheRequestState | null;
}
export {};
