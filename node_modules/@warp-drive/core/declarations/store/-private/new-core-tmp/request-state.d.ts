import type { Future } from "../../../request.js";
import type { ImmutableRequestInfo, ResponseInfo, StructuredErrorDocument } from "../../../types/request.js";
import type { PendingPromise, RejectedPromise, ResolvedPromise } from "./promise-state.js";
/**
* Lazily consumes the stream of a request, providing a number of
* reactive properties that can be used to build UIs that respond
* to the progress of a request.
*
*/
export declare class RequestLoadingState {
	private _sizeHint;
	private _bytesLoaded;
	private _startTime;
	private _endTime;
	private _lastPacketTime;
	private _isPending;
	private _isStarted;
	private _isComplete;
	private _isCancelled;
	private _isErrored;
	private _error;
	private _stream;
	private _future;
	private _triggered;
	private _trigger;
	promise: Promise<void> | null;
	get isPending(): boolean;
	get sizeHint(): number;
	get stream(): ReadableStream | null;
	get isStarted(): boolean;
	get bytesLoaded(): number;
	get startTime(): number;
	get endTime(): number;
	get lastPacketTime(): number;
	get isComplete(): boolean;
	get isCancelled(): boolean;
	get isErrored(): boolean;
	get error(): Error | null;
	get elapsedTime(): number;
	get completedRatio(): number;
	get remainingRatio(): number;
	get duration(): number;
	get speed(): number;
	constructor(future: Future<unknown>);
	abort: () => void;
}
/**
* The state of a request in the "pending"
* state. This is the default initial state.
*
* Extends the {@link PendingPromise} interface.
*
*/
export interface PendingRequest extends PendingPromise {
	/**
	* Whether the request is cancelled.
	*
	*/
	isCancelled: false;
	loadingState: RequestLoadingState;
	request: null;
	response: null;
}
/**
* The state of a request in the "fulfilled" state.
* This is the state of a request that has resolved
* successfully.
*
* Extends the {@link ResolvedPromise} interface.
*
*/
export interface ResolvedRequest<
	RT,
	T
> extends ResolvedPromise<RT> {
	/**
	* Whether the request is cancelled.
	*
	*/
	isCancelled: false;
	loadingState: RequestLoadingState;
	request: ImmutableRequestInfo<RT, T> | null;
	response: Response | ResponseInfo | null;
}
/**
* The state of a request in the "rejected" state.
* This is the state of a request that has rejected
* with an error.
*
* Extends the {@link RejectedPromise} interface.
*
*/
export interface RejectedRequest<
	RT,
	T,
	E extends StructuredErrorDocument = StructuredErrorDocument
> extends RejectedPromise<E> {
	/**
	* Whether the request is cancelled.
	*
	*/
	isCancelled: false;
	loadingState: RequestLoadingState;
	request: ImmutableRequestInfo<RT, T> | null;
	response: Response | ResponseInfo | null;
}
/**
* The state of a request in the "cancelled" state.
* This is the state of a promise that has been
* cancelled.
*
*/
export interface CancelledRequest<
	RT,
	T,
	E extends StructuredErrorDocument = StructuredErrorDocument
> {
	/**
	* The status of the request.
	*
	*/
	status: "cancelled";
	/**
	* Whether the request is pending.
	*
	*/
	isPending: false;
	/**
	* Whether the request is pending.
	*
	*/
	isLoading: false;
	/**
	* Whether the request has resolved
	* successfully.
	*
	*/
	isSuccess: false;
	/**
	* Whether the request has rejected
	* with an error.
	*
	*/
	isError: true;
	/**
	* Once the request has resolved, this will
	* be the value the request resolved to.
	*
	*/
	value: null;
	/**
	* Once the request has resolved, this will
	* be the value the request resolved to.
	*
	* @deprecated use `value` instead
	*/
	result: null;
	/**
	* Once the request has rejected, this will
	* be the error the request rejected with.
	*
	*
	* @deprecated use `reason` instead
	*/
	error: E;
	/**
	* Once the request has rejected, this will
	* be the error the request rejected with.
	*
	*/
	reason: E;
	/**
	* Whether the request is cancelled.
	*
	*/
	isCancelled: true;
	loadingState: RequestLoadingState;
	request: ImmutableRequestInfo<RT, T> | null;
	response: Response | ResponseInfo | null;
}
/**
* RequestState extends the concept of PromiseState to provide a reactive
* wrapper for a request `Future` which allows you write declarative code
* around a Future's control flow.
*
* It is useful in both Template and JavaScript contexts, allowing you
* to quickly derive behaviors and data from pending, error and success
* states.
*
* The key difference between a Promise and a Future is that Futures provide
* access to a stream of their content, the identity of the request (if any)
* as well as the ability to attempt to abort the request.
*
* ```ts
* interface Future<T> extends Promise<T>> {
*   getStream(): Promise<ReadableStream>;
*   abort(): void;
*   lid: StableDocumentIdentifier | null;
* }
* ```
*
* These additional APIs allow us to craft even richer state experiences.
*
* To get the state of a request, use `getRequestState`.
*
* See also:
* - {@link PendingRequest}
* - {@link ResolvedRequest}
* - {@link RejectedRequest}
* - {@link CancelledRequest}
*
*/
export type RequestCacheRequestState<
	RT = unknown,
	T = unknown,
	E extends StructuredErrorDocument = StructuredErrorDocument
> = PendingRequest | ResolvedRequest<RT, T> | RejectedRequest<RT, T, E> | CancelledRequest<RT, T, E>;
export declare function createRequestState<
	RT,
	T,
	E
>(future: Future<RT>): Readonly<RequestCacheRequestState<RT, T, StructuredErrorDocument<E>>>;
/**
* `getRequestState` can be used in both JavaScript and Template contexts.
*
* ```ts
* import { getRequestState } from '@warp-drive/ember';
*
* const state = getRequestState(future);
* ```
*
* For instance, we could write a getter on a component that updates whenever
* the request state advances or the future changes, by combining the function
* with the use of `@cached`
*
* ```ts
* class Component {
*   @cached
*   get title() {
*     const state = getRequestState(this.args.request);
*     if (state.isPending) {
*       return 'loading...';
*     }
*     if (state.isError) { return null; }
*     return state.result.title;
*   }
* }
* ```
*
* Or in a template as a helper:
*
* ```gjs
* import { getRequestState } from '@warp-drive/ember';
*
* <template>
*   {{#let (getRequestState @request) as |state|}}
*     {{#if state.isPending}}
*       <Spinner />
*     {{else if state.isError}}
*       <ErrorForm @error={{state.error}} />
*     {{else}}
*       <h1>{{state.result.title}}</h1>
*     {{/if}}
*   {{/let}}
* </template>
* ```
*
* If looking to use in a template, consider also the `<Request />` component
* which offers a numbe of additional capabilities for requests *beyond* what
* `RequestState` provides.
*
*/
export declare function getRequestState<
	RT,
	T,
	E
>(future: Future<RT>): Readonly<RequestCacheRequestState<RT, T, StructuredErrorDocument<E>>>;
