import { type Identifier, type RecordIdentifier, type StableDocumentIdentifier, type StableExistingRecordIdentifier, type StableRecordIdentifier } from "../../../types/identifier.js";
import type { ImmutableRequestInfo } from "../../../types/request.js";
import type { ExistingResourceIdentifierObject, ResourceIdentifierObject } from "../../../types/spec/json-api-raw.js";
import type { ForgetMethod, GenerationMethod, KeyInfo, KeyInfoMethod, ResetMethod, UpdateMethod } from "../../-types/q/identifier.js";
type TypeFromIdentifier<T> = T extends {
	type: infer U;
} ? U : string;
type NarrowIdentifierIfPossible<T> = T extends ExistingResourceIdentifierObject ? StableExistingRecordIdentifier<TypeFromIdentifier<T>> : StableRecordIdentifier;
export declare function isStableIdentifier(identifier: unknown): identifier is StableRecordIdentifier;
export declare function isDocumentIdentifier(identifier: unknown): identifier is StableDocumentIdentifier;
interface KeyOptions {
	lid: IdentifierMap;
	id: IdentifierMap;
}
type TypeMap = {
	[key: string]: KeyOptions;
};
// type IdentifierTypeLookup = { all: Set<StableRecordIdentifier>; id: Map<string, StableRecordIdentifier> };
// type IdentifiersByType = Map<string, IdentifierTypeLookup>;
type IdentifierMap = Map<string, StableRecordIdentifier>;
type StableCache = {
	resources: IdentifierMap;
	documents: Map<string, StableDocumentIdentifier>;
	resourcesByType: TypeMap;
	polymorphicLidBackMap: Map<string, string[]>;
};
export type MergeMethod = (targetIdentifier: StableRecordIdentifier, matchedIdentifier: StableRecordIdentifier, resourceData: unknown) => StableRecordIdentifier;
/**
Configures how unique identifier lid strings are generated by @ember-data/store.

This configuration MUST occur prior to the store instance being created.

Takes a method which can expect to receive various data as its first argument
and the name of a bucket as its second argument.

Currently there are two buckets, 'record' and 'document'.

### Resource (`Record`) Identity

If the bucket is `record` the method must return a unique (to at-least
the given bucket) string identifier for the given data as a string to be
used as the `lid` of an `Identifier` token.

This method will only be called by either `getOrCreateRecordIdentifier` or
`createIdentifierForNewRecord` when an identifier for the supplied data
is not already known via `lid` or `type + id` combo and one needs to be
generated or retrieved from a proprietary cache.

`data` will be the same data argument provided to `getOrCreateRecordIdentifier`
and in the `createIdentifierForNewRecord` case will be an object with
only `type` as a key.

```ts
import { setIdentifierGenerationMethod } from '@warp-drive/core';

export function initialize(applicationInstance) {
// note how `count` here is now scoped to the application instance
// for our generation method by being inside the closure provided
// by the initialize function
let count = 0;

setIdentifierGenerationMethod((resource, bucket) => {
return resource.lid || `my-key-${count++}`;
});
}

export default {
name: 'configure-ember-data-identifiers',
initialize
};
```

### Document Identity

If the bucket is `document` the method will receive the associated
immutable `request` passed to `store.request` as its first argument
and should return a unique string for the given request if the document
should be cached, and `null` if it should not be cached.

Note, the request result will still be passed to the cache via `Cache.put`,
but caches should take this as a signal that the document should not itself
be cached, while its contents may still be used to update other cache state.

The presence of `cacheOptions.key` on the request will take precedence
for the document cache key, and this method will not be called if it is
present.

The default method implementation for this bucket is to return `null`
for all requests whose method is not `GET`, and to return the `url` for
those where it is.

This means that queries via `POST` MUST provide `cacheOptions.key` or
implement this hook.

⚠️ Caution: Requests that do not have a `method` assigned are assumed to be `GET`

@public
*/
export declare function setIdentifierGenerationMethod(method: GenerationMethod | null): void;
/**
Configure a callback for when the identifier cache encounters new resource
data for an existing resource.

This configuration MUST occur prior to the store instance being created.

```js
import { setIdentifierUpdateMethod } from '@warp-drive/core';
```

Takes a method which can expect to receive an existing `Identifier` alongside
some new data to consider as a second argument. This is an opportunity
for secondary lookup tables and caches associated with the identifier
to be amended.

This method is called everytime `updateRecordIdentifier` is called and
with the same arguments. It provides the opportunity to update secondary
lookup tables for existing identifiers.

It will always be called after an identifier created with `createIdentifierForNewRecord`
has been committed, or after an update to the `record` a `RecordIdentifier`
is assigned to has been committed. Committed here meaning that the server
has acknowledged the update (for instance after a call to `.save()`)

If `id` has not previously existed, it will be assigned to the `Identifier`
prior to this `UpdateMethod` being called; however, calls to the parent method
`updateRecordIdentifier` that attempt to change the `id` or calling update
without providing an `id` when one is missing will throw an error.

@public
*/
export declare function setIdentifierUpdateMethod(method: UpdateMethod | null): void;
/**
Configure a callback for when the identifier cache is going to release an identifier.

This configuration MUST occur prior to the store instance being created.

```js
import { setIdentifierForgetMethod } from '@warp-drive/core';
```

Takes method which can expect to receive an existing `Identifier` that should be eliminated
from any secondary lookup tables or caches that the user has populated for it.

@public
*/
export declare function setIdentifierForgetMethod(method: ForgetMethod | null): void;
/**
Configure a callback for when the identifier cache is being torn down.

This configuration MUST occur prior to the store instance being created.

```js
import { setIdentifierResetMethod } from '@warp-drive/core';
```

Takes a method which can expect to be called when the parent application is destroyed.

If you have properly used a WeakMap to encapsulate the state of your customization
to the application instance, you may not need to implement the `resetMethod`.

@public
*/
export declare function setIdentifierResetMethod(method: ResetMethod | null): void;
/**
Configure a callback for when the identifier cache is generating a new
StableRecordIdentifier for a resource.

This method controls the `type` and `id` that will be assigned to the
`StableRecordIdentifier` that is created.

This configuration MUST occur prior to the store instance being created.

```js
import { setKeyInfoForResource } from '@warp-drive/core';
```

@public
*/
export declare function setKeyInfoForResource(method: KeyInfoMethod | null): void;
/**
* Each instance of {@link Store} receives a unique instance of a IdentifierCache.
*
* This cache is responsible for assigning or retrieving the unique identify
* for arbitrary resource data encountered by the store. Data representing
* a unique resource or record should always be represented by the same
* identifier.
*
* It can be configured by consuming applications.
*
* @hideconstructor
* @public
*/
export declare class IdentifierCache {
	/** @internal */
	_cache: StableCache;
	private _generate;
	private _update;
	private _forget;
	private _reset;
	private _merge;
	private _keyInfoForResource;
	private _id;
	constructor();
	/**
	* Internal hook to allow management of merge conflicts with identifiers.
	*
	* we allow late binding of this private internal merge so that
	* the cache can insert itself here to handle elimination of duplicates
	*
	* @private
	*/
	__configureMerge(method: MergeMethod | null): void;
	/** @internal */
	upgradeIdentifier(resource: {
		type: string;
		id: string | null;
		lid?: string;
	}): StableRecordIdentifier;
	/**
	* @private
	*/
	private _getRecordIdentifier;
	private _getRecordIdentifier;
	private _getRecordIdentifier;
	/**
	* allows us to peek without generating when needed
	* useful for the "create" case when we need to see if
	* we are accidentally overwritting something
	*
	* @private
	*/
	peekRecordIdentifier(resource: ResourceIdentifierObject | Identifier): StableRecordIdentifier | undefined;
	/**
	Returns the DocumentIdentifier for the given Request, creates one if it does not yet exist.
	Returns `null` if the request does not have a `cacheKey` or `url`.
	
	@public
	*/
	getOrCreateDocumentIdentifier(request: ImmutableRequestInfo): StableDocumentIdentifier | null;
	/**
	Returns the Identifier for the given Resource, creates one if it does not yet exist.
	
	Specifically this means that we:
	
	- validate the `id` `type` and `lid` combo against known identifiers
	- return an object with an `lid` that is stable (repeated calls with the same
	`id` + `type` or `lid` will return the same `lid` value)
	- this referential stability of the object itself is guaranteed
	
	@public
	*/
	getOrCreateRecordIdentifier<T>(resource: T): NarrowIdentifierIfPossible<T>;
	/**
	Returns a new Identifier for the supplied data. Call this method to generate
	an identifier when a new resource is being created local to the client and
	potentially does not have an `id`.
	
	Delegates generation to the user supplied `GenerateMethod` if one has been provided
	with the signature `generateMethod({ type }, 'record')`.
	
	@public
	*/
	createIdentifierForNewRecord(data: {
		type: string;
		id?: string | null;
	}): StableRecordIdentifier;
	/**
	Provides the opportunity to update secondary lookup tables for existing identifiers
	Called after an identifier created with `createIdentifierForNewRecord` has been
	committed.
	
	Assigned `id` to an `Identifier` if `id` has not previously existed; however,
	attempting to change the `id` or calling update without providing an `id` when
	one is missing will throw an error.
	
	- sets `id` (if `id` was previously `null`)
	- `lid` and `type` MUST NOT be altered post creation
	
	If a merge occurs, it is possible the returned identifier does not match the originally
	provided identifier. In this case the abandoned identifier will go through the usual
	`forgetRecordIdentifier` codepaths.
	
	@public
	*/
	updateRecordIdentifier(identifierObject: RecordIdentifier, data: unknown): StableRecordIdentifier;
	/**
	* @private
	*/
	_mergeRecordIdentifiers(keyInfo: KeyInfo, identifier: StableRecordIdentifier, existingIdentifier: StableRecordIdentifier, data: unknown): StableRecordIdentifier;
	/**
	Provides the opportunity to eliminate an identifier from secondary lookup tables
	as well as eliminates it from ember-data's own lookup tables and book keeping.
	
	Useful when a record has been deleted and the deletion has been persisted and
	we do not care about the record anymore. Especially useful when an `id` of a
	deleted record might be reused later for a new record.
	
	@public
	*/
	forgetRecordIdentifier(identifierObject: RecordIdentifier): void;
	/** @internal */
	destroy(): void;
}
export {};
