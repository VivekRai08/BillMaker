import { ReactiveDocument } from "../../../reactive/-private/document.js";
import type { Cache } from "../../../types/cache.js";
import type { StableDocumentIdentifier, StableRecordIdentifier } from "../../../types/identifier.js";
import type { Value } from "../../../types/json/raw.js";
import type { TypedRecordInstance, TypeFromInstance } from "../../../types/record.js";
import type { OpaqueRecordInstance } from "../../-types/q/record-instance.js";
import RecordReference from "../legacy-model-support/record-reference.js";
import { CacheCapabilitiesManager } from "../managers/cache-capabilities-manager.js";
import type { CacheManager } from "../managers/cache-manager.js";
import type { CreateRecordProperties, Store } from "../store-service.js";
export declare function peekRecordIdentifier(record: OpaqueRecordInstance): StableRecordIdentifier | undefined;
/**
Retrieves the unique referentially-stable [RecordIdentifier](/ember-data/release/classes/StableRecordIdentifier)
assigned to the given record instance.

```js
import { recordIdentifierFor } from "@ember-data/store";
// ... gain access to a record, for instance with peekRecord or findRecord
const record = store.peekRecord("user", "1");
// get the identifier for the record (see docs for StableRecordIdentifier)
const identifier = recordIdentifierFor(record);
// access the identifier's properties.
const { id, type, lid } = identifier;
```

@public
@param {Object} record a record instance previously obstained from the store.
@return {StableRecordIdentifier}
*/
export declare function recordIdentifierFor<T extends TypedRecordInstance>(record: T): StableRecordIdentifier<TypeFromInstance<T>>;
export declare function recordIdentifierFor(record: OpaqueRecordInstance): StableRecordIdentifier;
export declare function setRecordIdentifier(record: OpaqueRecordInstance, identifier: StableRecordIdentifier): void;
export declare const StoreMap: Map<unknown, Store>;
/**
* We may eventually make this public, but its likely better for this to be killed off
* @internal
*/
export declare function storeFor(record: OpaqueRecordInstance): Store | undefined;
type Caches = {
	record: Map<StableRecordIdentifier, OpaqueRecordInstance>;
	reference: WeakMap<StableRecordIdentifier, RecordReference>;
	document: Map<StableDocumentIdentifier, ReactiveDocument<OpaqueRecordInstance | OpaqueRecordInstance[] | null | undefined>>;
};
export declare class InstanceCache {
	store: Store;
	cache: Cache;
	_storeWrapper: CacheCapabilitiesManager;
	__cacheManager: CacheManager;
	__instances: Caches;
	constructor(store: Store);
	peek(identifier: StableRecordIdentifier): Cache | OpaqueRecordInstance | undefined;
	getDocument<T>(identifier: StableDocumentIdentifier): ReactiveDocument<T>;
	getRecord(identifier: StableRecordIdentifier, properties?: CreateRecordProperties): OpaqueRecordInstance;
	getReference(identifier: StableRecordIdentifier): RecordReference;
	recordIsLoaded(identifier: StableRecordIdentifier, filterDeleted?: boolean): boolean;
	disconnect(identifier: StableRecordIdentifier): void;
	unloadRecord(identifier: StableRecordIdentifier): void;
	clear(type?: string): void;
	// TODO this should move into something coordinating operations
	setRecordId(identifier: StableRecordIdentifier, id: string): void;
}
export declare function resourceIsFullyDeleted(instanceCache: InstanceCache, identifier: StableRecordIdentifier): boolean;
export declare function preloadData(store: Store, identifier: StableRecordIdentifier, preload: Record<string, Value>): void;
export declare function _clearCaches(): void;
export {};
