import type { StableDocumentIdentifier } from "../../../types/identifier.js";
import type { ImmutableCreateRequestOptions, ImmutableDeleteRequestOptions, ImmutableRequestInfo, ImmutableUpdateRequestOptions, StructuredDataDocument } from "../../../types/request.js";
import type { ResourceDataDocument, ResourceErrorDocument } from "../../../types/spec/document.js";
import type { ApiError } from "../../../types/spec/error.js";
import type { Store } from "../store-service.js";
export declare const MUTATION_OPS: Set<string>;
export declare function calcShouldFetch(store: Store, request: ImmutableRequestInfo, hasCachedValue: boolean, identifier: StableDocumentIdentifier | null): boolean;
export declare function calcShouldBackgroundFetch(store: Store, request: ImmutableRequestInfo, willFetch: boolean, identifier: StableDocumentIdentifier | null): boolean;
export declare function isMutation(request: Partial<ImmutableRequestInfo>): request is ImmutableUpdateRequestOptions | ImmutableCreateRequestOptions | ImmutableDeleteRequestOptions;
export declare function isCacheAffecting<T>(document: StructuredDataDocument<T>): boolean;
export declare function isAggregateError(error: Error & {
	errors?: ApiError[];
}): error is AggregateError & {
	errors: ApiError[];
};
export type RobustError = Error & {
	error: string | object;
	errors?: ApiError[];
	content?: unknown;
};
// TODO @runspired, consider if we should deep freeze errors (potentially only in debug) vs cloning them
export declare function cloneError(error: RobustError): RobustError;
export declare function isErrorDocument(document: ResourceDataDocument | ResourceErrorDocument): document is ResourceErrorDocument;
export declare function getPriority(identifier: StableDocumentIdentifier | null, deduped: Map<StableDocumentIdentifier, {
	priority: {
		blocking: boolean;
	};
}>, priority: {
	blocking: boolean;
}): {
	blocking: boolean;
};
