import type { CacheCapabilitiesManager, StableRecordIdentifier } from "../../types.js";
import type { RelationshipDiff } from "../../types/cache.js";
import type { MergeOperation } from "../../types/cache/operations.js";
import type { CollectionRelationship, ResourceRelationship } from "../../types/cache/relationship.js";
import type { DeleteRecordOperation, LocalRelationshipOperation, RemoteRelationshipOperation } from "../../types/graph.js";
import type { EdgeCache, UpgradedMeta } from "./-edge-definition.js";
import { type CollectionEdge } from "./edges/collection.js";
import type { ImplicitEdge } from "./edges/implicit.js";
import { type ResourceEdge } from "./edges/resource.js";
export type GraphEdge = ImplicitEdge | CollectionEdge | ResourceEdge;
export declare const Graphs: Map<CacheCapabilitiesManager, Graph>;
type PendingOps = {
	belongsTo?: Map<string, Map<string, RemoteRelationshipOperation[]>>;
	hasMany?: Map<string, Map<string, RemoteRelationshipOperation[]>>;
	deletions: DeleteRecordOperation[];
};
/*
* Graph acts as the cache for relationship data. It allows for
* us to ask about and update relationships for a given Identifier
* without requiring other objects for that Identifier to be
* instantiated (such as `RecordData` or a `Record`)
*
* This also allows for us to make more substantive changes to relationships
* with increasingly minor alterations to other portions of the internals
* over time.
*
* The graph is made up of nodes and edges. Each unique identifier gets
* its own node, which is a dictionary with a list of that node's edges
* (or connections) to other nodes. In `Model` terms, a node represents a
* record instance, with each key (an edge) in the dictionary correlating
* to either a `hasMany` or `belongsTo` field on that record instance.
*
* The value for each key, or `edge` is the identifier(s) the node relates
* to in the graph from that key.
*/
export declare class Graph {
	_definitionCache: EdgeCache;
	_metaCache: Record<string, Record<string, UpgradedMeta>>;
	_potentialPolymorphicTypes: Record<string, Record<string, boolean>>;
	identifiers: Map<StableRecordIdentifier, Record<string, GraphEdge>>;
	store: CacheCapabilitiesManager;
	isDestroyed: boolean;
	_willSyncRemote: boolean;
	_willSyncLocal: boolean;
	silenceNotifications: boolean;
	_pushedUpdates: PendingOps;
	_updatedRelationships: Set<CollectionEdge>;
	_transaction: number | null;
	_removing: StableRecordIdentifier | null;
	constructor(store: CacheCapabilitiesManager);
	has(identifier: StableRecordIdentifier, propertyName: string): boolean;
	getDefinition(identifier: StableRecordIdentifier, propertyName: string): UpgradedMeta;
	get(identifier: StableRecordIdentifier, propertyName: string): GraphEdge;
	getData(identifier: StableRecordIdentifier, propertyName: string): ResourceRelationship | CollectionRelationship;
	getRemoteData(identifier: StableRecordIdentifier, propertyName: string): ResourceRelationship | CollectionRelationship;
	/*
	* Allows for the graph to dynamically discover polymorphic connections
	* without needing to walk prototype chains.
	*
	* Used by edges when an added `type` does not match the expected `type`
	* for that edge.
	*
	* Currently we assert before calling this. For a public API we will want
	* to call out to the schema manager to ask if we should consider these
	* types as equivalent for a given relationship.
	*/
	registerPolymorphicType(type1: string, type2: string): void;
	isReleasable(identifier: StableRecordIdentifier): boolean;
	unload(identifier: StableRecordIdentifier, silenceNotifications?: boolean): void;
	_isDirty(identifier: StableRecordIdentifier, field: string): boolean;
	getChanged(identifier: StableRecordIdentifier): Map<string, RelationshipDiff>;
	hasChanged(identifier: StableRecordIdentifier): boolean;
	rollback(identifier: StableRecordIdentifier): string[];
	remove(identifier: StableRecordIdentifier): void;
	/*
	* Remote state changes
	*/
	push(op: RemoteRelationshipOperation): void;
	/*
	* Local state changes
	*/
	update(op: RemoteRelationshipOperation | MergeOperation, isRemote: true): void;
	update(op: LocalRelationshipOperation, isRemote?: false): void;
	_scheduleLocalSync(relationship: CollectionEdge): void;
	_flushRemoteQueue(): void;
	_addToTransaction(relationship: CollectionEdge | ResourceEdge): void;
	_flushLocalQueue(): void;
	destroy(): void;
}
export {};
