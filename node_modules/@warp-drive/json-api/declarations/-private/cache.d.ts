import type { Graph } from "@warp-drive/core/graph/-private";
import type { CacheCapabilitiesManager } from "@warp-drive/core/types";
import type { Cache, ChangedAttributesHash, RelationshipDiff } from "@warp-drive/core/types/cache";
import type { Change } from "@warp-drive/core/types/cache/change";
import type { Operation } from "@warp-drive/core/types/cache/operations";
import type { CollectionRelationship, ResourceRelationship } from "@warp-drive/core/types/cache/relationship";
import type { LocalRelationshipOperation } from "@warp-drive/core/types/graph";
import type { StableDocumentIdentifier, StableExistingRecordIdentifier, StableRecordIdentifier } from "@warp-drive/core/types/identifier";
import type { Value } from "@warp-drive/core/types/json/raw";
import type { StructuredDataDocument, StructuredDocument, StructuredErrorDocument } from "@warp-drive/core/types/request";
import type { CollectionResourceDataDocument, ResourceDocument, ResourceErrorDocument, ResourceMetaDocument, SingleResourceDataDocument } from "@warp-drive/core/types/spec/document";
import type { ApiError } from "@warp-drive/core/types/spec/error";
import type { CollectionResourceDocument, ExistingResourceObject, ResourceObject, SingleResourceDocument } from "@warp-drive/core/types/spec/json-api-raw";
interface CachedResource {
	id: string | null;
	remoteAttrs: Record<string, Value | undefined> | null;
	localAttrs: Record<string, Value | undefined> | null;
	defaultAttrs: Record<string, Value | undefined> | null;
	inflightAttrs: Record<string, Value | undefined> | null;
	changes: Record<string, [Value | undefined, Value]> | null;
	errors: ApiError[] | null;
	isNew: boolean;
	isDeleted: boolean;
	isDeletionCommitted: boolean;
	/**
	* debugging only
	*
	* @internal
	*/
	inflightRelationships?: Record<string, unknown> | null;
}
/**
* ### JSONAPICache
*
* ```ts
* import { JSONAPICache } from '@warp-drive/json-api';
* ```
*
A {@link Cache} implementation tuned for [{json:api}](https://jsonapi.org/)

This format excels at simiplifying common complex problems around cache
consistency and information density. Because most API responses can be quickly
transformed into {json:api} format without losing any information, WarpDrive
recommends that most apps use this Cache implementation.

If a cache built to understand another format would do better for your app then
it just needs to follow the same interface.

Do you really need a cache? Are sunsets beautiful? Caching is what powers features like
immutability, mutation management, and allows ***Warp*Drive** to understand your relational
data.

Some caches are simple request/response maps. ***Warp*Drive**'s is not. The Cache deeply
understands the structure of your data, ensuring your data remains consistent both within
and across requests.

### Installation

::: code-group

```sh [pnpm]
pnpm add -E @warp-drive/core@latest @warp-drive/json-api@latest
```

```sh [npm]
npm add -E @warp-drive/core@latest @warp-drive/json-api@latest
```

```sh [yarn]
yarn add -E @warp-drive/core@latest @warp-drive/json-api@latest
```

```sh [bun]
bun add --exact @warp-drive/core@latest @warp-drive/json-api@latest
```

:::

### Setup

```ts [services/store.ts]
import { Fetch, RequestManager, Store } from '@warp-drive/core';
import {
registerDerivations,
SchemaService,
} from '@warp-drive/core/reactive';
import { CacheHandler } from '@warp-drive/core/store';
import type { CacheCapabilitiesManager } from '@warp-drive/core/types'; // [!code focus:2]
import { JSONAPICache } from '@warp-drive/json-api';

export default class AppStore extends Store {

requestManager = new RequestManager()
.use([Fetch])
.useCache(CacheHandler);

createSchemaService() {
const schema = new SchemaService();
registerDerivations(schema);
return schema;
}

createCache(capabilities: CacheCapabilitiesManager) { // [!code focus:3]
return new JSONAPICache(capabilities);
}
}
```

* @categoryDescription Cache Management
* APIs for primary cache management functionality
* @categoryDescription Cache Forking
* APIs that support Cache Forking
* @categoryDescription SSR Support
* APIs that support SSR functionality
* @categoryDescription Resource Lifecycle
* APIs that support management of resource data
* @categoryDescription Resource Data
* APIs that support granular field level management of resource data
* @categoryDescription Resource State
* APIs that support managing Resource states

@public
*/
export declare class JSONAPICache implements Cache {
	/**
	* The Cache Version that this implementation implements.
	*
	* @public
	*/
	version: "2";
	/** @internal */
	_capabilities: CacheCapabilitiesManager;
	/** @internal */
	__cache: Map<StableRecordIdentifier, CachedResource>;
	/** @internal */
	__destroyedCache: Map<StableRecordIdentifier, CachedResource>;
	/** @internal */
	__documents: Map<string, StructuredDocument<ResourceDocument>>;
	/** @internal */
	__graph: Graph;
	constructor(capabilities: CacheCapabilitiesManager);
	////////// ================ //////////
	////////// Cache Management //////////
	////////// ================ //////////
	/**
	* Cache the response to a request
	*
	* Implements `Cache.put`.
	*
	* Expects a StructuredDocument whose `content` member is a JsonApiDocument.
	*
	* ```js
	* cache.put({
	*   request: { url: 'https://api.example.com/v1/user/1' },
	*   content: {
	*     data: {
	*       type: 'user',
	*       id: '1',
	*       attributes: {
	*         name: 'Chris'
	*       }
	*     }
	*   }
	* })
	* ```
	*
	* > **Note**
	* > The nested `content` and `data` members are not a mistake. This is because
	* > there are two separate concepts involved here, the `StructuredDocument` which contains
	* > the context of a given Request that has been issued with the returned contents as its
	* > `content` property, and a `JSON:API Document` which is the json contents returned by
	* > this endpoint and which uses its `data` property to signify which resources are the
	* > primary resources associated with the request.
	*
	* StructuredDocument's with urls will be cached as full documents with
	* associated resource membership order and contents preserved but linked
	* into the cache.
	*
	* @category Cache Management
	* @public
	*/
	put<T extends SingleResourceDocument>(doc: StructuredDataDocument<T>): SingleResourceDataDocument;
	put<T extends CollectionResourceDocument>(doc: StructuredDataDocument<T>): CollectionResourceDataDocument;
	put<T extends ResourceErrorDocument>(doc: StructuredErrorDocument<T>): ResourceErrorDocument;
	put<T extends ResourceMetaDocument>(doc: StructuredDataDocument<T>): ResourceMetaDocument;
	/** @internal */
	_putDocument<T extends ResourceErrorDocument>(doc: StructuredErrorDocument<T>, data: undefined, included: undefined): ResourceErrorDocument;
	_putDocument<T extends ResourceMetaDocument>(doc: StructuredDataDocument<T>, data: undefined, included: undefined): ResourceMetaDocument;
	_putDocument<T extends SingleResourceDocument>(doc: StructuredDataDocument<T>, data: StableExistingRecordIdentifier | null, included: StableExistingRecordIdentifier[] | undefined): SingleResourceDataDocument;
	_putDocument<T extends CollectionResourceDocument>(doc: StructuredDataDocument<T>, data: StableExistingRecordIdentifier[], included: StableExistingRecordIdentifier[] | undefined): CollectionResourceDataDocument;
	/**
	* Update the "remote" or "canonical" (persisted) state of the Cache
	* by merging new information into the existing state.
	*
	* @category Cache Management
	* @public
	* @param op the operation or list of operations to perform
	*/
	patch(op: Operation | Operation[]): void;
	/**
	* Update the "local" or "current" (unpersisted) state of the Cache
	*
	* @category Cache Management
	* @public
	*/
	mutate(mutation: LocalRelationshipOperation): void;
	/**
	* Peek resource data from the Cache.
	*
	* In development, if the return value
	* is JSON the return value
	* will be deep-cloned and deep-frozen
	* to prevent mutation thereby enforcing cache
	* Immutability.
	*
	* This form of peek is useful for implementations
	* that want to feed raw-data from cache to the UI
	* or which want to interact with a blob of data
	* directly from the presentation cache.
	*
	* An implementation might want to do this because
	* de-referencing records which read from their own
	* blob is generally safer because the record does
	* not require retainining connections to the Store
	* and Cache to present data on a per-field basis.
	*
	* This generally takes the place of `getAttr` as
	* an API and may even take the place of `getRelationship`
	* depending on implementation specifics, though this
	* latter usage is less recommended due to the advantages
	* of the Graph handling necessary entanglements and
	* notifications for relational data.
	*
	* @category Cache Management
	* @public
	*/
	peek(identifier: StableRecordIdentifier): ResourceObject | null;
	peek(identifier: StableDocumentIdentifier): ResourceDocument | null;
	/**
	* Peek the remote resource data from the Cache.
	*
	* @category Cache Management
	* @public
	*/
	peekRemoteState(identifier: StableRecordIdentifier): ResourceObject | null;
	peekRemoteState(identifier: StableDocumentIdentifier): ResourceDocument | null;
	/**
	* Peek the Cache for the existing request data associated with
	* a cacheable request.
	*
	* This is effectively the reverse of `put` for a request in
	* that it will return the the request, response, and content
	* whereas `peek` will return just the `content`.
	*
	* @category Cache Management
	* @public
	*/
	peekRequest(identifier: StableDocumentIdentifier): StructuredDocument<ResourceDocument> | null;
	/**
	* Push resource data from a remote source into the cache for this identifier
	*
	* @category Cache Management
	* @public
	* @return if `calculateChanges` is true then calculated key changes should be returned
	*/
	upsert(identifier: StableRecordIdentifier, data: ExistingResourceObject, calculateChanges?: boolean): void | string[];
	////////// ============= //////////
	////////// Cache Forking //////////
	////////// ============= //////////
	/**
	* Create a fork of the cache from the current state.
	*
	* Applications should typically not call this method themselves,
	* preferring instead to fork at the Store level, which will
	* utilize this method to fork the cache.
	*
	* @category Cache Forking
	* @internal
	*/
	fork(): Promise<Cache>;
	/**
	* Merge a fork back into a parent Cache.
	*
	* Applications should typically not call this method themselves,
	* preferring instead to merge at the Store level, which will
	* utilize this method to merge the caches.
	*
	* @category Cache Forking
	* @internal
	*/
	merge(_cache: Cache): Promise<void>;
	/**
	* Generate the list of changes applied to all
	* record in the store.
	*
	* Each individual resource or document that has
	* been mutated should be described as an individual
	* `Change` entry in the returned array.
	*
	* A `Change` is described by an object containing up to
	* three properties: (1) the `identifier` of the entity that
	* changed; (2) the `op` code of that change being one of
	* `upsert` or `remove`, and if the op is `upsert` a `patch`
	* containing the data to merge into the cache for the given
	* entity.
	*
	* This `patch` is opaque to the Store but should be understood
	* by the Cache and may expect to be utilized by an Adapter
	* when generating data during a `save` operation.
	*
	* It is generally recommended that the `patch` contain only
	* the updated state, ignoring fields that are unchanged
	*
	* ```ts
	* interface Change {
	*  identifier: StableRecordIdentifier | StableDocumentIdentifier;
	*  op: 'upsert' | 'remove';
	*  patch?: unknown;
	* }
	* ```
	*
	* @category Cache Forking
	* @internal
	*/
	diff(): Promise<Change[]>;
	////////// =========== //////////
	////////// SSR Support //////////
	////////// =========== //////////
	/**
	* Serialize the entire contents of the Cache into a Stream
	* which may be fed back into a new instance of the same Cache
	* via `cache.hydrate`.
	*
	* @category SSR Support
	* @internal
	*/
	dump(): Promise<ReadableStream<unknown>>;
	/**
	* hydrate a Cache from a Stream with content previously serialized
	* from another instance of the same Cache, resolving when hydration
	* is complete.
	*
	* This method should expect to be called both in the context of restoring
	* the Cache during application rehydration after SSR **AND** at unknown
	* times during the lifetime of an already booted application when it is
	* desired to bulk-load additional information into the cache. This latter
	* behavior supports optimizing pre/fetching of data for route transitions
	* via data-only SSR modes.
	*
	* @category SSR Support
	* @internal
	*/
	hydrate(stream: ReadableStream<unknown>): Promise<void>;
	////////// ================== //////////
	////////// Resource Lifecycle //////////
	////////// ================== //////////
	/**
	* [LIFECYCLE] Signal to the cache that a new record has been instantiated on the client
	*
	* It returns properties from options that should be set on the record during the create
	* process. This return value behavior is deprecated.
	*
	* @category Resource Lifecycle
	* @public
	*/
	clientDidCreate(identifier: StableRecordIdentifier, options?: Record<string, Value>): Record<string, unknown>;
	/**
	* [LIFECYCLE] Signals to the cache that a resource
	* will be part of a save transaction.
	*
	* @category Resource Lifecycle
	* @public
	*/
	willCommit(identifier: StableRecordIdentifier): void;
	/**
	* [LIFECYCLE] Signals to the cache that a resource
	* was successfully updated as part of a save transaction.
	*
	* @category Resource Lifecycle
	* @public
	*/
	didCommit(committedIdentifier: StableRecordIdentifier, result: StructuredDataDocument<SingleResourceDocument>): SingleResourceDataDocument;
	/**
	* [LIFECYCLE] Signals to the cache that a resource
	* was update via a save transaction failed.
	*
	* @category Resource Lifecycle
	* @public
	*/
	commitWasRejected(identifier: StableRecordIdentifier, errors?: ApiError[]): void;
	/**
	* [LIFECYCLE] Signals to the cache that all data for a resource
	* should be cleared.
	*
	* This method is a candidate to become a mutation
	*
	* @category Resource Lifecycle
	* @public
	*/
	unloadRecord(identifier: StableRecordIdentifier): void;
	////////// ============= //////////
	////////// Resource Data //////////
	////////// ============= //////////
	/**
	* Retrieve the data for an attribute from the cache
	* with local mutations applied.
	*
	* @category Resource Data
	* @public
	*/
	getAttr(identifier: StableRecordIdentifier, attr: string | string[]): Value | undefined;
	/**
	* Retrieve the remote data for an attribute from the cache
	*
	* @category Resource Data
	* @public
	*/
	getRemoteAttr(identifier: StableRecordIdentifier, attr: string | string[]): Value | undefined;
	/**
	* Mutate the data for an attribute in the cache
	*
	* This method is a candidate to become a mutation
	*
	* @category Resource Data
	* @public
	*/
	setAttr(identifier: StableRecordIdentifier, attr: string | string[], value: Value): void;
	/**
	* Query the cache for the changed attributes of a resource.
	*
	* @category Resource Data
	* @public
	* @return `{ '<field>': ['<old>', '<new>'] }`
	*/
	changedAttrs(identifier: StableRecordIdentifier): ChangedAttributesHash;
	/**
	* Query the cache for whether any mutated attributes exist
	*
	* @category Resource Data
	* @public
	*/
	hasChangedAttrs(identifier: StableRecordIdentifier): boolean;
	/**
	* Tell the cache to discard any uncommitted mutations to attributes
	*
	* This method is a candidate to become a mutation
	*
	* @category Resource Data
	* @public
	* @return the names of fields that were restored
	*/
	rollbackAttrs(identifier: StableRecordIdentifier): string[];
	/**
	* Query the cache for the changes to relationships of a resource.
	*
	* Returns a map of relationship names to RelationshipDiff objects.
	*
	* ```ts
	* type RelationshipDiff =
	| {
	kind: 'collection';
	remoteState: StableRecordIdentifier[];
	additions: Set<StableRecordIdentifier>;
	removals: Set<StableRecordIdentifier>;
	localState: StableRecordIdentifier[];
	reordered: boolean;
	}
	| {
	kind: 'resource';
	remoteState: StableRecordIdentifier | null;
	localState: StableRecordIdentifier | null;
	};
	```
	*
	* @category Resource Data
	* @public
	*/
	changedRelationships(identifier: StableRecordIdentifier): Map<string, RelationshipDiff>;
	/**
	* Query the cache for whether any mutated relationships exist
	*
	* @category Resource Data
	* @public
	*/
	hasChangedRelationships(identifier: StableRecordIdentifier): boolean;
	/**
	* Tell the cache to discard any uncommitted mutations to relationships.
	*
	* This will also discard the change on any appropriate inverses.
	*
	* This method is a candidate to become a mutation
	*
	* @category Resource Data
	* @public
	* @return the names of relationships that were restored
	*/
	rollbackRelationships(identifier: StableRecordIdentifier): string[];
	/**
	* Query the cache for the current state of a relationship property
	*
	* @category Resource Data
	* @public
	* @return resource relationship object
	*/
	getRelationship(identifier: StableRecordIdentifier, field: string): ResourceRelationship | CollectionRelationship;
	/**
	* Query the cache for the remote state of a relationship property
	*
	* @category Resource Data
	* @public
	* @return resource relationship object
	*/
	getRemoteRelationship(identifier: StableRecordIdentifier, field: string): ResourceRelationship | CollectionRelationship;
	////////// ============== //////////
	////////// Resource State //////////
	////////// ============== //////////
	/**
	* Update the cache state for the given resource to be marked
	* as locally deleted, or remove such a mark.
	*
	* This method is a candidate to become a mutation
	*
	* @category Resource State
	* @public
	*/
	setIsDeleted(identifier: StableRecordIdentifier, isDeleted: boolean): void;
	/**
	* Query the cache for any validation errors applicable to the given resource.
	*
	* @category Resource State
	* @public
	*/
	getErrors(identifier: StableRecordIdentifier): ApiError[];
	/**
	* Query the cache for whether a given resource has any available data
	*
	* @category Resource State
	* @public
	*/
	isEmpty(identifier: StableRecordIdentifier): boolean;
	/**
	* Query the cache for whether a given resource was created locally and not
	* yet persisted.
	*
	* @category Resource State
	* @public
	*/
	isNew(identifier: StableRecordIdentifier): boolean;
	/**
	* Query the cache for whether a given resource is marked as deleted (but not
	* necessarily persisted yet).
	*
	* @category Resource State
	* @public
	*/
	isDeleted(identifier: StableRecordIdentifier): boolean;
	/**
	* Query the cache for whether a given resource has been deleted and that deletion
	* has also been persisted.
	*
	* @category Resource State
	* @public
	*/
	isDeletionCommitted(identifier: StableRecordIdentifier): boolean;
	/**
	* Private method used to populate an entry for the identifier
	*
	* @internal
	*/
	_createCache(identifier: StableRecordIdentifier): CachedResource;
	/**
	* Peek whether we have cached resource data matching the identifier
	* without asserting if the resource data is missing.
	*
	* @internal
	*/
	__safePeek(identifier: StableRecordIdentifier, allowDestroyed: boolean): CachedResource | undefined;
	/**
	* Peek whether we have cached resource data matching the identifier
	* Asserts if the resource data is missing.
	*
	* @internal
	*/
	__peek(identifier: StableRecordIdentifier, allowDestroyed: boolean): CachedResource;
}
export {};
