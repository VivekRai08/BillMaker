import type PromiseProxyMixin from "@ember/object/promise-proxy-mixin";
import type ObjectProxy from "@ember/object/proxy";
import type { Store } from "@warp-drive/core";
import type { OpaqueRecordInstance, TypeFromInstanceOrString } from "@warp-drive/core/types/record";
import type { LegacySupport } from "./legacy-relationships-support.js";
export interface BelongsToProxyMeta<T = unknown> {
	key: string;
	store: Store;
	legacySupport: LegacySupport;
	modelName: TypeFromInstanceOrString<T>;
}
export interface BelongsToProxyCreateArgs<T = unknown> {
	promise: Promise<T | null>;
	content?: T | null;
	_belongsToState: BelongsToProxyMeta<T>;
}
export declare const LegacyPromiseProxy: unique symbol;
interface PromiseObjectType<T> extends PromiseProxyMixin<T | null>, ObjectProxy<T> {
	// eslint-disable-next-line @typescript-eslint/no-misused-new
	new <PT>(...args: unknown[]): PromiseObjectType<PT>;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-extraneous-class
declare class PromiseObjectType<T> {}
declare const Extended: PromiseObjectType<OpaqueRecordInstance>;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
interface PromiseBelongsTo<T> {
	[LegacyPromiseProxy]: true;
}
/**
A PromiseBelongsTo is a PromiseObject that also proxies certain method calls
to the underlying belongsTo model.
Right now we proxy:
* `reload()`
@class PromiseBelongsTo
@private
*/
declare class PromiseBelongsTo<T = unknown> extends Extended<T> {
	_belongsToState: BelongsToProxyMeta<T>;
	get id(): string | null;
	// we don't proxy meta because we would need to proxy it to the relationship state container
	//  however, meta on relationships does not trigger change notifications.
	//  if you need relationship meta, you should do `record.belongsTo(relationshipName).meta()`
	get meta(): void;
	reload(options: Record<string, unknown>): Promise<this>;
}
export { PromiseBelongsTo };
