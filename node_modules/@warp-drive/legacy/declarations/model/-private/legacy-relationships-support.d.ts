import type { Store } from "@warp-drive/core";
import type { CollectionEdge, Graph, ResourceEdge, UpgradedMeta } from "@warp-drive/core/graph/-private";
import type { LiveArray } from "@warp-drive/core/store/-private";
import { RelatedCollection as ManyArray } from "@warp-drive/core/store/-private";
import type { BaseFinderOptions, StableRecordIdentifier } from "@warp-drive/core/types";
import type { Cache } from "@warp-drive/core/types/cache";
import type { CollectionRelationship } from "@warp-drive/core/types/cache/relationship";
import type { LocalRelationshipOperation } from "@warp-drive/core/types/graph";
import type { OpaqueRecordInstance, TypeFromInstanceOrString } from "@warp-drive/core/types/record";
import type { CollectionResourceRelationship, InnerRelationshipDocument, SingleResourceRelationship } from "@warp-drive/core/types/spec/json-api-raw";
import type { MinimalLegacyRecord } from "./model-methods.js";
import type { BelongsToProxyCreateArgs } from "./promise-belongs-to.js";
import { PromiseBelongsTo } from "./promise-belongs-to.js";
import type { HasManyProxyCreateArgs } from "./promise-many-array.js";
import { PromiseManyArray } from "./promise-many-array.js";
import BelongsToReference from "./references/belongs-to.js";
import HasManyReference from "./references/has-many.js";
export declare const LEGACY_SUPPORT: Map<StableRecordIdentifier | MinimalLegacyRecord, LegacySupport>;
export declare function lookupLegacySupport(record: MinimalLegacyRecord): LegacySupport;
export declare class LegacySupport {
	record: MinimalLegacyRecord;
	store: Store;
	graph: Graph;
	cache: Cache;
	references: Record<string, BelongsToReference | HasManyReference>;
	identifier: StableRecordIdentifier;
	_manyArrayCache: Record<string, ManyArray>;
	_relationshipPromisesCache: Record<string, Promise<ManyArray | OpaqueRecordInstance>>;
	_relationshipProxyCache: Record<string, PromiseManyArray | PromiseBelongsTo | undefined>;
	_pending: Record<string, Promise<StableRecordIdentifier | null> | undefined>;
	isDestroying: boolean;
	isDestroyed: boolean;
	constructor(record: MinimalLegacyRecord);
	_syncArray(array: LiveArray): void;
	mutate(mutation: LocalRelationshipOperation): void;
	_findBelongsTo(key: string, resource: SingleResourceRelationship, relationship: ResourceEdge, options?: BaseFinderOptions): Promise<OpaqueRecordInstance | null>;
	reloadBelongsTo(key: string, options?: BaseFinderOptions): Promise<OpaqueRecordInstance | null>;
	getBelongsTo(key: string, options?: BaseFinderOptions): PromiseBelongsTo | OpaqueRecordInstance | null;
	setDirtyBelongsTo(key: string, value: OpaqueRecordInstance | null): void;
	_getCurrentState<T>(identifier: StableRecordIdentifier, field: string): [StableRecordIdentifier<TypeFromInstanceOrString<T>>[], CollectionRelationship];
	getManyArray<T>(key: string, definition?: UpgradedMeta): ManyArray<T>;
	fetchAsyncHasMany(key: string, relationship: CollectionEdge, manyArray: ManyArray, options?: BaseFinderOptions): Promise<ManyArray>;
	reloadHasMany<T>(key: string, options?: BaseFinderOptions): Promise<ManyArray<T>> | PromiseManyArray<T>;
	getHasMany(key: string, options?: BaseFinderOptions): PromiseManyArray | ManyArray;
	_updatePromiseProxyFor(kind: "hasMany", key: string, args: HasManyProxyCreateArgs): PromiseManyArray;
	_updatePromiseProxyFor(kind: "belongsTo", key: string, args: BelongsToProxyCreateArgs): PromiseBelongsTo;
	_updatePromiseProxyFor(kind: "belongsTo", key: string, args: {
		promise: Promise<OpaqueRecordInstance | null>;
	}): PromiseBelongsTo;
	referenceFor(kind: "belongsTo", name: string): BelongsToReference;
	referenceFor(kind: "hasMany", name: string): HasManyReference;
	_findHasManyByJsonApiResource(resource: CollectionResourceRelationship, parentIdentifier: StableRecordIdentifier, relationship: CollectionEdge, options?: BaseFinderOptions): Promise<void | unknown[]> | void;
	_findBelongsToByJsonApiResource(resource: SingleResourceRelationship, parentIdentifier: StableRecordIdentifier, relationship: ResourceEdge, options?: BaseFinderOptions): Promise<StableRecordIdentifier | null>;
	destroy(): void;
}
export declare function areAllInverseRecordsLoaded(store: Store, resource: InnerRelationshipDocument): boolean;
