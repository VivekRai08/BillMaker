import type { JsonApiError } from "@warp-drive/core/store/-types/q/record-data-json-api";
export interface AdapterRequestError<T extends string = string> extends Error {
	isAdapterError: true;
	code: T;
	errors: JsonApiError[];
}
export interface AdapterRequestErrorConstructor<Instance extends AdapterRequestError = AdapterRequestError> {
	new (errors?: unknown[], message?: string): Instance;
	extend(options: {
		message: string;
	}): AdapterRequestErrorConstructor;
}
export type AdapterError = AdapterRequestError<"AdapterError">;
export declare const AdapterError: AdapterRequestErrorConstructor<AdapterError>;
/**
A `InvalidError` is used by an adapter to signal the external API
was unable to process a request because the content was not
semantically correct or meaningful per the API. Usually, this means a
record failed some form of server-side validation. When a promise
from an adapter is rejected with a `InvalidError` the record will
transition to the `invalid` state and the errors will be set to the
`errors` property on the record.

For Ember Data to correctly map errors to their corresponding
properties on the model, Ember Data expects each error to be
a valid JSON-API error object with a `source/pointer` that matches
the property name. For example, if you had a Post model that
looked like this.

```js [app/models/post.js]
import { Model, attr } from '@warp-drive/legacy/model';

export default class PostModel extends Model {
@attr('string') title;
@attr('string') content;
}
```

To show an error from the server related to the `title` and
`content` properties your adapter could return a promise that
rejects with a `InvalidError` object that looks like this:

```js [app/adapters/post.js]
import RSVP from 'RSVP';
import RESTAdapter from '@ember-data/adapter/rest';
import { InvalidError } from '@ember-data/adapter/error';

export default class ApplicationAdapter extends RESTAdapter {
updateRecord() {
// Fictional adapter that always rejects
return RSVP.reject(new InvalidError([
{
detail: 'Must be unique',
source: { pointer: '/data/attributes/title' }
},
{
detail: 'Must not be blank',
source: { pointer: '/data/attributes/content'}
}
]));
}
}
```

Your backend may use different property names for your records the
store will attempt to extract and normalize the errors using the
serializer's `extractErrors` method before the errors get added to
the model. As a result, it is safe for the `InvalidError` to
wrap the error payload unaltered.

@class InvalidError
@public
*/
// TODO @deprecate extractError documentation
export type InvalidError = AdapterRequestError<"InvalidError">;
export declare const InvalidError: AdapterRequestErrorConstructor<InvalidError>;
/**
A `TimeoutError` is used by an adapter to signal that a request
to the external API has timed out. I.e. no response was received from
the external API within an allowed time period.

An example use case would be to warn the user to check their internet
connection if an adapter operation has timed out:

```js [app/routes/application.js]
import { TimeoutError } from '@ember-data/adapter/error';

export default class ApplicationRoute extends Route {
@action
error(error, transition) {
if (error instanceof TimeoutError) {
// alert the user
alert('Are you still connected to the Internet?');
return;
}

// ...other error handling logic
}
}
```

@class TimeoutError
@public
*/
export type TimeoutError = AdapterRequestError<"TimeoutError">;
export declare const TimeoutError: AdapterRequestErrorConstructor<TimeoutError>;
/**
A `AbortError` is used by an adapter to signal that a request to
the external API was aborted. For example, this can occur if the user
navigates away from the current page after a request to the external API
has been initiated but before a response has been received.

@class AbortError
@public
*/
export type AbortError = AdapterRequestError<"AbortError">;
export declare const AbortError: AdapterRequestErrorConstructor<AbortError>;
/**
A `UnauthorizedError` equates to a HTTP `401 Unauthorized` response
status. It is used by an adapter to signal that a request to the external
API was rejected because authorization is required and has failed or has not
yet been provided.

An example use case would be to redirect the user to a login route if a
request is unauthorized:

```js [app/routes/application.js]
import { UnauthorizedError } from '@ember-data/adapter/error';

export default class ApplicationRoute extends Route {
@action
error(error, transition) {
if (error instanceof UnauthorizedError) {
// go to the login route
this.transitionTo('login');
return;
}

// ...other error handling logic
}
}
```

@class UnauthorizedError
@public
*/
export type UnauthorizedError = AdapterRequestError<"UnauthorizedError">;
export declare const UnauthorizedError: AdapterRequestErrorConstructor<UnauthorizedError>;
/**
A `ForbiddenError` equates to a HTTP `403 Forbidden` response status.
It is used by an adapter to signal that a request to the external API was
valid but the server is refusing to respond to it. If authorization was
provided and is valid, then the authenticated user does not have the
necessary permissions for the request.

@class ForbiddenError
@public
*/
export type ForbiddenError = AdapterRequestError<"ForbiddenError">;
export declare const ForbiddenError: AdapterRequestErrorConstructor<ForbiddenError>;
/**
A `NotFoundError` equates to a HTTP `404 Not Found` response status.
It is used by an adapter to signal that a request to the external API
was rejected because the resource could not be found on the API.

An example use case would be to detect if the user has entered a route
for a specific model that does not exist. For example:

```js [app/routes/post.js]
import { NotFoundError } from '@ember-data/adapter/error';

export default class PostRoute extends Route {
@service store;
model(params) {
return this.store.findRecord('post', params.post_id);
}
@action
error(error, transition) {
if (error instanceof NotFoundError) {
// redirect to a list of all posts instead
this.transitionTo('posts');
} else {
// otherwise let the error bubble
return true;
}
}
}
```

@class NotFoundError
@public
*/
export type NotFoundError = AdapterRequestError<"NotFoundError">;
export declare const NotFoundError: AdapterRequestErrorConstructor<NotFoundError>;
/**
A `ConflictError` equates to a HTTP `409 Conflict` response status.
It is used by an adapter to indicate that the request could not be processed
because of a conflict in the request. An example scenario would be when
creating a record with a client-generated ID but that ID is already known
to the external API.

@class ConflictError
@public
*/
export type ConflictError = AdapterRequestError<"ConflictError">;
export declare const ConflictError: AdapterRequestErrorConstructor<ConflictError>;
/**
A `ServerError` equates to a HTTP `500 Internal Server Error` response
status. It is used by the adapter to indicate that a request has failed
because of an error in the external API.

@class ServerError
@public
*/
export type ServerError = AdapterRequestError<"ServerError">;
export declare const ServerError: AdapterRequestErrorConstructor<ServerError>;
