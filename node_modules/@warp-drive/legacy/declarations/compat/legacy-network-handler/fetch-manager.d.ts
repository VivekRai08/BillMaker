import type { Store } from "@warp-drive/core";
import { createDeferred } from "@warp-drive/core/request";
import type { Request, RequestStateService } from "@warp-drive/core/store/-private";
import type { FindRecordOptions } from "@warp-drive/core/types";
import type { StableExistingRecordIdentifier, StableRecordIdentifier } from "@warp-drive/core/types/identifier";
import type { TypeFromInstance } from "@warp-drive/core/types/record";
import type { ImmutableRequestInfo } from "@warp-drive/core/types/request";
import type { SingleResourceDocument } from "@warp-drive/core/types/spec/json-api-raw";
import { Snapshot } from "./snapshot.js";
type Deferred<T> = ReturnType<typeof createDeferred<T>>;
export declare const SaveOp: "___(unique) Symbol(SaveOp)";
export type FetchMutationOptions = FindRecordOptions & {
	[SaveOp]: "createRecord" | "deleteRecord" | "updateRecord";
};
interface PendingFetchItem {
	identifier: StableExistingRecordIdentifier;
	queryRequest: Request;
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	resolver: Deferred<any>;
	options: FindRecordOptions;
	trace?: unknown;
	promise: Promise<StableExistingRecordIdentifier>;
}
export declare class FetchManager {
	isDestroyed: boolean;
	requestCache: RequestStateService;
	// fetches pending in the runloop, waiting to be coalesced
	_pendingFetch: Map<string, Map<StableExistingRecordIdentifier, PendingFetchItem[]>>;
	_store: Store;
	constructor(store: Store);
	createSnapshot<T>(identifier: StableRecordIdentifier<TypeFromInstance<T>>, options?: FindRecordOptions): Snapshot<T>;
	createSnapshot(identifier: StableRecordIdentifier, options?: FindRecordOptions): Snapshot;
	/**
	This method is called by `record.save`, and gets passed a
	resolver for the promise that `record.save` returns.
	
	It schedules saving to happen at the end of the run loop.
	
	@internal
	*/
	scheduleSave(identifier: StableRecordIdentifier, options: FetchMutationOptions): Promise<null | SingleResourceDocument>;
	scheduleFetch(identifier: StableExistingRecordIdentifier, options: FindRecordOptions, request: ImmutableRequestInfo): Promise<StableExistingRecordIdentifier>;
	getPendingFetch(identifier: StableExistingRecordIdentifier, options: FindRecordOptions): Promise<StableExistingRecordIdentifier> | undefined;
	flushAllPendingFetches(): void;
	fetchDataIfNeededForIdentifier(identifier: StableExistingRecordIdentifier, options: FindRecordOptions | undefined, request: ImmutableRequestInfo): Promise<StableExistingRecordIdentifier>;
	destroy(): void;
}
export {};
