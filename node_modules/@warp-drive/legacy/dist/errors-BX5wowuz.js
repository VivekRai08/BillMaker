import { memoized, defineSignal, defineNonEnumerableSignal, isStableIdentifier, recordIdentifierFor, storeFor, peekCache, SOURCE, fastPush, RelatedCollection, notifyInternalSignal, ARRAY_SIGNAL } from '@warp-drive/core/store/-private';
import { getOrSetGlobal } from '@warp-drive/core/types/-private';
import { EnableHydration } from '@warp-drive/core/types/request';
import { u as upgradeStore } from "./-private-CKrP0ogQ.js";
import { computed, get } from '@ember/object';
import PromiseProxyMixin from '@ember/object/promise-proxy-mixin';
import ObjectProxy from '@ember/object/proxy';
import { macroCondition, getGlobalConfig } from '@embroider/macros';
import { d as decorateMethodV2, a as decorateFieldV2, i as initializeDeferredDecorator } from "./runtime-BPCpkOf1-BKOwiRJp.js";
import { A } from '@ember/array';
import ArrayProxy from '@ember/array/proxy';
import { mapBy, not } from '@ember/object/computed';
const PromiseObject = ObjectProxy.extend(PromiseProxyMixin);
const LegacyPromiseProxy = Symbol.for('LegacyPromiseProxy');

// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-extraneous-class

const Extended = PromiseObject;

// eslint-disable-next-line @typescript-eslint/no-unused-vars

/**
  A PromiseBelongsTo is a PromiseObject that also proxies certain method calls
  to the underlying belongsTo model.
  Right now we proxy:
    * `reload()`
  @class PromiseBelongsTo
  @private
*/
class PromiseBelongsTo extends Extended {
  get id() {
    const {
      key,
      legacySupport
    } = this._belongsToState;
    const ref = legacySupport.referenceFor('belongsTo', key);
    return ref.id();
  }

  // we don't proxy meta because we would need to proxy it to the relationship state container
  //  however, meta on relationships does not trigger change notifications.
  //  if you need relationship meta, you should do `record.belongsTo(relationshipName).meta()`
  static {
    decorateMethodV2(this.prototype, "id", [memoized]);
  }
  get meta() {
    // eslint-disable-next-line no-constant-condition
    {
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        {
          throw new Error('You attempted to access meta on the promise for the async belongsTo relationship ' + `${this._belongsToState.modelName}:${this._belongsToState.key}'.` + '\nUse `record.belongsTo(relationshipName).meta()` instead.');
        }
      })() : {};
    }
    return;
  }
  static {
    decorateMethodV2(this.prototype, "meta", [computed()]);
  }
  async reload(options) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error('You are trying to reload an async belongsTo before it has been created');
      }
    })(this.content !== undefined) : {};
    const {
      key,
      legacySupport
    } = this._belongsToState;
    await legacySupport.reloadBelongsTo(key, options);
    return this;
  }
}
PromiseBelongsTo.prototype[LegacyPromiseProxy] = true;

/**
  This class is returned as the result of accessing an async hasMany relationship
  on an instance of a Model extending from `@ember-data/model`.

  A PromiseManyArray is an iterable proxy that allows templates to consume related
  ManyArrays and update once their contents are no longer pending.

  In your JS code you should resolve the promise first.

  ```js
  const comments = await post.comments;
  ```

  @class PromiseManyArray
  @public
*/
class PromiseManyArray {
  constructor(promise, content) {
    this._update(promise, content);
    this.isDestroyed = false;
    this[LegacyPromiseProxy] = true;
  }

  /**
   * Retrieve the length of the content
   * @property length
   * @public
   */
  get length() {
    // shouldn't be needed, but ends up being needed
    // for computed chains even in 4.x
    if (macroCondition(getGlobalConfig().WarpDrive.deprecations.DEPRECATE_COMPUTED_CHAINS)) {
      // eslint-disable-next-line @typescript-eslint/no-unused-expressions
      this['[]'];
    }
    return this.content ? this.content.length : 0;
  }

  // this will error if someone tries to call
  // A(identifierArray) since it is not configurable
  // which is preferrable to the `meta` override we used
  // before which required importing all of Ember
  static {
    decorateMethodV2(this.prototype, "length", [memoized]);
  }
  get '[]'() {
    // ember-source < 3.23 (e.g. 3.20 lts)
    // requires that the tag `'[]'` be notified
    // on the ArrayProxy in order for `{{#each}}`
    // to recompute. We entangle content.
    return this.content?.length && this.content;
  }

  /**
   * Iterate the proxied content. Called by the glimmer iterator in #each
   * We do not guarantee that forEach will always be available. This
   * may eventually be made to use Symbol.Iterator once glimmer supports it.
   *
   * @param cb
   * @return
   * @private
   */
  static {
    decorateMethodV2(this.prototype, '[]', [memoized]);
  }
  forEach(cb) {
    if (this.content && this.length) {
      this.content.forEach(cb);
    }
  }

  /**
   * Reload the relationship
   * @public
   * @param options
   * @return
   */
  reload(options) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error('You are trying to reload an async manyArray before it has been created');
      }
    })(this.content) : {};
    void this.content.reload(options);
    return this;
  }

  //----  Properties/Methods from the PromiseProxyMixin that we will keep as our API

  /**
   * Whether the loading promise is still pending
   *
   * @property isPending
   * @type {Boolean}
   * @public
   */

  /**
   * Whether the loading promise rejected
   *
   * @property isRejected
   * @type {Boolean}
   * @public
   */

  /**
   * Whether the loading promise succeeded
   *
   * @property isFulfilled
   * @type {Boolean}
   * @public
   */

  /**
   * Whether the loading promise completed (resolved or rejected)
   *
   * @property isSettled
   * @type {Boolean}
   * @public
   */

  /**
   * chain this promise
   *
   * @public
   */
  then(success, rejected) {
    return this.promise.then(success, rejected);
  }

  /**
   * catch errors thrown by this promise
   * @public
   * @param callback
   * @return {Promise}
   */
  catch(cb) {
    return this.promise.catch(cb);
  }

  /**
   * run cleanup after this promise completes
   *
   * @public
   * @param callback
   * @return {Promise}
   */
  finally(cb) {
    return this.promise.finally(cb);
  }

  //---- Methods on EmberObject that we should keep

  destroy() {
    this.isDestroyed = true;
    this.content = null;
    this.promise = null;
  }

  //---- Methods/Properties on ManyArray that we own and proxy to

  /**
   * Retrieve the links for this relationship
   * @property links
   * @public
   */
  get links() {
    return this.content ? this.content.links : undefined;
  }

  /**
   * Retrieve the meta for this relationship
   * @property meta
   * @public
   */
  static {
    decorateMethodV2(this.prototype, "links", [memoized]);
  }
  get meta() {
    return this.content ? this.content.meta : undefined;
  }

  //---- Our own stuff

  /** @internal */
  static {
    decorateMethodV2(this.prototype, "meta", [memoized]);
  }
  _update(promise, content) {
    if (content !== undefined) {
      this.content = content;
    }
    this.promise = tapPromise(this, promise);
  }
  static create({
    promise,
    content
  }) {
    return new this(promise, content);
  }
}
defineSignal(PromiseManyArray.prototype, 'content', null);
defineSignal(PromiseManyArray.prototype, 'isPending', false);
defineSignal(PromiseManyArray.prototype, 'isRejected', false);
defineSignal(PromiseManyArray.prototype, 'isFulfilled', false);
defineSignal(PromiseManyArray.prototype, 'isSettled', false);
function tapPromise(proxy, promise) {
  proxy.isPending = true;
  proxy.isSettled = false;
  proxy.isFulfilled = false;
  proxy.isRejected = false;
  return Promise.resolve(promise).then(content => {
    proxy.isPending = false;
    proxy.isFulfilled = true;
    proxy.isSettled = true;
    proxy.content = content;
    return content;
  }, error => {
    proxy.isPending = false;
    proxy.isFulfilled = false;
    proxy.isRejected = true;
    proxy.isSettled = true;
    throw error;
  });
}

/*
  Assert that `addedRecord` has a valid type so it can be added to the
  relationship of the `record`.

  The assert basically checks if the `addedRecord` can be added to the
  relationship (specified via `relationshipMeta`) of the `record`.

  This utility should only be used internally, as both record parameters must
  be stable record identifiers and the `relationshipMeta` needs to be the meta
  information about the relationship, retrieved via
  `record.relationshipFor(key)`.
*/
let assertPolymorphicType;
if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
  // eslint-disable-next-line @typescript-eslint/no-shadow
  assertPolymorphicType = function assertPolymorphicType(parentIdentifier, parentDefinition, addedIdentifier, store) {
    if (parentDefinition.inverseIsImplicit) {
      return;
    }
    if (parentDefinition.isPolymorphic) {
      const meta = store.schema.fields(addedIdentifier)?.get(parentDefinition.inverseKey);
      if (meta) {
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`Expected the schema for the field ${parentDefinition.inverseKey} on ${addedIdentifier.type} to be for a legacy relationship`);
          }
        })(meta.kind === 'belongsTo' || meta.kind === 'hasMany') : {};
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`The schema for the relationship '${parentDefinition.inverseKey}' on '${addedIdentifier.type}' type does not implement '${parentDefinition.type}' and thus cannot be assigned to the '${parentDefinition.key}' relationship in '${parentIdentifier.type}'. The definition should specify 'as: "${parentDefinition.type}"' in options.`);
          }
        })(meta?.options?.as === parentDefinition.type) : {};
      }
    }
  };
}
function isResourceIdentiferWithRelatedLinks$1(value) {
  return Boolean(value && value.links && value.links.related);
}
/**
 A `HasManyReference` is a low-level API that allows access
 and manipulation of a hasMany relationship.

 It is especially useful when you're dealing with `async` relationships
 from `@ember-data/model` as it allows synchronous access to
 the relationship data if loaded, as well as APIs for loading, reloading
 the data or accessing available information without triggering a load.

 It may also be useful when using `sync` relationships with `@ember-data/model`
 that need to be loaded/reloaded with more precise timing than marking the
 relationship as `async` and relying on autofetch would have allowed.

 However,keep in mind that marking a relationship as `async: false` will introduce
 bugs into your application if the data is not always guaranteed to be available
 by the time the relationship is accessed. Ergo, it is recommended when using this
 approach to utilize `links` for unloaded relationship state instead of identifiers.

 Reference APIs are entangled with the relationship's underlying state,
 thus any getters or cached properties that utilize these will properly
 invalidate if the relationship state changes.

 References are "stable", meaning that multiple calls to retrieve the reference
  for a given relationship will always return the same HasManyReference.

 @class HasManyReference
 @public
 */
class HasManyReference {
  /**
   * The field name on the parent record for this has-many relationship.
   *
   * @property key
   * @type {String}
   * @public
   */

  /**
   * The type of resource this relationship will contain.
   *
   * @property type
   * @type {String}
   * @public
   */

  // unsubscribe tokens given to us by the notification manager
  ___token;
  ___identifier;
  ___relatedTokenMap;
  constructor(store, graph, parentIdentifier, hasManyRelationship, key) {
    this.graph = graph;
    this.key = key;
    this.hasManyRelationship = hasManyRelationship;
    this.type = hasManyRelationship.definition.type;
    this.store = store;
    this.___identifier = parentIdentifier;
    this.___token = store.notifications.subscribe(parentIdentifier, (_, bucket, notifiedKey) => {
      if (bucket === 'relationships' && notifiedKey === key) {
        this._ref++;
      }
    });
    this.___relatedTokenMap = new Map();
    // TODO inverse
  }

  /**
   * This method should never be called by user code.
   *
   * @internal
   */
  destroy() {
    this.store.notifications.unsubscribe(this.___token);
    this.___relatedTokenMap.forEach(token => {
      this.store.notifications.unsubscribe(token);
    });
    this.___relatedTokenMap.clear();
  }

  /**
   * An array of identifiers for the records that this reference refers to.
   *
   * @property identifiers
   * @type {StableRecordIdentifier[]}
   * @public
   */
  get identifiers() {
    ensureRefCanSubscribe(this);
    // eslint-disable-next-line @typescript-eslint/no-unused-expressions
    this._ref;
    const resource = this._resource();
    const map = this.___relatedTokenMap;
    this.___relatedTokenMap = new Map();
    if (resource && resource.data) {
      return resource.data.map(resourceIdentifier => {
        const identifier = this.store.identifierCache.getOrCreateRecordIdentifier(resourceIdentifier);
        let token = map.get(identifier);
        if (token) {
          map.delete(identifier);
        } else {
          token = this.store.notifications.subscribe(identifier, (_, bucket, notifiedKey) => {
            if (bucket === 'identity' || bucket === 'attributes' && notifiedKey === 'id') {
              this._ref++;
            }
          });
        }
        this.___relatedTokenMap.set(identifier, token);
        return identifier;
      });
    }
    map.forEach(token => {
      this.store.notifications.unsubscribe(token);
    });
    map.clear();
    return [];
  }
  static {
    decorateMethodV2(this.prototype, "identifiers", [memoized]);
  }
  _resource() {
    const cache = this.store.cache;
    return cache.getRelationship(this.___identifier, this.key);
  }

  /**
   This returns a string that represents how the reference will be
   looked up when it is loaded. If the relationship has a link it will
   use the "link" otherwise it defaults to "id".
    Example
    ```js [app/models/post.js]
   import { Model, hasMany } from '@warp-drive/legacy/model';
    export default class PostModel extends Model {
     @hasMany('comment', { async: true, inverse: null }) comments;
   }
   ```
    ```javascript
   let post = store.push({
     data: {
       type: 'post',
       id: 1,
       relationships: {
         comments: {
           data: [{ type: 'comment', id: 1 }]
         }
       }
     }
   });
    let commentsRef = post.hasMany('comments');
    // get the identifier of the reference
   if (commentsRef.remoteType() === "ids") {
     let ids = commentsRef.ids();
   } else if (commentsRef.remoteType() === "link") {
     let link = commentsRef.link();
   }
   ```
    @public
   @return {String} The name of the remote type. This should either be `link` or `ids`
   */
  remoteType() {
    const value = this._resource();
    if (value && value.links && value.links.related) {
      return 'link';
    }
    return 'ids';
  }

  /**
   `ids()` returns an array of the record IDs in this relationship.
    Example
    ```js [app/models/post.js]
   import { Model, hasMany } from '@warp-drive/legacy/model';
    export default class PostModel extends Model {
     @hasMany('comment', { async: true, inverse: null }) comments;
   }
   ```
    ```javascript
   let post = store.push({
     data: {
       type: 'post',
       id: 1,
       relationships: {
         comments: {
           data: [{ type: 'comment', id: 1 }]
         }
       }
     }
   });
    let commentsRef = post.hasMany('comments');
    commentsRef.ids(); // ['1']
   ```
     @public
   @return {Array} The ids in this has-many relationship
   */
  ids() {
    return this.identifiers.map(identifier => identifier.id);
  }

  /**
   The link Ember Data will use to fetch or reload this belongs-to
   relationship. By default it uses only the "related" resource linkage.
    Example
    ```javascript
   // models/blog.js
   import { Model, belongsTo } from '@warp-drive/legacy/model';
   export default Model.extend({
      user: belongsTo('user', { async: true, inverse: null })
    });
    let blog = store.push({
      data: {
        type: 'blog',
        id: 1,
        relationships: {
          user: {
            links: {
              related: '/articles/1/author'
            }
          }
        }
      }
    });
   let userRef = blog.belongsTo('user');
    // get the identifier of the reference
   if (userRef.remoteType() === "link") {
      let link = userRef.link();
    }
   ```
    @public
   @return {String} The link Ember Data will use to fetch or reload this belongs-to relationship.
   */
  link() {
    const resource = this._resource();
    if (isResourceIdentiferWithRelatedLinks$1(resource)) {
      if (resource.links) {
        const related = resource.links.related;
        return !related || typeof related === 'string' ? related : related.href;
      }
    }
    return null;
  }

  /**
   * any links that have been received for this relationship
   *
   * @public
   * @return
   */
  links() {
    const resource = this._resource();
    return resource && resource.links ? resource.links : null;
  }

  /**
   The meta data for the has-many relationship.
    Example
    ```javascript
   // models/blog.js
   import { Model, hasMany } from '@warp-drive/legacy/model';
   export default Model.extend({
      users: hasMany('user', { async: true, inverse: null })
    });
    let blog = store.push({
      data: {
        type: 'blog',
        id: 1,
        relationships: {
          users: {
            links: {
              related: {
                href: '/articles/1/authors'
              },
            },
            meta: {
              lastUpdated: 1458014400000
            }
          }
        }
      }
    });
    let usersRef = blog.hasMany('user');
    usersRef.meta() // { lastUpdated: 1458014400000 }
   ```
   @public
  @return {Object|null} The meta information for the belongs-to relationship.
  */
  meta() {
    let meta = null;
    const resource = this._resource();
    if (resource && resource.meta && typeof resource.meta === 'object') {
      meta = resource.meta;
    }
    return meta;
  }

  /**
   `push` can be used to update the data in the relationship and EmberData
   will treat the new data as the canonical value of this relationship on
   the backend. An empty array will signify the canonical value should be
   empty.
    Example model
    ```js [app/models/post.js]
   import { Model, hasMany } from '@warp-drive/legacy/model';
    export default class PostModel extends Model {
     @hasMany('comment', { async: true, inverse: null }) comments;
   }
   ```
    Setup some initial state, note we haven't loaded the comments yet:
    ```js
   const post = store.push({
     data: {
       type: 'post',
       id: '1',
       relationships: {
         comments: {
           data: [{ type: 'comment', id: '1' }]
         }
       }
     }
   });
    const commentsRef = post.hasMany('comments');
   commentsRef.ids(); // ['1']
   ```
    Update the state using `push`, note we can do this even without
   having loaded these comments yet by providing resource identifiers.
    Both full resources and resource identifiers are supported.
    ```js
   await commentsRef.push({
    data: [
     { type: 'comment', id: '2' },
     { type: 'comment', id: '3' },
    ]
   });
    commentsRef.ids(); // ['2', '3']
   ```
    For convenience, you can also pass in an array of resources or resource identifiers
   without wrapping them in the `data` property:
    ```js
   await commentsRef.push([
     { type: 'comment', id: '4' },
     { type: 'comment', id: '5' },
   ]);
    commentsRef.ids(); // ['4', '5']
   ```
    When using the `data` property, you may also include other resource data via included,
   as well as provide new links and meta to the relationship.
    ```js
   await commentsRef.push({
     links: {
       related: '/posts/1/comments'
     },
     meta: {
       total: 2
     },
     data: [
       { type: 'comment', id: '4' },
       { type: 'comment', id: '5' },
     ],
     included: [
       { type: 'other-thing', id: '1', attributes: { foo: 'bar' },
     ]
   });
   ```
    By default, the store will attempt to fetch any unloaded records before resolving
   the returned promise with the ManyArray.
    Alternatively, pass `true` as the second argument to avoid fetching unloaded records
   and instead the promise will resolve with void without attempting to fetch. This is
   particularly useful if you want to update the state of the relationship without
   forcing the load of all of the associated records.
    @public
   @param {Array|Object} doc a JSONAPI document object describing the new value of this relationship.
   @param {Boolean} [skipFetch] if `true`, do not attempt to fetch unloaded records
   @return {Promise<ManyArray | void>}
  */
  async push(doc, skipFetch) {
    const {
      store
    } = this;
    const dataDoc = Array.isArray(doc) ? {
      data: doc
    } : doc;
    const isResourceData = Array.isArray(dataDoc.data) && dataDoc.data.length > 0 && isMaybeResource(dataDoc.data[0]);

    // enforce that one of links, meta or data is present
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`You must provide at least one of 'links', 'meta' or 'data' when calling hasManyReference.push`);
      }
    })('links' in dataDoc || 'meta' in dataDoc || 'data' in dataDoc) : {};
    const identifiers = !Array.isArray(dataDoc.data) ? [] : isResourceData ? store._push(dataDoc, true) : dataDoc.data.map(i => store.identifierCache.getOrCreateRecordIdentifier(i));
    const {
      identifier
    } = this.hasManyRelationship;
    if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
      const relationshipMeta = this.hasManyRelationship.definition;
      identifiers.forEach(added => {
        assertPolymorphicType(identifier, relationshipMeta, added, store);
      });
    }
    const newData = {};
    // only set data if it was passed in
    if (Array.isArray(dataDoc.data)) {
      newData.data = identifiers;
    }
    if ('links' in dataDoc) {
      newData.links = dataDoc.links;
    }
    if ('meta' in dataDoc) {
      newData.meta = dataDoc.meta;
    }
    store._join(() => {
      this.graph.push({
        op: 'updateRelationship',
        record: identifier,
        field: this.key,
        value: newData
      });
    });
    if (!skipFetch) return this.load();
  }
  _isLoaded() {
    const hasRelationshipDataProperty = this.hasManyRelationship.state.hasReceivedData;
    if (!hasRelationshipDataProperty) {
      return false;
    }
    const relationship = this.graph.getData(this.hasManyRelationship.identifier, this.key);
    return relationship.data ? relationship.data.every(identifier => {
      return this.store._instanceCache.recordIsLoaded(identifier, true) === true;
    }) : false;
  }

  /**
   `value()` synchronously returns the current value of the has-many
   relationship. Unlike `record.relationshipName`, calling
   `value()` on a reference does not trigger a fetch if the async
   relationship is not yet loaded. If the relationship is not loaded
   it will always return `null`.
    Example
    ```js [app/models/post.js]
   import { Model, hasMany } from '@warp-drive/legacy/model';
    export default class PostModel extends Model {
     @hasMany('comment', { async: true, inverse: null }) comments;
   }
   ```
    ```javascript
   let post = store.push({
     data: {
       type: 'post',
       id: 1,
       relationships: {
         comments: {
           data: [{ type: 'comment', id: 1 }]
         }
       }
     }
   });
    let commentsRef = post.hasMany('comments');
    post.comments.then(function(comments) {
     commentsRef.value() === comments
   })
   ```
     @public
   @return {ManyArray}
   */
  value() {
    const support = LEGACY_SUPPORT.get(this.___identifier);
    if (!ensureRefCanSubscribe(this)) {
      // eslint-disable-next-line @typescript-eslint/no-unused-expressions
      this._ref;
      return null;
    }
    return support.getManyArray(this.key);
  }

  /**
   Loads the relationship if it is not already loaded.  If the
   relationship is already loaded this method does not trigger a new
   load. This causes a request to the specified
   relationship link or reloads all items currently in the relationship.
    Example
    ```js [app/models/post.js]
   import { Model, hasMany } from '@warp-drive/legacy/model';
    export default class PostModel extends Model {
     @hasMany('comment', { async: true, inverse: null }) comments;
   }
   ```
    ```javascript
   let post = store.push({
     data: {
       type: 'post',
       id: 1,
       relationships: {
         comments: {
           data: [{ type: 'comment', id: 1 }]
         }
       }
     }
   });
    let commentsRef = post.hasMany('comments');
    commentsRef.load().then(function(comments) {
     //...
   });
   ```
    You may also pass in an options object whose properties will be
   fed forward. This enables you to pass `adapterOptions` into the
   request given to the adapter via the reference.
    Example
    ```javascript
   commentsRef.load({ adapterOptions: { isPrivate: true } })
     .then(function(comments) {
       //...
     });
   ```
    ```js [app/adapters/comment.js]
   export default ApplicationAdapter.extend({
     findMany(store, type, id, snapshots) {
       // In the adapter you will have access to adapterOptions.
       let adapterOptions = snapshots[0].adapterOptions;
     }
   });
   ```
    @public
   @param {Object} options the options to pass in.
   @return {Promise} a promise that resolves with the ManyArray in
   this has-many relationship.
   */
  async load(options) {
    const support = LEGACY_SUPPORT.get(this.___identifier);
    const fetchSyncRel = !this.hasManyRelationship.definition.isAsync && !areAllInverseRecordsLoaded(this.store, this._resource());
    return fetchSyncRel ? support.reloadHasMany(this.key, options) :
    // we cast to fix the return type since typescript and eslint don't understand async functions
    // properly
    support.getHasMany(this.key, options);
  }

  /**
   Reloads this has-many relationship. This causes a request to the specified
   relationship link or reloads all items currently in the relationship.
    Example
    ```js [app/models/post.js]
   import { Model, hasMany } from '@warp-drive/legacy/model';
    export default class PostModel extends Model {
     @hasMany('comment', { async: true, inverse: null }) comments;
   }
   ```
    ```javascript
   let post = store.push({
     data: {
       type: 'post',
       id: 1,
       relationships: {
         comments: {
           data: [{ type: 'comment', id: 1 }]
         }
       }
     }
   });
    let commentsRef = post.hasMany('comments');
    commentsRef.reload().then(function(comments) {
     //...
   });
   ```
    You may also pass in an options object whose properties will be
   fed forward. This enables you to pass `adapterOptions` into the
   request given to the adapter via the reference. A full example
   can be found in the `load` method.
    Example
    ```javascript
   commentsRef.reload({ adapterOptions: { isPrivate: true } })
   ```
     @public
   @param {Object} options the options to pass in.
   @return {Promise} a promise that resolves with the ManyArray in this has-many relationship.
   */
  reload(options) {
    const support = LEGACY_SUPPORT.get(this.___identifier);
    return support.reloadHasMany(this.key, options);
  }
}
defineNonEnumerableSignal(HasManyReference.prototype, '_ref', 0);
function isMaybeResource(object) {
  const keys = Object.keys(object).filter(k => k !== 'id' && k !== 'type' && k !== 'lid');
  return keys.length > 0;
}
function ensureRefCanSubscribe(rel) {
  const loaded = rel._isLoaded();
  if (!loaded) {
    // subscribe to changes
    // for when we are not loaded yet
    //
    // because the graph optimizes the case where a relationship has never been subscribed,
    // we force accessed to be true here. When we make the graph public we should create a
    // subscribe/unsubscribe API
    const edge = rel.graph.get(rel.___identifier, rel.key);
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected a hasMany relationship for ${rel.___identifier.type}:${rel.key}`);
      }
    })('accessed' in edge) : {};
    edge.accessed = true;
    return false;
  }
  return true;
}
function isResourceIdentiferWithRelatedLinks(value) {
  return Boolean(value && value.links && value.links.related);
}

/**
 A `BelongsToReference` is a low-level API that allows access
 and manipulation of a belongsTo relationship.

 It is especially useful when you're dealing with `async` relationships
 from `@ember-data/model` as it allows synchronous access to
 the relationship data if loaded, as well as APIs for loading, reloading
 the data or accessing available information without triggering a load.

 It may also be useful when using `sync` relationships with `@ember-data/model`
 that need to be loaded/reloaded with more precise timing than marking the
 relationship as `async` and relying on autofetch would have allowed.

 However,keep in mind that marking a relationship as `async: false` will introduce
 bugs into your application if the data is not always guaranteed to be available
 by the time the relationship is accessed. Ergo, it is recommended when using this
 approach to utilize `links` for unloaded relationship state instead of identifiers.

 Reference APIs are entangled with the relationship's underlying state,
 thus any getters or cached properties that utilize these will properly
 invalidate if the relationship state changes.

 References are "stable", meaning that multiple calls to retrieve the reference
  for a given relationship will always return the same HasManyReference.

 @class BelongsToReference
 @public
 */
class BelongsToReference {
  /**
   * The field name on the parent record for this has-many relationship.
   *
   * @property key
   * @type {String}
   * @public
   */

  /**
   * The type of resource this relationship will contain.
   *
   * @property type
   * @type {String}
   * @public
   */

  // unsubscribe tokens given to us by the notification manager

  constructor(store, graph, parentIdentifier, belongsToRelationship, key) {
    this.graph = graph;
    this.key = key;
    this.belongsToRelationship = belongsToRelationship;
    this.type = belongsToRelationship.definition.type;
    this.store = store;
    this.___identifier = parentIdentifier;
    this.___relatedToken = null;
    this.___token = store.notifications.subscribe(parentIdentifier, (_, bucket, notifiedKey) => {
      if (bucket === 'relationships' && notifiedKey === key) {
        this._ref++;
      }
    });

    // TODO inverse
  }
  destroy() {
    // TODO @feature we need the notification manager often enough
    // we should potentially just expose it fully public
    this.store.notifications.unsubscribe(this.___token);
    this.___token = null;
    if (this.___relatedToken) {
      this.store.notifications.unsubscribe(this.___relatedToken);
      this.___relatedToken = null;
    }
  }

  /**
   * The identifier of the record that this reference refers to.
   * `null` if no related record is known.
   *
   * @property identifier
   * @type {StableRecordIdentifier | null}
   * @public
   */
  get identifier() {
    if (this.___relatedToken) {
      this.store.notifications.unsubscribe(this.___relatedToken);
      this.___relatedToken = null;
    }
    const resource = this._resource();
    if (resource && resource.data) {
      const identifier = this.store.identifierCache.getOrCreateRecordIdentifier(resource.data);
      this.___relatedToken = this.store.notifications.subscribe(identifier, (_, bucket, notifiedKey) => {
        if (bucket === 'identity' || bucket === 'attributes' && notifiedKey === 'id') {
          this._ref++;
        }
      });
      return identifier;
    }
    return null;
  }

  /**
   The `id` of the record that this reference refers to. Together, the
   `type()` and `id()` methods form a composite key for the identity
   map. This can be used to access the id of an async relationship
   without triggering a fetch that would normally happen if you
   attempted to use `record.relationship.id`.
    Example
    ```javascript
   // models/blog.js
   import { Model, belongsTo } from '@warp-drive/legacy/model';
    export default class BlogModel extends Model {
    @belongsTo('user', { async: true, inverse: null }) user;
   }
    let blog = store.push({
      data: {
        type: 'blog',
        id: 1,
        relationships: {
          user: {
            data: { type: 'user', id: 1 }
          }
        }
      }
    });
   let userRef = blog.belongsTo('user');
    // get the identifier of the reference
   if (userRef.remoteType() === "id") {
      let id = userRef.id();
    }
   ```
    @public
   @return {String} The id of the record in this belongsTo relationship.
   */
  static {
    decorateMethodV2(this.prototype, "identifier", [memoized]);
  }
  id() {
    return this.identifier?.id || null;
  }

  /**
   The link Ember Data will use to fetch or reload this belongs-to
   relationship. By default it uses only the "related" resource linkage.
    Example
    ```javascript
   // models/blog.js
   import { Model, belongsTo } from '@warp-drive/legacy/model';
   export default Model.extend({
      user: belongsTo('user', { async: true, inverse: null })
    });
    let blog = store.push({
      data: {
        type: 'blog',
        id: 1,
        relationships: {
          user: {
            links: {
              related: '/articles/1/author'
            }
          }
        }
      }
    });
   let userRef = blog.belongsTo('user');
    // get the identifier of the reference
   if (userRef.remoteType() === "link") {
      let link = userRef.link();
    }
   ```
    @public
   @return {String} The link Ember Data will use to fetch or reload this belongs-to relationship.
   */
  link() {
    const resource = this._resource();
    if (isResourceIdentiferWithRelatedLinks(resource)) {
      if (resource.links) {
        const related = resource.links.related;
        return !related || typeof related === 'string' ? related : related.href;
      }
    }
    return null;
  }

  /**
   * any links that have been received for this relationship
   *
   * @public
   * @return
   */
  links() {
    const resource = this._resource();
    return resource && resource.links ? resource.links : null;
  }

  /**
   The meta data for the belongs-to relationship.
    Example
    ```javascript
   // models/blog.js
   import { Model, belongsTo } from '@warp-drive/legacy/model';
   export default Model.extend({
      user: belongsTo('user', { async: true, inverse: null })
    });
    let blog = store.push({
      data: {
        type: 'blog',
        id: 1,
        relationships: {
          user: {
            links: {
              related: {
                href: '/articles/1/author'
              },
            },
            meta: {
              lastUpdated: 1458014400000
            }
          }
        }
      }
    });
    let userRef = blog.belongsTo('user');
    userRef.meta() // { lastUpdated: 1458014400000 }
   ```
     @public
   @return {Object} The meta information for the belongs-to relationship.
   */
  meta() {
    let meta = null;
    const resource = this._resource();
    if (resource && resource.meta && typeof resource.meta === 'object') {
      meta = resource.meta;
    }
    return meta;
  }
  _resource() {
    // eslint-disable-next-line @typescript-eslint/no-unused-expressions
    this._ref; // subscribe
    const cache = this.store.cache;
    return cache.getRelationship(this.___identifier, this.key);
  }

  /**
   This returns a string that represents how the reference will be
   looked up when it is loaded. If the relationship has a link it will
   use the "link" otherwise it defaults to "id".
    Example
    ```js [app/models/post.js]
   import Model, { hasMany } from '@ember-data/model';
    export default class PostModel extends Model {
     @hasMany('comment', { async: true, inverse: null }) comments;
   }
   ```
    ```javascript
   let post = store.push({
     data: {
       type: 'post',
       id: 1,
       relationships: {
         comments: {
           data: [{ type: 'comment', id: 1 }]
         }
       }
     }
   });
    let commentsRef = post.hasMany('comments');
    // get the identifier of the reference
   if (commentsRef.remoteType() === "ids") {
     let ids = commentsRef.ids();
   } else if (commentsRef.remoteType() === "link") {
     let link = commentsRef.link();
   }
   ```
    @public
   @return {String} The name of the remote type. This should either be `link` or `id`
   */
  remoteType() {
    const value = this._resource();
    if (isResourceIdentiferWithRelatedLinks(value)) {
      return 'link';
    }
    return 'id';
  }

  /**
   `push` can be used to update the data in the relationship and EmberData
   will treat the new data as the canonical value of this relationship on
   the backend. A value of `null` (e.g. `{ data: null }`) can be passed to
   clear the relationship.
    Example model
    ```js [app/models/blog.js]
   import { Model, belongsTo } from '@warp-drive/legacy/model';
    export default class BlogModel extends Model {
      @belongsTo('user', { async: true, inverse: null }) user;
    }
   ```
    Setup some initial state, note we haven't loaded the user yet:
    ```js
   const blog = store.push({
      data: {
        type: 'blog',
        id: '1',
        relationships: {
          user: {
            data: { type: 'user', id: '1' }
          }
        }
      }
   });
    const userRef = blog.belongsTo('user');
   userRef.id(); // '1'
   ```
    Update the state using `push`, note we can do this even without
   having loaded the user yet by providing a resource-identifier.
    Both full a resource and a resource-identifier are supported.
    ```js
   await userRef.push({
      data: {
        type: 'user',
        id: '2',
      }
    });
     userRef.id(); // '2'
   ```
    You may also pass in links and meta fore the relationship, and sideload
   additional resources that might be required.
    ```js
    await userRef.push({
        data: {
          type: 'user',
          id: '2',
        },
        links: {
          related: '/articles/1/author'
        },
        meta: {
          lastUpdated: Date.now()
        },
        included: [
          {
            type: 'user-preview',
            id: '2',
            attributes: {
              username: '@runspired'
            }
          }
        ]
      });
    ```
    By default, the store will attempt to fetch the record if it is not loaded or its
   resource data is not included in the call to `push` before resolving the returned
   promise with the new state..
    Alternatively, pass `true` as the second argument to avoid fetching unloaded records
   and instead the promise will resolve with void without attempting to fetch. This is
   particularly useful if you want to update the state of the relationship without
   forcing the load of all of the associated record.
    @public
   @param {Object} doc a JSONAPI document object describing the new value of this relationship.
   @param {Boolean} [skipFetch] if `true`, do not attempt to fetch unloaded records
   @return {Promise<OpaqueRecordInstance | null | void>}
  */
  async push(doc, skipFetch) {
    const {
      store
    } = this;
    const isResourceData = doc.data && isMaybeResource(doc.data);
    const added = isResourceData ? store._push(doc, true) : doc.data ? store.identifierCache.getOrCreateRecordIdentifier(doc.data) : null;
    const {
      identifier
    } = this.belongsToRelationship;
    if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
      if (added) {
        assertPolymorphicType(identifier, this.belongsToRelationship.definition, added, store);
      }
    }
    const newData = {};

    // only set data if it was passed in
    if (doc.data || doc.data === null) {
      newData.data = added;
    }
    if ('links' in doc) {
      newData.links = doc.links;
    }
    if ('meta' in doc) {
      newData.meta = doc.meta;
    }
    store._join(() => {
      this.graph.push({
        op: 'updateRelationship',
        record: identifier,
        field: this.key,
        value: newData
      });
    });
    if (!skipFetch) return this.load();
  }

  /**
   `value()` synchronously returns the current value of the belongs-to
   relationship. Unlike `record.relationshipName`, calling
   `value()` on a reference does not trigger a fetch if the async
   relationship is not yet loaded. If the relationship is not loaded
   it will always return `null`.
    Example
    ```javascript
   // models/blog.js
   import { Model, belongsTo } from '@warp-drive/legacy/model';
    export default class BlogModel extends Model {
     @belongsTo('user', { async: true, inverse: null }) user;
   }
    let blog = store.push({
      data: {
        type: 'blog',
        id: 1,
        relationships: {
          user: {
            data: { type: 'user', id: 1 }
          }
        }
      }
    });
   let userRef = blog.belongsTo('user');
    userRef.value(); // null
    // provide data for reference
   userRef.push({
      data: {
        type: 'user',
        id: 1,
        attributes: {
          username: "@user"
        }
      }
    }).then(function(user) {
      userRef.value(); // user
    });
   ```
     @public
   @return {Model} the record in this relationship
   */
  value() {
    const resource = this._resource();
    return resource && resource.data ? this.store.peekRecord(resource.data) : null;
  }

  /**
   Loads a record in a belongs-to relationship if it is not already
   loaded. If the relationship is already loaded this method does not
   trigger a new load.
    Example
    ```javascript
   // models/blog.js
   import { Model, belongsTo } from '@warp-drive/legacy/model';
    export default class BlogModel extends Model {
     @belongsTo('user', { async: true, inverse: null }) user;
   }
    let blog = store.push({
      data: {
        type: 'blog',
        id: 1,
        relationships: {
          user: {
            data: { type: 'user', id: 1 }
          }
        }
      }
    });
   let userRef = blog.belongsTo('user');
    userRef.value(); // null
    userRef.load().then(function(user) {
      userRef.value() === user
    });
   ```
    You may also pass in an options object whose properties will be
   fed forward. This enables you to pass `adapterOptions` into the
   request given to the adapter via the reference.
    Example
    ```javascript
   userRef.load({ adapterOptions: { isPrivate: true } }).then(function(user) {
     userRef.value() === user;
   });
   ```
   ```js [app/adapters/user.js]
   import Adapter from '@ember-data/adapter';
    export default class UserAdapter extends Adapter {
     findRecord(store, type, id, snapshot) {
       // In the adapter you will have access to adapterOptions.
       let adapterOptions = snapshot.adapterOptions;
     }
   });
   ```
     @public
   @param {Object} options the options to pass in.
   @return {Promise} a promise that resolves with the record in this belongs-to relationship.
   */
  async load(options) {
    const support = LEGACY_SUPPORT.get(this.___identifier);
    const fetchSyncRel = !this.belongsToRelationship.definition.isAsync && !areAllInverseRecordsLoaded(this.store, this._resource());
    return fetchSyncRel ? support.reloadBelongsTo(this.key, options).then(() => this.value()) :
    // we cast to fix the return type since typescript and eslint don't understand async functions
    // properly
    support.getBelongsTo(this.key, options);
  }

  /**
   Triggers a reload of the value in this relationship. If the
   remoteType is `"link"` Ember Data will use the relationship link to
   reload the relationship. Otherwise it will reload the record by its
   id.
    Example
    ```javascript
   // models/blog.js
   import { Model, belongsTo } from '@warp-drive/legacy/model';
    export default class BlogModel extends Model {
     @belongsTo('user', { async: true, inverse: null }) user;
   }
    let blog = store.push({
      data: {
        type: 'blog',
        id: 1,
        relationships: {
          user: {
            data: { type: 'user', id: 1 }
          }
        }
      }
    });
   let userRef = blog.belongsTo('user');
    userRef.reload().then(function(user) {
      userRef.value() === user
    });
   ```
    You may also pass in an options object whose properties will be
   fed forward. This enables you to pass `adapterOptions` into the
   request given to the adapter via the reference. A full example
   can be found in the `load` method.
    Example
    ```javascript
   userRef.reload({ adapterOptions: { isPrivate: true } })
   ```
     @public
   @param {Object} options the options to pass in.
   @return {Promise} a promise that resolves with the record in this belongs-to relationship after the reload has completed.
   */
  reload(options) {
    const support = LEGACY_SUPPORT.get(this.___identifier);
    return support.reloadBelongsTo(this.key, options).then(() => this.value());
  }
}
defineNonEnumerableSignal(BelongsToReference.prototype, '_ref', 0);
const LEGACY_SUPPORT = getOrSetGlobal('LEGACY_SUPPORT', new Map());
function lookupLegacySupport(record) {
  const identifier = recordIdentifierFor(record);
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`Expected a record`);
    }
  })(identifier) : {};
  let support = LEGACY_SUPPORT.get(identifier);
  if (!support) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Memory Leak Detected`);
      }
    })(!record.isDestroyed && !record.isDestroying) : {};
    support = new LegacySupport(record);
    LEGACY_SUPPORT.set(identifier, support);
    LEGACY_SUPPORT.set(record, support);
  }
  return support;
}
class LegacySupport {
  constructor(record) {
    this.record = record;
    this.store = storeFor(record);
    this.identifier = recordIdentifierFor(record);
    this.cache = peekCache(record);
    if (this.store._graph) {
      this.graph = this.store._graph;
    }
    this._manyArrayCache = Object.create(null);
    this._relationshipPromisesCache = Object.create(null);
    this._relationshipProxyCache = Object.create(null);
    this._pending = Object.create(null);
    this.references = Object.create(null);
  }
  _syncArray(array) {
    // It’s possible the parent side of the relationship may have been destroyed by this point
    if (this.isDestroyed || this.isDestroying) {
      return;
    }
    const currentState = array[SOURCE];
    const identifier = this.identifier;
    const [identifiers, jsonApi] = this._getCurrentState(identifier, array.key);
    if (jsonApi.meta) {
      array.meta = jsonApi.meta;
    }
    if (jsonApi.links) {
      array.links = jsonApi.links;
    }
    currentState.length = 0;
    fastPush(currentState, identifiers);
  }
  mutate(mutation) {
    this.cache.mutate(mutation);
  }
  _findBelongsTo(key, resource, relationship, options) {
    // TODO @runspired follow up if parent isNew then we should not be attempting load here
    // TODO @runspired follow up on whether this should be in the relationship requests cache
    return this._findBelongsToByJsonApiResource(resource, this.identifier, relationship, options).then(identifier => handleCompletedRelationshipRequest(this, key, relationship, identifier), e => handleCompletedRelationshipRequest(this, key, relationship, null, e));
  }
  reloadBelongsTo(key, options) {
    const loadingPromise = this._relationshipPromisesCache[key];
    if (loadingPromise) {
      return loadingPromise;
    }
    const relationship = this.graph.get(this.identifier, key);
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected ${key} to be a belongs-to relationship`);
      }
    })(isBelongsTo(relationship)) : {};
    const resource = this.cache.getRelationship(this.identifier, key);
    relationship.state.hasFailedLoadAttempt = false;
    relationship.state.shouldForceReload = true;
    const promise = this._findBelongsTo(key, resource, relationship, options);
    if (this._relationshipProxyCache[key]) {
      // @ts-expect-error
      return this._updatePromiseProxyFor('belongsTo', key, {
        promise
      });
    }
    return promise;
  }
  getBelongsTo(key, options) {
    const {
      identifier,
      cache
    } = this;
    const resource = cache.getRelationship(this.identifier, key);
    const relatedIdentifier = resource && resource.data ? resource.data : null;
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected a stable identifier`);
      }
    })(!relatedIdentifier || isStableIdentifier(relatedIdentifier)) : {};
    const store = this.store;
    const relationship = this.graph.get(this.identifier, key);
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected ${key} to be a belongs-to relationship`);
      }
    })(isBelongsTo(relationship)) : {};
    const isAsync = relationship.definition.isAsync;
    const _belongsToState = {
      key,
      store,
      legacySupport: this,
      modelName: relationship.definition.type
    };
    if (isAsync) {
      if (relationship.state.hasFailedLoadAttempt) {
        return this._relationshipProxyCache[key];
      }
      const promise = this._findBelongsTo(key, resource, relationship, options);
      const isLoaded = relatedIdentifier && store._instanceCache.recordIsLoaded(relatedIdentifier);
      return this._updatePromiseProxyFor('belongsTo', key, {
        promise,
        content: isLoaded ? store._instanceCache.getRecord(relatedIdentifier) : null,
        _belongsToState
      });
    } else {
      if (relatedIdentifier === null) {
        return null;
      } else {
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`You looked up the '${key}' relationship on a '${identifier.type}' with id ${identifier.id || 'null'} but some of the associated records were not loaded. Either make sure they are all loaded together with the parent record, or specify that the relationship is async (\`belongsTo(<type>, { async: true, inverse: <inverse> })\`)`);
          }
        })(store._instanceCache.recordIsLoaded(relatedIdentifier, true)) : {};
        return store._instanceCache.getRecord(relatedIdentifier);
      }
    }
  }
  setDirtyBelongsTo(key, value) {
    return this.cache.mutate({
      op: 'replaceRelatedRecord',
      record: this.identifier,
      field: key,
      value: extractIdentifierFromRecord(value)
    },
    // @ts-expect-error
    true);
  }
  _getCurrentState(identifier, field) {
    const jsonApi = this.cache.getRelationship(identifier, field);
    const cache = this.store._instanceCache;
    const identifiers = [];
    if (jsonApi.data) {
      for (let i = 0; i < jsonApi.data.length; i++) {
        const relatedIdentifier = jsonApi.data[i];
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`Expected a stable identifier`);
          }
        })(isStableIdentifier(relatedIdentifier)) : {};
        if (cache.recordIsLoaded(relatedIdentifier, true)) {
          identifiers.push(relatedIdentifier);
        }
      }
    }
    return [identifiers, jsonApi];
  }
  getManyArray(key, definition) {
    if (this.graph) {
      let manyArray = this._manyArrayCache[key];
      if (!definition) {
        definition = this.graph.get(this.identifier, key).definition;
      }
      if (!manyArray) {
        const [identifiers, doc] = this._getCurrentState(this.identifier, key);
        manyArray = new RelatedCollection({
          store: this.store,
          type: definition.type,
          identifier: this.identifier,
          cache: this.cache,
          field: this.store.schema.fields(this.identifier).get(key),
          identifiers,
          key,
          meta: doc.meta || null,
          links: doc.links || null,
          isPolymorphic: definition.isPolymorphic,
          isAsync: definition.isAsync,
          _inverseIsAsync: definition.inverseIsAsync,
          // @ts-expect-error Typescript doesn't have a way for us to thread the generic backwards so it infers unknown instead of T
          manager: this,
          isLoaded: !definition.isAsync,
          allowMutation: true
        });
        this._manyArrayCache[key] = manyArray;
      }
      return manyArray;
    }
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error('hasMany only works with the @ember-data/json-api package');
      }
    })() : {};
  }
  fetchAsyncHasMany(key, relationship, manyArray, options) {
    if (this.graph) {
      let loadingPromise = this._relationshipPromisesCache[key];
      if (loadingPromise) {
        return loadingPromise;
      }
      const jsonApi = this.cache.getRelationship(this.identifier, key);
      const promise = this._findHasManyByJsonApiResource(jsonApi, this.identifier, relationship, options);
      if (!promise) {
        manyArray.isLoaded = true;
        return Promise.resolve(manyArray);
      }
      loadingPromise = promise.then(() => handleCompletedRelationshipRequest(this, key, relationship, manyArray), e => handleCompletedRelationshipRequest(this, key, relationship, manyArray, e));
      this._relationshipPromisesCache[key] = loadingPromise;
      return loadingPromise;
    }
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error('hasMany only works with the @ember-data/json-api package');
      }
    })() : {};
  }
  reloadHasMany(key, options) {
    if (this.graph) {
      const loadingPromise = this._relationshipPromisesCache[key];
      if (loadingPromise) {
        return loadingPromise;
      }
      const relationship = this.graph.get(this.identifier, key);
      const {
        definition,
        state
      } = relationship;
      state.hasFailedLoadAttempt = false;
      state.shouldForceReload = true;
      const manyArray = this.getManyArray(key, definition);
      const promise = this.fetchAsyncHasMany(key, relationship, manyArray, options);
      if (this._relationshipProxyCache[key]) {
        return this._updatePromiseProxyFor('hasMany', key, {
          promise
        });
      }
      return promise;
    }
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`hasMany only works with the @ember-data/json-api package`);
      }
    })() : {};
  }
  getHasMany(key, options) {
    if (this.graph) {
      const relationship = this.graph.get(this.identifier, key);
      const {
        definition,
        state
      } = relationship;
      const manyArray = this.getManyArray(key, definition);
      if (definition.isAsync) {
        if (state.hasFailedLoadAttempt) {
          return this._relationshipProxyCache[key];
        }
        const promise = this.fetchAsyncHasMany(key, relationship, manyArray, options);
        return this._updatePromiseProxyFor('hasMany', key, {
          promise,
          content: manyArray
        });
      } else {
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`You looked up the '${key}' relationship on a '${this.identifier.type}' with id ${this.identifier.id || 'null'} but some of the associated records were not loaded. Either make sure they are all loaded together with the parent record, or specify that the relationship is async ('hasMany(<type>, { async: true, inverse: <inverse> })')`);
          }
        })(!anyUnloaded(this.store, relationship)) : {};
        return manyArray;
      }
    }
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`hasMany only works with the @ember-data/json-api package`);
      }
    })() : {};
  }
  _updatePromiseProxyFor(kind, key, args) {
    let promiseProxy = this._relationshipProxyCache[key];
    if (kind === 'hasMany') {
      const {
        promise,
        content
      } = args;
      if (promiseProxy) {
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`Expected a PromiseManyArray`);
          }
        })('_update' in promiseProxy) : {};
        promiseProxy._update(promise, content);
      } else {
        promiseProxy = this._relationshipProxyCache[key] = new PromiseManyArray(promise, content);
      }
      return promiseProxy;
    }
    if (promiseProxy) {
      const {
        promise,
        content
      } = args;
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        if (!test) {
          throw new Error(`Expected a PromiseBelongsTo`);
        }
      })('_belongsToState' in promiseProxy) : {};
      if (content !== undefined) {
        promiseProxy.set('content', content);
      }
      void promiseProxy.set('promise', promise);
    } else {
      promiseProxy = PromiseBelongsTo.create(args);
      this._relationshipProxyCache[key] = promiseProxy;
    }
    return promiseProxy;
  }
  referenceFor(kind, name) {
    let reference = this.references[name];
    if (!reference) {
      if (!this.graph) {
        // TODO @runspired while this feels odd, it is not a regression in capability because we do
        // not today support references pulling from RecordDatas other than our own
        // because of the intimate API access involved. This is something we will need to redesign.
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          {
            throw new Error(`snapshot.belongsTo only supported for @ember-data/json-api`);
          }
        })() : {};
      }
      const {
        graph,
        identifier
      } = this;
      const relationship = graph.get(identifier, name);
      if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
        if (kind) {
          const modelName = identifier.type;
          const actualRelationshipKind = relationship.definition.kind;
          macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
            if (!test) {
              throw new Error(`You tried to get the '${name}' relationship on a '${modelName}' via record.${kind}('${name}'), but the relationship is of kind '${actualRelationshipKind}'. Use record.${actualRelationshipKind}('${name}') instead.`);
            }
          })(actualRelationshipKind === kind) : {};
        }
      }
      const relationshipKind = relationship.definition.kind;
      if (relationshipKind === 'belongsTo') {
        reference = new BelongsToReference(this.store, graph, identifier, relationship, name);
      } else if (relationshipKind === 'hasMany') {
        reference = new HasManyReference(this.store, graph, identifier, relationship, name);
      }
      this.references[name] = reference;
    }
    return reference;
  }
  _findHasManyByJsonApiResource(resource, parentIdentifier, relationship, options = {}) {
    if (this.graph) {
      if (!resource) {
        return;
      }
      const {
        definition,
        state
      } = relationship;
      upgradeStore(this.store);
      const adapter = this.store.adapterFor?.(definition.type);
      const {
        isStale,
        hasDematerializedInverse,
        hasReceivedData,
        isEmpty,
        shouldForceReload
      } = state;
      const allInverseRecordsAreLoaded = areAllInverseRecordsLoaded(this.store, resource);
      const identifiers = resource.data;
      const shouldFindViaLink = resource.links && resource.links.related && (typeof adapter?.findHasMany === 'function' || typeof identifiers === 'undefined') && (shouldForceReload || hasDematerializedInverse || isStale || !allInverseRecordsAreLoaded && !isEmpty);
      const field = this.store.schema.fields({
        type: definition.inverseType
      }).get(definition.key);
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        if (!test) {
          throw new Error(`Expected a hasMany field definition for ${definition.inverseType}.${definition.key}`);
        }
      })(field && field.kind === 'hasMany') : {};
      const request = {
        useLink: shouldFindViaLink,
        field,
        links: resource.links,
        meta: resource.meta,
        options,
        record: parentIdentifier
      };

      // fetch via link
      if (shouldFindViaLink) {
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`Expected collection to be an array`);
          }
        })(!identifiers || Array.isArray(identifiers)) : {};
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`Expected stable identifiers`);
          }
        })(!identifiers || identifiers.every(isStableIdentifier)) : {};
        const req = field.options.linksMode ? {
          url: getRelatedLink(resource),
          op: 'findHasMany',
          method: 'GET',
          records: identifiers || [],
          data: request,
          [EnableHydration]: false
        } : {
          op: 'findHasMany',
          records: identifiers || [],
          data: request,
          cacheOptions: {
            [Symbol.for('wd:skip-cache')]: true
          }
        };
        return this.store.request(req);
      }
      const preferLocalCache = hasReceivedData && !isEmpty;
      const hasLocalPartialData = hasDematerializedInverse || isEmpty && Array.isArray(identifiers) && identifiers.length > 0;
      const attemptLocalCache = !shouldForceReload && !isStale && (preferLocalCache || hasLocalPartialData);
      if (attemptLocalCache && allInverseRecordsAreLoaded) {
        return;
      }
      const hasData = hasReceivedData && !isEmpty;
      if (attemptLocalCache || hasData || hasLocalPartialData) {
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`Expected collection to be an array`);
          }
        })(Array.isArray(identifiers)) : {};
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`Expected stable identifiers`);
          }
        })(identifiers.every(isStableIdentifier)) : {};
        options.reload = options.reload || !attemptLocalCache || undefined;
        return this.store.request({
          op: 'findHasMany',
          records: identifiers,
          data: request,
          cacheOptions: {
            [Symbol.for('wd:skip-cache')]: true
          }
        });
      }

      // we were explicitly told we have no data and no links.
      //   TODO if the relationshipIsStale, should we hit the adapter anyway?
      return;
    }
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`hasMany only works with the @ember-data/json-api package`);
      }
    })() : {};
  }
  _findBelongsToByJsonApiResource(resource, parentIdentifier, relationship, options = {}) {
    if (!resource) {
      return Promise.resolve(null);
    }
    const key = relationship.definition.key;

    // interleaved promises mean that we MUST cache this here
    // in order to prevent infinite re-render if the request
    // fails.
    if (this._pending[key]) {
      return this._pending[key];
    }
    const identifier = resource.data ? resource.data : null;
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected a stable identifier`);
      }
    })(!identifier || isStableIdentifier(identifier)) : {};
    const {
      isStale,
      hasDematerializedInverse,
      hasReceivedData,
      isEmpty,
      shouldForceReload
    } = relationship.state;
    const allInverseRecordsAreLoaded = areAllInverseRecordsLoaded(this.store, resource);
    const shouldFindViaLink = resource.links?.related && (shouldForceReload || hasDematerializedInverse || isStale || !allInverseRecordsAreLoaded && !isEmpty);
    const field = this.store.schema.fields(this.identifier).get(relationship.definition.key);
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Attempted to access a belongsTo relationship but no definition exists for it`);
      }
    })(field && field.kind === 'belongsTo') : {};
    const request = {
      useLink: shouldFindViaLink,
      field,
      links: resource.links,
      meta: resource.meta,
      options,
      record: parentIdentifier
    };

    // fetch via link
    if (shouldFindViaLink) {
      const req = field.options.linksMode ? {
        url: getRelatedLink(resource),
        op: 'findBelongsTo',
        method: 'GET',
        records: identifier ? [identifier] : [],
        data: request,
        [EnableHydration]: false
      } : {
        op: 'findBelongsTo',
        records: identifier ? [identifier] : [],
        data: request,
        cacheOptions: {
          [Symbol.for('wd:skip-cache')]: true
        }
      };
      const future = this.store.request(req);
      this._pending[key] = future.then(doc => field.options.linksMode ? doc.content.data : doc.content).finally(() => {
        this._pending[key] = undefined;
      });
      return this._pending[key];
    }
    const preferLocalCache = hasReceivedData && allInverseRecordsAreLoaded && !isEmpty;
    const hasLocalPartialData = hasDematerializedInverse || isEmpty && resource.data;
    // null is explicit empty, undefined is "we don't know anything"
    const localDataIsEmpty = !identifier;
    const attemptLocalCache = !shouldForceReload && !isStale && (preferLocalCache || hasLocalPartialData);

    // we dont need to fetch and are empty
    if (attemptLocalCache && localDataIsEmpty) {
      return Promise.resolve(null);
    }

    // we dont need to fetch because we are local state
    const resourceIsLocal = identifier?.id === null;
    if (attemptLocalCache && allInverseRecordsAreLoaded || resourceIsLocal) {
      return Promise.resolve(identifier);
    }

    // we may need to fetch
    if (identifier) {
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        if (!test) {
          throw new Error(`Cannot fetch belongs-to relationship with no information`);
        }
      })(identifier) : {};
      options.reload = options.reload || !attemptLocalCache || undefined;
      this._pending[key] = this.store.request({
        op: 'findBelongsTo',
        records: [identifier],
        data: request,
        cacheOptions: {
          [Symbol.for('wd:skip-cache')]: true
        }
      }).then(doc => doc.content).finally(() => {
        this._pending[key] = undefined;
      });
      return this._pending[key];
    }

    // we were explicitly told we have no data and no links.
    //   TODO if the relationshipIsStale, should we hit the adapter anyway?
    return Promise.resolve(null);
  }
  destroy() {
    this.isDestroying = true;
    let cache = this._manyArrayCache;
    this._manyArrayCache = Object.create(null);
    Object.keys(cache).forEach(key => {
      cache[key].destroy();
    });
    cache = this._relationshipProxyCache;
    this._relationshipProxyCache = Object.create(null);
    Object.keys(cache).forEach(key => {
      const proxy = cache[key];
      if (proxy.destroy) {
        proxy.destroy();
      }
    });
    cache = this.references;
    this.references = Object.create(null);
    Object.keys(cache).forEach(key => {
      cache[key].destroy();
    });
    this.isDestroyed = true;
  }
}
function getRelatedLink(resource) {
  const related = resource.links?.related;
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`Expected a related link`);
    }
  })(related) : {};
  return typeof related === 'object' ? related.href : related;
}
function handleCompletedRelationshipRequest(recordExt, key, relationship, value, error) {
  delete recordExt._relationshipPromisesCache[key];
  relationship.state.shouldForceReload = false;
  const isHasMany = relationship.definition.kind === 'hasMany';
  if (isHasMany) {
    // we don't notify the record property here to avoid refetch
    // only the many array
    notifyInternalSignal(value[ARRAY_SIGNAL]);
  }
  if (error) {
    relationship.state.hasFailedLoadAttempt = true;
    const proxy = recordExt._relationshipProxyCache[key];
    // belongsTo relationships are sometimes unloaded
    // when a load fails, in this case we need
    // to make sure that we aren't proxying
    // to destroyed content
    // for the sync belongsTo reload case there will be no proxy
    // for the async reload case there will be no proxy if the ui
    // has never been accessed
    if (proxy && !isHasMany) {
      // @ts-expect-error unsure why this is not resolving the boolean but async belongsTo is weird
      if (proxy.content && proxy.content.isDestroying) {
        proxy.set('content', null);
      }
      recordExt.store.notifications._flush();
    }
    throw error;
  }
  if (isHasMany) {
    value.isLoaded = true;
  } else {
    recordExt.store.notifications._flush();
  }
  relationship.state.hasFailedLoadAttempt = false;
  // only set to not stale if no error is thrown
  relationship.state.isStale = false;
  return isHasMany || !value ? value : recordExt.store.peekRecord(value);
}
function extractIdentifierFromRecord(record) {
  if (!record) {
    return null;
  }
  return recordIdentifierFor(record);
}
function anyUnloaded(store, relationship) {
  const graph = store._graph;
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`Expected a Graph instance to be available`);
    }
  })(graph) : {};
  const relationshipData = graph.getData(relationship.identifier, relationship.definition.key);
  const state = relationshipData.data;
  const cache = store._instanceCache;
  const unloaded = state?.find(s => {
    const isLoaded = cache.recordIsLoaded(s, true);
    return !isLoaded;
  });
  return unloaded || false;
}
function areAllInverseRecordsLoaded(store, resource) {
  const instanceCache = store._instanceCache;
  const identifiers = resource.data;
  if (Array.isArray(identifiers)) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected stable identifiers`);
      }
    })(identifiers.every(isStableIdentifier)) : {};
    // treat as collection
    // check for unloaded records
    return identifiers.every(identifier => instanceCache.recordIsLoaded(identifier));
  }

  // treat as single resource
  if (!identifiers) return true;
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`Expected stable identifiers`);
    }
  })(isStableIdentifier(identifiers)) : {};
  return instanceCache.recordIsLoaded(identifiers);
}
function isBelongsTo(relationship) {
  return relationship.definition.kind === 'belongsTo';
}

// we force the type here to our own construct because mixin and extend patterns
// lose generic signatures. We also do this because we need to Omit `clear` from
// the type of ArrayProxy as we override it's signature.
const ArrayProxyWithCustomOverrides = ArrayProxy;

/**
  Holds validation errors for a given record, organized by attribute names.

  This class is not directly instantiable.

  Every `Model` has an `errors` property that is an instance of
  `Errors`. This can be used to display validation error
  messages returned from the server when a `record.save()` rejects.

  For Example, if you had a `User` model that looked like this:

  ```js [app/models/user.js]
  import { Model, attr } from '@warp-drive/legacy/model';

  export default class UserModel extends Model {
    @attr('string') username;
    @attr('string') email;
  }
  ```
  And you attempted to save a record that did not validate on the backend:

  ```javascript
  let user = store.createRecord('user', {
    username: 'tomster',
    email: 'invalidEmail'
  });
  user.save();
  ```

  Your backend would be expected to return an error response that described
  the problem, so that error messages can be generated on the app.

  API responses will be translated into instances of `Errors` differently,
  depending on the specific combination of adapter and serializer used. You
  may want to check the documentation or the source code of the libraries
  that you are using, to know how they expect errors to be communicated.

  Errors can be displayed to the user by accessing their property name
  to get an array of all the error objects for that property. Each
  error object is a JavaScript object with two keys:

  - `message` A string containing the error message from the backend
  - `attribute` The name of the property associated with this error message

  ```handlebars
  <label>Username: <Input @value={{@model.username}} /> </label>
  {{#each @model.errors.username as |error|}}
    <div class="error">
      {{error.message}}
    </div>
  {{/each}}

  <label>Email: <Input @value={{@model.email}} /> </label>
  {{#each @model.errors.email as |error|}}
    <div class="error">
      {{error.message}}
    </div>
  {{/each}}
  ```

  You can also access the special `messages` property on the error
  object to get an array of all the error strings.

  ```handlebars
  {{#each @model.errors.messages as |message|}}
    <div class="error">
      {{message}}
    </div>
  {{/each}}
  ```

  @class Errors
  @public
 */
class Errors extends ArrayProxyWithCustomOverrides {
  /**
    @property errorsByAttributeName
    @type {MapWithDefault}
    @private
  */
  get errorsByAttributeName() {
    return new Map();
  }

  /**
    Returns errors for a given attribute
     ```javascript
    let user = store.createRecord('user', {
      username: 'tomster',
      email: 'invalidEmail'
    });
    user.save().catch(function(){
      user.errors.errorsFor('email'); // returns:
      // [{attribute: "email", message: "Doesn't look like a valid email."}]
    });
    ```
     @public
    @param {String} attribute
    @return {Array}
  */
  static {
    decorateMethodV2(this.prototype, "errorsByAttributeName", [computed()]);
  }
  errorsFor(attribute) {
    const map = this.errorsByAttributeName;
    let errors = map.get(attribute);
    if (errors === undefined) {
      errors = A();
      map.set(attribute, errors);
    }

    // Errors may be a native array with extensions turned on. Since we access
    // the array via a method, and not a computed or using `Ember.get`, it does
    // not entangle properly with autotracking, so we entangle manually by
    // getting the `[]` property.
    get(errors, '[]');
    return errors;
  }

  /**
    An array containing all of the error messages for this
    record. This is useful for displaying all errors to the user.
     ```handlebars
    {{#each @model.errors.messages as |message|}}
      <div class="error">
        {{message}}
      </div>
    {{/each}}
    ```
     @property messages
    @public
    @type {Array}
  */
  static {
    decorateFieldV2(this.prototype, "messages", [mapBy('content', 'message')]);
  }
  #messages = (initializeDeferredDecorator(this, "messages"), void 0);
  /**
    @property content
    @type {Array}
    @private
  */
  get content() {
    return A();
  }

  /**
    @private
  */
  static {
    decorateMethodV2(this.prototype, "content", [computed()]);
  }
  unknownProperty(attribute) {
    const errors = this.errorsFor(attribute);
    if (errors.length === 0) {
      return undefined;
    }
    return errors;
  }

  /**
    Total number of errors.
     @property length
    @type {Number}
    @public
    @readonly
  */

  /**
    `true` if we have no errors.
     @property isEmpty
    @type {Boolean}
    @public
    @readonly
  */
  static {
    decorateFieldV2(this.prototype, "isEmpty", [not('length')]);
  }
  #isEmpty = (initializeDeferredDecorator(this, "isEmpty"), void 0);
  /**
   Manually adds errors to the record. This will trigger the `becameInvalid` event/ lifecycle method on
    the record and transition the record into an `invalid` state.
    Example
   ```javascript
    let errors = user.errors;
     // add multiple errors
    errors.add('password', [
      'Must be at least 12 characters',
      'Must contain at least one symbol',
      'Cannot contain your name'
    ]);
     errors.errorsFor('password');
    // =>
    // [
    //   { attribute: 'password', message: 'Must be at least 12 characters' },
    //   { attribute: 'password', message: 'Must contain at least one symbol' },
    //   { attribute: 'password', message: 'Cannot contain your name' },
    // ]
     // add a single error
    errors.add('username', 'This field is required');
     errors.errorsFor('username');
    // =>
    // [
    //   { attribute: 'username', message: 'This field is required' },
    // ]
   ```
    @public
    @param {String} attribute - the property name of an attribute or relationship
    @param {string[]|string} messages - an error message or array of error messages for the attribute
   */
  add(attribute, messages) {
    const errors = this._findOrCreateMessages(attribute, messages);
    this.addObjects(errors);
    this.errorsFor(attribute).addObjects(errors);
    this.__record.currentState.notify('isValid');
    this.notifyPropertyChange(attribute);
  }

  /**
    @private
  */
  _findOrCreateMessages(attribute, messages) {
    const errors = this.errorsFor(attribute);
    const messagesArray = Array.isArray(messages) ? messages : [messages];
    const _messages = new Array(messagesArray.length);
    for (let i = 0; i < messagesArray.length; i++) {
      const message = messagesArray[i];
      const err = errors.findBy('message', message);
      if (err) {
        _messages[i] = err;
      } else {
        _messages[i] = {
          attribute: attribute,
          message
        };
      }
    }
    return _messages;
  }

  /**
   Manually removes all errors for a given member from the record.
     This will transition the record into a `valid` state, and
    triggers the `becameValid` event and lifecycle method.
    Example:
    ```javascript
    let errors = user.errors;
    errors.add('phone', ['error-1', 'error-2']);
     errors.errorsFor('phone');
    // =>
    // [
    //   { attribute: 'phone', message: 'error-1' },
    //   { attribute: 'phone', message: 'error-2' },
    // ]
     errors.remove('phone');
     errors.errorsFor('phone');
    // => undefined
   ```
    @public
   @param {String} member - the property name of an attribute or relationship
   */
  remove(attribute) {
    if (this.isEmpty) {
      return;
    }
    const content = this.rejectBy('attribute', attribute);
    this.content.setObjects(content);

    // Although errorsByAttributeName.delete is technically enough to sync errors state, we also
    // must mutate the array as well for autotracking
    const errors = this.errorsFor(attribute);
    for (let i = 0; i < errors.length; i++) {
      if (errors[i].attribute === attribute) {
        // .replace from Ember.NativeArray is necessary. JS splice will not work.
        errors.replace(i, 1);
      }
    }
    this.errorsByAttributeName.delete(attribute);
    this.__record.currentState.notify('isValid');
    this.notifyPropertyChange(attribute);
    this.notifyPropertyChange('length');
  }

  /**
   Manually clears all errors for the record.
     This will transition the record into a `valid` state, and
     will trigger the `becameValid` event and lifecycle method.
   Example:
    ```javascript
   let errors = user.errors;
   errors.add('username', ['error-a']);
   errors.add('phone', ['error-1', 'error-2']);
    errors.errorsFor('username');
   // =>
   // [
   //   { attribute: 'username', message: 'error-a' },
   // ]
    errors.errorsFor('phone');
   // =>
   // [
   //   { attribute: 'phone', message: 'error-1' },
   //   { attribute: 'phone', message: 'error-2' },
   // ]
    errors.clear();
    errors.errorsFor('username');
   // => undefined
    errors.errorsFor('phone');
   // => undefined
    errors.messages
   // => []
   ```
   @public
   */
  clear() {
    if (this.isEmpty) {
      return;
    }
    const errorsByAttributeName = this.errorsByAttributeName;
    const attributes = [];
    errorsByAttributeName.forEach(function (_, attribute) {
      attributes.push(attribute);
    });
    errorsByAttributeName.clear();
    attributes.forEach(attribute => {
      this.notifyPropertyChange(attribute);
    });
    this.__record.currentState.notify('isValid');
    super.clear();
  }

  /**
    Checks if there are error messages for the given attribute.
     ```js [app/controllers/user/edit.js]
    export default class UserEditController extends Controller {
      @action
      save(user) {
        if (user.errors.has('email')) {
          return alert('Please update your email before attempting to save.');
        }
        user.save();
      }
    }
    ```
     @public
    @param {String} attribute
    @return {Boolean} true if there some errors on given attribute
  */
  has(attribute) {
    return this.errorsFor(attribute).length > 0;
  }
}
export { Errors as E, LEGACY_SUPPORT as L, PromiseBelongsTo as P, PromiseManyArray as a, lookupLegacySupport as l };