import { getOwner } from '@ember/application';
import { deprecate } from '@ember/debug';
import EmberObject from '@ember/object';
import { recordIdentifierFor, storeFor } from '@warp-drive/core';
import { peekCache, notifyInternalSignal, peekInternalSignal, withSignalStore, ARRAY_SIGNAL, recordIdentifierFor as recordIdentifierFor$1, gate, memoized, defineSignal, coerceId, entangleSignal } from '@warp-drive/core/store/-private';
import { RecordStore } from '@warp-drive/core/types/symbols';
import { l as lookupLegacySupport, L as LEGACY_SUPPORT, E as Errors } from "./errors-BX5wowuz.js";
import { u as upgradeStore, F as FetchManager } from "./-private-CKrP0ogQ.js";
import { macroCondition, getGlobalConfig } from '@embroider/macros';
import { cacheFor } from '@ember/object/internals';
import { d as decorateMethodV2 } from "./runtime-BPCpkOf1-BKOwiRJp.js";
import { dasherize } from '@warp-drive/utilities/string';
function isElementDescriptor(args) {
  const [maybeTarget, maybeKey, maybeDesc] = args;
  return (
    // Ensure we have the right number of args
    args.length === 3 && (
    // Make sure the target is a class or object (prototype)
    typeof maybeTarget === 'function' || typeof maybeTarget === 'object' && maybeTarget !== null) &&
    // Make sure the key is a string
    typeof maybeKey === 'string' && (
    // Make sure the descriptor is the right shape
    typeof maybeDesc === 'object' && maybeDesc !== null && 'enumerable' in maybeDesc && 'configurable' in maybeDesc ||
    // TS compatibility
    maybeDesc === undefined)
  );
}
function normalizeModelName(type) {
  if (macroCondition(getGlobalConfig().WarpDrive.deprecations.DEPRECATE_NON_STRICT_TYPES)) {
    const result = dasherize(type);
    deprecate(`The resource type '${type}' is not normalized. Update your application code to use '${result}' instead of '${type}'.`, result === type, {
      id: 'ember-data:deprecate-non-strict-types',
      until: '6.0',
      for: 'ember-data',
      since: {
        available: '4.13',
        enabled: '5.3'
      }
    });
    return result;
  }
  return type;
}
function rollbackAttributes() {
  const {
    currentState
  } = this;
  const {
    isNew
  } = currentState;
  this[RecordStore]._join(() => {
    peekCache(this).rollbackAttrs(recordIdentifierFor(this));
    this.errors.clear();
    currentState.cleanErrorRequests();
    if (isNew) {
      this.unloadRecord();
    }
  });
}
function unloadRecord() {
  if (this.currentState.isNew && (this.isDestroyed || this.isDestroying)) {
    return;
  }
  this[RecordStore].unloadRecord(this);
}
function belongsTo(prop) {
  return lookupLegacySupport(this).referenceFor('belongsTo', prop);
}
function hasMany(prop) {
  return lookupLegacySupport(this).referenceFor('hasMany', prop);
}
function reload(options = {}) {
  options.isReloading = true;
  options.reload = true;
  const identifier = recordIdentifierFor(this);
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`You cannot reload a record without an ID`);
    }
  })(identifier.id) : {};
  this.isReloading = true;
  const promise = this[RecordStore].request({
    op: 'findRecord',
    data: {
      options,
      record: identifier
    },
    cacheOptions: {
      [Symbol.for('wd:skip-cache')]: true
    }
  }).then(() => this).finally(() => {
    this.isReloading = false;
  });
  return promise;
}
function changedAttributes() {
  return peekCache(this).changedAttrs(recordIdentifierFor(this));
}
function serialize(options) {
  upgradeStore(this[RecordStore]);
  return this[RecordStore].serializeRecord(this, options);
}
function deleteRecord() {
  // ensure we've populated currentState prior to deleting a new record
  if (this.currentState) {
    this[RecordStore].deleteRecord(this);
  }
}
function save(options) {
  let promise;
  if (this.currentState.isNew && this.currentState.isDeleted) {
    promise = Promise.resolve(this);
  } else {
    this.errors.clear();
    promise = this[RecordStore].saveRecord(this, options);
  }
  return promise;
}
function destroyRecord(options) {
  const {
    isNew
  } = this.currentState;
  this.deleteRecord();
  if (isNew) {
    return Promise.resolve(this);
  }
  return this.save(options).then(_ => {
    this.unloadRecord();
    return this;
  });
}
function createSnapshot() {
  const store = this[RecordStore];
  if (!store._fetchManager) {
    store._fetchManager = new FetchManager(store);
  }

  // @ts-expect-error Typescript isn't able to curry narrowed args that are divorced from each other.
  return store._fetchManager.createSnapshot(recordIdentifierFor(this));
}
function notifyChanges(identifier, value, key, record, store) {
  switch (value) {
    case 'added':
    case 'attributes':
      if (key) {
        notifyAttribute(store, identifier, key, record);
      } else {
        record.eachAttribute(name => {
          notifyAttribute(store, identifier, name, record);
        });
      }
      break;
    case 'relationships':
      if (key) {
        const meta = record.constructor.relationshipsByName.get(key);
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error(`Expected to find a relationship for ${key} on ${identifier.type}`);
          }
        })(meta) : {};
        notifyRelationship(identifier, key, record, meta);
      } else {
        record.eachRelationship((name, meta) => {
          notifyRelationship(identifier, name, record, meta);
        });
      }
      break;
    case 'identity':
      notifyInternalSignal(peekInternalSignal(withSignalStore(record), 'id'));
      break;
  }
}
function notifyRelationship(identifier, key, record, meta) {
  if (meta.kind === 'belongsTo') {
    record.notifyPropertyChange(key);
  } else if (meta.kind === 'hasMany') {
    const support = LEGACY_SUPPORT.get(identifier);
    const manyArray = support && support._manyArrayCache[key];
    const hasPromise = support && support._relationshipPromisesCache[key];
    if (manyArray && hasPromise) {
      // do nothing, we will notify the ManyArray directly
      // once the fetch has completed.
      return;
    }
    if (manyArray) {
      notifyInternalSignal(manyArray[ARRAY_SIGNAL]);

      //We need to notifyPropertyChange in the adding case because we need to make sure
      //we fetch the newly added record in case it is unloaded
      //TODO(Igor): Consider whether we could do this only if the record state is unloaded
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        if (!test) {
          throw new Error(`Expected options to exist on relationship meta`);
        }
      })(meta.options) : {};
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        if (!test) {
          throw new Error(`Expected async to exist on relationship meta options`);
        }
      })('async' in meta.options) : {};
      if (meta.options.async) {
        record.notifyPropertyChange(key);
      }
    }
  }
}
function notifyAttribute(store, identifier, key, record) {
  const currentValue = cacheFor(record, key);
  const cache = store.cache;
  if (currentValue !== cache.getAttr(identifier, key)) {
    record.notifyPropertyChange(key);
  }
}
const SOURCE_POINTER_REGEXP = /^\/?data\/(attributes|relationships)\/(.*)/;
const SOURCE_POINTER_PRIMARY_REGEXP = /^\/?data/;
const PRIMARY_ATTRIBUTE_KEY = 'base';
function isInvalidError(error) {
  return !!error && error instanceof Error && 'isAdapterError' in error && error.isAdapterError === true && 'code' in error && error.code === 'InvalidError';
}

/**
Historically EmberData managed a state machine
for each record, the localState for which
was reflected onto Model.

This implements the flags and stateName for backwards compat
with the state tree that used to be possible (listed below).

stateName and dirtyType are candidates for deprecation.

root
  empty
    deleted    // hidden from stateName
    preloaded  // hidden from stateName

  loading
     empty     // hidden from stateName
     preloaded // hidden from stateName

  loaded
    saved
    updated
      uncommitted
      invalid
      inFlight
    created
      uncommitted
      invalid
      inFlight

  deleted
    saved
      new      // hidden from stateName
    uncommitted
    invalid
    inFlight

  @internal
*/
class RecordState {
  constructor(record) {
    const store = storeFor(record);
    const identity = recordIdentifierFor$1(record);
    this.identifier = identity;
    this.record = record;
    this.cache = store.cache;
    this.pendingCount = 0;
    this.fulfilledCount = 0;
    this.rejectedCount = 0;
    this._errorRequests = [];
    this._lastError = null;
    const requests = store.getRequestStateService();
    const notifications = store.notifications;
    const handleRequest = req => {
      if (req.type === 'mutation') {
        switch (req.state) {
          case 'pending':
            this.isSaving = true;
            break;
          case 'rejected':
            this.isSaving = false;
            this._lastError = req;
            if (!(req.response && isInvalidError(req.response.data))) {
              this._errorRequests.push(req);
            }
            notifyErrorsStateChanged(this);
            break;
          case 'fulfilled':
            this._errorRequests = [];
            this._lastError = null;
            this.isSaving = false;
            this.notify('isDirty');
            notifyErrorsStateChanged(this);
            break;
        }
      } else {
        switch (req.state) {
          case 'pending':
            this.pendingCount++;
            this.notify('isLoading');
            break;
          case 'rejected':
            this.pendingCount--;
            this._lastError = req;
            if (!(req.response && isInvalidError(req.response.data))) {
              this._errorRequests.push(req);
            }
            this.notify('isLoading');
            notifyErrorsStateChanged(this);
            break;
          case 'fulfilled':
            this.pendingCount--;
            this.fulfilledCount++;
            this.notify('isLoading');
            this.notify('isDirty');
            notifyErrorsStateChanged(this);
            this._errorRequests = [];
            this._lastError = null;
            break;
        }
      }
    };
    requests.subscribeForRecord(identity, handleRequest);

    // we instantiate lazily
    // so we grab anything we don't have yet
    const lastRequest = requests.getLastRequestForRecord(identity);
    if (lastRequest) {
      handleRequest(lastRequest);
    }
    this.handler = notifications.subscribe(identity, (identifier, type, key) => {
      switch (type) {
        case 'state':
          this.notify('isSaved');
          this.notify('isNew');
          this.notify('isDeleted');
          this.notify('isDirty');
          break;
        case 'attributes':
          this.notify('isEmpty');
          this.notify('isDirty');
          break;
        case 'errors':
          this.updateInvalidErrors(this.record.errors);
          this.notify('isValid');
          break;
      }
    });
  }

  /** @internal */
  destroy() {
    storeFor(this.record).notifications.unsubscribe(this.handler);
  }

  /** @internal */
  notify(key) {
    const signals = withSignalStore(this);
    const signal = peekInternalSignal(signals, key);
    if (signal) {
      notifyInternalSignal(signal);
    }
  }

  /** @internal */
  updateInvalidErrors(errors) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected the Cache instance for ${this.identifier.lid}  to implement getErrors(identifier)`);
      }
    })(typeof this.cache.getErrors === 'function') : {};
    const jsonApiErrors = this.cache.getErrors(this.identifier);
    errors.clear();
    for (let i = 0; i < jsonApiErrors.length; i++) {
      const error = jsonApiErrors[i];
      if (error.source && error.source.pointer) {
        const keyMatch = error.source.pointer.match(SOURCE_POINTER_REGEXP);
        let key;
        if (keyMatch) {
          key = keyMatch[2];
        } else if (error.source.pointer.search(SOURCE_POINTER_PRIMARY_REGEXP) !== -1) {
          key = PRIMARY_ATTRIBUTE_KEY;
        }
        if (key) {
          const errMsg = error.detail || error.title;
          macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
            if (!test) {
              throw new Error(`Expected field error to have a detail or title to use as the message`);
            }
          })(errMsg) : {};
          errors.add(key, errMsg);
        }
      }
    }
  }

  /** @internal */
  cleanErrorRequests() {
    this.notify('isValid');
    this.notify('isError');
    this.notify('adapterError');
    this._errorRequests = [];
    this._lastError = null;
  }
  get isLoading() {
    return !this.isLoaded && this.pendingCount > 0 && this.fulfilledCount === 0;
  }
  static {
    decorateMethodV2(this.prototype, "isLoading", [gate]);
  }
  get isLoaded() {
    if (this.isNew) {
      return true;
    }
    return this.fulfilledCount > 0 || !this.isEmpty;
  }
  static {
    decorateMethodV2(this.prototype, "isLoaded", [gate]);
  }
  get isSaved() {
    const rd = this.cache;
    if (this.isDeleted) {
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        if (!test) {
          throw new Error(`Expected Cache to implement isDeletionCommitted()`);
        }
      })(typeof rd.isDeletionCommitted === 'function') : {};
      return rd.isDeletionCommitted(this.identifier);
    }
    if (this.isNew || this.isEmpty || !this.isValid || this.isDirty || this.isLoading) {
      return false;
    }
    return true;
  }
  static {
    decorateMethodV2(this.prototype, "isSaved", [gate]);
  }
  get isEmpty() {
    const rd = this.cache;
    // TODO this is not actually an RFC'd concept. Determine the
    // correct heuristic to replace this with.
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected Cache to implement isEmpty()`);
      }
    })(typeof rd.isEmpty === 'function') : {};
    return !this.isNew && rd.isEmpty(this.identifier);
  }
  static {
    decorateMethodV2(this.prototype, "isEmpty", [gate]);
  }
  get isNew() {
    const rd = this.cache;
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected Cache to implement isNew()`);
      }
    })(typeof rd.isNew === 'function') : {};
    return rd.isNew(this.identifier);
  }
  static {
    decorateMethodV2(this.prototype, "isNew", [gate]);
  }
  get isDeleted() {
    const rd = this.cache;
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected Cache to implement isDeleted()`);
      }
    })(typeof rd.isDeleted === 'function') : {};
    return rd.isDeleted(this.identifier);
  }
  static {
    decorateMethodV2(this.prototype, "isDeleted", [gate]);
  }
  get isValid() {
    return this.record.errors.length === 0;
  }
  static {
    decorateMethodV2(this.prototype, "isValid", [gate]);
  }
  get isDirty() {
    const rd = this.cache;
    if (this.isEmpty || rd.isDeletionCommitted(this.identifier) || this.isDeleted && this.isNew) {
      return false;
    }
    return this.isDeleted || this.isNew || rd.hasChangedAttrs(this.identifier);
  }
  static {
    decorateMethodV2(this.prototype, "isDirty", [gate]);
  }
  get isError() {
    const errorReq = this._errorRequests[this._errorRequests.length - 1];
    if (!errorReq) {
      return false;
    } else {
      return true;
    }
  }
  static {
    decorateMethodV2(this.prototype, "isError", [gate]);
  }
  get adapterError() {
    const request = this._lastError;
    if (!request) {
      return null;
    }
    return request.state === 'rejected' && request.response.data;
  }
  static {
    decorateMethodV2(this.prototype, "adapterError", [gate]);
  }
  get isPreloaded() {
    return !this.isEmpty && this.isLoading;
  }
  static {
    decorateMethodV2(this.prototype, "isPreloaded", [memoized]);
  }
  get stateName() {
    // we might be empty while loading so check this first
    if (this.isLoading) {
      return 'root.loading';

      // got nothing yet or were unloaded
    } else if (this.isEmpty) {
      return 'root.empty';

      // deleted substates
    } else if (this.isDeleted) {
      if (this.isSaving) {
        return 'root.deleted.inFlight';
      } else if (this.isSaved) {
        // TODO ensure isSaved isn't true from previous requests
        return 'root.deleted.saved';
      } else if (!this.isValid) {
        return 'root.deleted.invalid';
      } else {
        return 'root.deleted.uncommitted';
      }

      // loaded.created substates
    } else if (this.isNew) {
      if (this.isSaving) {
        return 'root.loaded.created.inFlight';
      } else if (!this.isValid) {
        return 'root.loaded.created.invalid';
      }
      return 'root.loaded.created.uncommitted';

      // loaded.updated substates
    } else if (this.isSaving) {
      return 'root.loaded.updated.inFlight';
    } else if (!this.isValid) {
      return 'root.loaded.updated.invalid';
    } else if (this.isDirty) {
      return 'root.loaded.updated.uncommitted';

      // if nothing remains, we are loaded saved!
    } else {
      return 'root.loaded.saved';
    }
  }
  static {
    decorateMethodV2(this.prototype, "stateName", [memoized]);
  }
  get dirtyType() {
    // we might be empty while loading so check this first
    if (this.isLoading || this.isEmpty) {
      return '';

      // deleted substates
    } else if (this.isDirty && this.isDeleted) {
      return 'deleted';

      // loaded.created substates
    } else if (this.isNew) {
      return 'created';

      // loaded.updated substates
    } else if (this.isSaving || !this.isValid || this.isDirty) {
      return 'updated';

      // if nothing remains, we are loaded saved!
    } else {
      return '';
    }
  }
  static {
    decorateMethodV2(this.prototype, "dirtyType", [memoized]);
  }
}
defineSignal(RecordState.prototype, 'isSaving', false);
function notifyErrorsStateChanged(state) {
  state.notify('isValid');
  state.notify('isError');
  state.notify('adapterError');
}

/*
 * This decorator allows us to lazily compute
 * an expensive getter on first-access and thereafter
 * never recompute it.
 */
function computeOnce(target, propertyName, desc) {
  const cache = new WeakMap();
  // eslint-disable-next-line @typescript-eslint/unbound-method
  const getter = desc.get;
  desc.get = function () {
    let meta = cache.get(this);
    if (!meta) {
      meta = {
        hasComputed: false,
        value: undefined
      };
      cache.set(this, meta);
    }
    if (!meta.hasComputed) {
      meta.value = getter.call(this);
      meta.hasComputed = true;
    }
    return meta.value;
  };
  return desc;
}

/**
 * @noInheritDoc
 */

/**
 * Base class from which Models can be defined.
 *
 * ::: code-group
 *
 * ```js [app/models/user.js]
 * import { Model, attr, belongsTo, hasMany } from '@warp-drive/legacy/model';
 *
 * export default class User extends Model {
 *   @attr name;
 *   @attr('number') age;
 *   @hasMany('post', { async: true, inverse: null }) posts;
 *   @belongsTo('group', { async: false, inverse: 'users' }) group;
 * }
 * ```
 *
 * ```ts [app/models/user.ts]
 * import { Model, attr, belongsTo, hasMany, type AsyncHasMany } from '@warp-drive/legacy/model';
 * import type { NumberTransform } from '@ember-data/serializer/transform';
 * import type Group from './group';
 * import type Post from './post';
 *
 * export default class User extends Model {
 *   @attr declare name: string;
 *
 *   @attr<NumberTransform>('number')
 *   declare age: number;
 *
 *   @hasMany('post', { async: true, inverse: null })
 *   declare posts: AsyncHasMany<Post>;
 *
 *   @belongsTo('group', { async: false, inverse: 'users' })
 *   declare group: Group | null;
 * }
 * ```
 *
 * :::
 *
 * Models both define the schema for a resource type and provide
 * the class to use as the reactive object for data of resource
 * of that type.
 *
 * @noInheritDoc
 */
class Model extends EmberObject {
  /** @internal */
  init(options) {
    if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
      if (!options?._secretInit && !options?._createProps) {
        throw new Error('You should not call `create` on a model. Instead, call `store.createRecord` with the attributes you would like to set.');
      }
    }
    const createProps = options._createProps;
    const _secretInit = options._secretInit;
    options._createProps = null;
    options._secretInit = null;
    const store = this.store = _secretInit.store;
    super.init(options);
    this[RecordStore] = store;
    const identity = _secretInit.identifier;
    _secretInit.cb(this, _secretInit.cache, identity, _secretInit.store);
    this.___recordState = macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? new RecordState(this) : null;
    this.setProperties(createProps);
    const notifications = store.notifications;
    this.___private_notifications = notifications.subscribe(identity, (identifier, type, field) => {
      notifyChanges(identifier, type, field, this, store);
    });
  }

  /** @internal */
  // @ts-expect-error destroy should not return a value, but ember's types force it to
  destroy() {
    const identifier = recordIdentifierFor(this);
    this.___recordState?.destroy();
    const store = storeFor(this);
    store.notifications.unsubscribe(this.___private_notifications);
    LEGACY_SUPPORT.get(this)?.destroy();
    LEGACY_SUPPORT.delete(this);
    LEGACY_SUPPORT.delete(identifier);
    super.destroy();
  }

  /**
    If this property is `true` the record is in the `empty`
    state. Empty is the first state all records enter after they have
    been created. Most records created by the store will quickly
    transition to the `loading` state if data needs to be fetched from
    the server or the `created` state if the record is created on the
    client. A record can also enter the empty state if the adapter is
    unable to locate the record.
     @property isEmpty
    @public
    @readonly
  */
  get isEmpty() {
    return this.currentState.isEmpty;
  }

  /**
    If this property is `true` the record is in the `loading` state. A
    record enters this state when the store asks the adapter for its
    data. It remains in this state until the adapter provides the
    requested data.
     @property isLoading
    @public
    @readonly
  */
  static {
    decorateMethodV2(this.prototype, "isEmpty", [memoized]);
  }
  get isLoading() {
    return this.currentState.isLoading;
  }

  /**
    If this property is `true` the record is in the `loaded` state. A
    record enters this state when its data is populated. Most of a
    record's lifecycle is spent inside substates of the `loaded`
    state.
     Example
     ```javascript
    let record = store.createRecord('model');
    record.isLoaded; // true
     const { content: { data: model } } = await store.request(findRecord({ type: 'model', id: '1' }));
    model.isLoaded;
    ```
     @property isLoaded
    @public
    @readonly
  */
  static {
    decorateMethodV2(this.prototype, "isLoading", [memoized]);
  }
  get isLoaded() {
    return this.currentState.isLoaded;
  }

  /**
    If this property is `true` the record is in the `dirty` state. The
    record has local changes that have not yet been saved by the
    adapter. This includes records that have been created (but not yet
    saved) or deleted.
     Example
     ```javascript
    let record = store.createRecord('model');
    record.hasDirtyAttributes; // true
     const { content: { data: model } } = await store.request(findRecord({ type: 'model', id: '1' }));
     model.hasDirtyAttributes; // false
    model.foo = 'some value';
    model.hasDirtyAttributes; // true
    ```
     @since 1.13.0
    @property hasDirtyAttributes
    @public
    @readonly
  */
  static {
    decorateMethodV2(this.prototype, "isLoaded", [memoized]);
  }
  get hasDirtyAttributes() {
    return this.currentState.isDirty;
  }

  /**
    If this property is `true` the record is in the `saving` state. A
    record enters the saving state when `save` is called, but the
    adapter has not yet acknowledged that the changes have been
    persisted to the backend.
     Example
     ```javascript
    let record = store.createRecord('model');
    record.isSaving; // false
    let promise = record.save();
    record.isSaving; // true
    promise.then(function() {
      record.isSaving; // false
    });
    ```
     @property isSaving
    @public
    @readonly
  */
  static {
    decorateMethodV2(this.prototype, "hasDirtyAttributes", [memoized]);
  }
  get isSaving() {
    return this.currentState.isSaving;
  }

  /**
    If this property is `true` the record is in the `deleted` state
    and has been marked for deletion. When `isDeleted` is true and
    `hasDirtyAttributes` is true, the record is deleted locally but the deletion
    was not yet persisted. When `isSaving` is true, the change is
    in-flight. When both `hasDirtyAttributes` and `isSaving` are false, the
    change has persisted.
     Example
     ```javascript
    let record = store.createRecord('model');
    record.isDeleted;    // false
    record.deleteRecord();
     // Locally deleted
    record.isDeleted;           // true
    record.hasDirtyAttributes;  // true
    record.isSaving;            // false
     // Persisting the deletion
    let promise = record.save();
    record.isDeleted;    // true
    record.isSaving;     // true
     // Deletion Persisted
    promise.then(function() {
      record.isDeleted;          // true
      record.isSaving;           // false
      record.hasDirtyAttributes; // false
    });
    ```
     @property isDeleted
    @public
    @readonly
  */
  static {
    decorateMethodV2(this.prototype, "isSaving", [memoized]);
  }
  get isDeleted() {
    return this.currentState.isDeleted;
  }

  /**
    If this property is `true` the record is in the `new` state. A
    record will be in the `new` state when it has been created on the
    client and the adapter has not yet report that it was successfully
    saved.
     Example
     ```javascript
    let record = store.createRecord('model');
    record.isNew; // true
     record.save().then(function(model) {
      model.isNew; // false
    });
    ```
     @property isNew
    @public
    @readonly
  */
  static {
    decorateMethodV2(this.prototype, "isDeleted", [memoized]);
  }
  get isNew() {
    return this.currentState.isNew;
  }

  /**
    If this property is `true` the record is in the `valid` state.
     A record will be in the `valid` state when the adapter did not report any
    server-side validation failures.
     @property isValid
    @public
    @readonly
  */
  static {
    decorateMethodV2(this.prototype, "isNew", [memoized]);
  }
  get isValid() {
    return this.currentState.isValid;
  }

  /**
    If the record is in the dirty state this property will report what
    kind of change has caused it to move into the dirty
    state. Possible values are:
     - `created` The record has been created by the client and not yet saved to the adapter.
    - `updated` The record has been updated by the client and not yet saved to the adapter.
    - `deleted` The record has been deleted by the client and not yet saved to the adapter.
     Example
     ```javascript
    let record = store.createRecord('model');
    record.dirtyType; // 'created'
    ```
     @property dirtyType
    @public
    @readonly
  */
  static {
    decorateMethodV2(this.prototype, "isValid", [memoized]);
  }
  get dirtyType() {
    return this.currentState.dirtyType;
  }

  /**
    If `true` the adapter reported that it was unable to save local
    changes to the backend for any reason other than a server-side
    validation error.
     Example
     ```javascript
    record.isError; // false
    record.set('foo', 'valid value');
    record.save().then(null, function() {
      record.isError; // true
    });
    ```
     @property isError
    @public
    @readonly
  */
  static {
    decorateMethodV2(this.prototype, "dirtyType", [memoized]);
  }
  get isError() {
    return this.currentState.isError;
  }
  static {
    decorateMethodV2(this.prototype, "isError", [memoized]);
  }
  set isError(v) {
    if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
      throw new Error(`isError is not directly settable`);
    }
  }

  /**
    If `true` the store is attempting to reload the record from the adapter.
     Example
     ```javascript
    record.isReloading; // false
    record.reload();
    record.isReloading; // true
    ```
     @property isReloading
    @public
    @readonly
  */

  /**
    All ember models have an id property. This is an identifier
    managed by an external source. These are always coerced to be
    strings before being used internally. Note when declaring the
    attributes for a model it is an error to declare an id
    attribute.
     ```javascript
    let record = store.createRecord('model');
    record.id; // null
     const { content: { data: model } } = await store.request(findRecord({ type: 'model', id: '1' }));
    model.id; // '1'
    ```
     @property id
    @public
  */
  get id() {
    // this guard exists, because some dev-only deprecation code
    // (addListener via validatePropertyInjections) invokes toString before the
    // object is real.
    if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
      try {
        return recordIdentifierFor(this).id;
      } catch {
        return null;
      }
    }
    return recordIdentifierFor(this).id;
  }
  static {
    decorateMethodV2(this.prototype, "id", [gate]);
  }
  set id(id) {
    const normalizedId = coerceId(id);
    const identifier = recordIdentifierFor(this);
    const didChange = normalizedId !== identifier.id;
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Cannot set ${identifier.type} record's id to ${id}, because id is already ${identifier.id}`);
      }
    })(!didChange || identifier.id === null) : {};
    if (normalizedId !== null && didChange) {
      this.store._instanceCache.setRecordId(identifier, normalizedId);
      this.store.notifications.notify(identifier, 'identity');
    }
  }
  toString() {
    return `<model::${this.constructor.modelName}:${this.id}>`;
  }

  /**
    @property currentState
    @private
  */
  // TODO we can probably make this a computeOnce
  // we likely do not need to notify the currentState root anymore
  get currentState() {
    // descriptors are called with the wrong `this` context during mergeMixins
    // when using legacy/classic ember classes. Basically: lazy in prod and eager in dev.
    // so we do this to try to steer folks to the nicer "dont user currentState"
    // error.
    if (macroCondition(!getGlobalConfig().WarpDrive.env.DEBUG)) {
      if (!this.___recordState) {
        this.___recordState = new RecordState(this);
      }
    }
    return this.___recordState;
  }
  static {
    decorateMethodV2(this.prototype, "currentState", [gate]);
  }
  set currentState(_v) {
    throw new Error('cannot set currentState');
  }

  /**
    The store service instance which created this record instance
    @property store
    @public
   */

  /**
    When the record is in the `invalid` state this object will contain
    any errors returned by the adapter. When present the errors hash
    contains keys corresponding to the invalid property names
    and values which are arrays of Javascript objects with two keys:
     - `message` A string containing the error message from the backend
    - `attribute` The name of the property associated with this error message
     ```javascript
    record.errors.length; // 0
    record.set('foo', 'invalid value');
    record.save().catch(function() {
      record.errors.foo;
      // [{message: 'foo should be a number.', attribute: 'foo'}]
    });
    ```
     The `errors` property is useful for displaying error messages to
    the user.
     ```handlebars
    <label>Username: <Input @value={{@model.username}} /> </label>
    {{#each @model.errors.username as |error|}}
      <div class="error">
        {{error.message}}
      </div>
    {{/each}}
    <label>Email: <Input @value={{@model.email}} /> </label>
    {{#each @model.errors.email as |error|}}
      <div class="error">
        {{error.message}}
      </div>
    {{/each}}
    ```
      You can also access the special `messages` property on the error
    object to get an array of all the error strings.
     ```handlebars
    {{#each @model.errors.messages as |message|}}
      <div class="error">
        {{message}}
      </div>
    {{/each}}
    ```
     @property errors
    @public
  */
  get errors() {
    const errors = Errors.create({
      __record: this
    });
    this.currentState.updateInvalidErrors(errors);
    return errors;
  }

  /**
    This property holds the `AdapterError` object with which
    last adapter operation was rejected.
     @property adapterError
    @public
  */
  static {
    decorateMethodV2(this.prototype, "errors", [computeOnce]);
  }
  get adapterError() {
    return this.currentState.adapterError;
  }
  static {
    decorateMethodV2(this.prototype, "adapterError", [memoized]);
  }
  set adapterError(v) {
    throw new Error(`adapterError is not directly settable`);
  }

  /*
    We hook the default implementation to ensure
    our tagged properties are properly notified
    as well. We still super for everything because
    sync observers require a direct call occuring
    to trigger their flush. We wouldn't need to
    super in 4.0+ where sync observers are removed.
   */
  // @ts-expect-error no return is necessary, but Ember's types are forcing it
  notifyPropertyChange(prop) {
    const signals = withSignalStore(this);
    entangleSignal(signals, this, prop, undefined);
    super.notifyPropertyChange(prop);
  }

  /** @internal */
  attr() {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error('The `attr` method is not available on Model, a Snapshot was probably expected. Are you passing a Model instead of a Snapshot to your serializer?');
      }
    })() : {};
  }

  /**
   Given a callback, iterates over each of the relationships in the model,
   invoking the callback with the name of each relationship and its relationship
   descriptor.
     The callback method you provide should have the following signature (all
   parameters are optional):
    ```javascript
   function(name, descriptor);
   ```
    - `name` the name of the current property in the iteration
   - `descriptor` the meta object that describes this relationship
    The relationship descriptor argument is an object with the following properties.
    - **name** <span class="type">String</span> the name of this relationship on the Model
   - **kind** <span class="type">String</span> "hasMany" or "belongsTo"
   - **options** <span class="type">Object</span> the original options hash passed when the relationship was declared
   - **parentType** <span class="type">Model</span> the type of the Model that owns this relationship
   - **type** <span class="type">String</span> the type name of the related Model
    Note that in addition to a callback, you can also pass an optional target
   object that will be set as `this` on the context.
    Example
    ```js [app/serializers/application.js]
   import JSONSerializer from '@ember-data/serializer/json';
    export default class ApplicationSerializer extends JSONSerializer {
      serialize(record, options) {
      let json = {};
       record.eachRelationship(function(name, descriptor) {
        if (descriptor.kind === 'hasMany') {
          let serializedHasManyName = name.toUpperCase() + '_IDS';
          json[serializedHasManyName] = record.get(name).map(r => r.id);
        }
      });
       return json;
    }
  }
   ```
    @public
   @param {Function} callback the callback to invoke
   @param {any} binding the value to which the callback's `this` should be bound
   */
  eachRelationship(callback, binding) {
    this.constructor.eachRelationship(callback, binding);
  }
  relationshipFor(name) {
    return this.constructor.relationshipsByName.get(name);
  }
  inverseFor(name) {
    return this.constructor.inverseFor(name, storeFor(this));
  }
  eachAttribute(callback, binding) {
    this.constructor.eachAttribute(callback, binding);
  }

  /**
   * @internal
   */
  static isModel = true;

  /**
   Represents the model's class name as a string. This can be used to look up the model's class name through
   `Store`'s modelFor method.
    `modelName` is generated for you by EmberData. It will be a lowercased, dasherized string.
   For example:
    ```javascript
   store.modelFor('post').modelName; // 'post'
   store.modelFor('blog-post').modelName; // 'blog-post'
   ```
    The most common place you'll want to access `modelName` is in your serializer's `payloadKeyFromModelName` method. For example, to change payload
   keys to underscore (instead of dasherized), you might use the following code:
    ```javascript
   import RESTSerializer from '@ember-data/serializer/rest';
   import { underscore } from '<app-name>/utils/string-utils';
    export default const PostSerializer = RESTSerializer.extend({
     payloadKeyFromModelName(modelName) {
       return underscore(modelName);
     }
   });
   ```
   @property modelName
    @public
   @readonly
  */
  static modelName = null;

  /*
   These class methods below provide relationship
   introspection abilities about relationships.
    A note about the computed properties contained here:
    **These properties are effectively sealed once called for the first time.**
   To avoid repeatedly doing expensive iteration over a model's fields, these
   values are computed once and then cached for the remainder of the runtime of
   your application.
    If your application needs to modify a class after its initial definition
   (for example, using `reopen()` to add additional attributes), make sure you
   do it before using your model with the store, which uses these properties
   extensively.
   */

  /**
   For a given relationship name, returns the model type of the relationship.
    For example, if you define a model like this:
    ```js [app/models/post.js]
   import { Model, hasMany } from '@warp-drive/legacy/model';
    export default class PostModel extends Model {
     @hasMany('comment') comments;
   }
   ```
    Calling `store.modelFor('post').typeForRelationship('comments', store)` will return `Comment`.
     @public
   @param {String} name the name of the relationship
   @param {store} store an instance of Store
   @return {Model} the type of the relationship, or undefined
   */
  static typeForRelationship(name, store) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    const relationship = this.relationshipsByName.get(name);
    return relationship && store.modelFor(relationship.type);
  }
  static get inverseMap() {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    return Object.create(null);
  }

  /**
   Find the relationship which is the inverse of the one asked for.
    For example, if you define models like this:
    ```js [app/models/post.js]
   import { Model, hasMany } from '@warp-drive/legacy/model';
    export default class PostModel extends Model {
      @hasMany('message') comments;
    }
   ```
    ```js [app/models/message.js]
   import { Model, belongsTo } from '@warp-drive/legacy/model';
    export default class MessageModel extends Model {
      @belongsTo('post') owner;
    }
   ```
    ``` js
   store.modelFor('post').inverseFor('comments', store) // { type: 'message', name: 'owner', kind: 'belongsTo' }
   store.modelFor('message').inverseFor('owner', store) // { type: 'post', name: 'comments', kind: 'hasMany' }
   ```
     @public
   @param {String} name the name of the relationship
   @param {Store} store
   @return {Object} the inverse relationship, or null
   */
  static {
    decorateMethodV2(this, "inverseMap", [computeOnce]);
  }
  static inverseFor(name, store) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    const inverseMap = this.inverseMap;
    if (inverseMap[name]) {
      return inverseMap[name];
    } else {
      const inverse = this._findInverseFor(name, store);
      inverseMap[name] = inverse;
      return inverse;
    }
  }

  //Calculate the inverse, ignoring the cache
  static _findInverseFor(name, store) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    const relationship = this.relationshipsByName.get(name);
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`No relationship named '${name}' on '${this.modelName}' exists.`);
      }
    })(relationship) : {};
    if (!relationship) {
      return null;
    }
    const {
      options
    } = relationship;
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Expected the relationship ${name} on ${this.modelName} to define an inverse.`);
      }
    })(options.inverse === null || typeof options.inverse === 'string' && options.inverse.length > 0) : {};
    if (options.inverse === null) {
      return null;
    }
    const schemaExists = store.schema.hasResource(relationship);
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`No associated schema found for '${relationship.type}' while calculating the inverse of ${name} on ${this.modelName}`);
      }
    })(schemaExists) : {};
    if (!schemaExists) {
      return null;
    }
    const inverseField = store.schema.fields(relationship).get(options.inverse);
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`No inverse relationship found for '${name}' on '${this.modelName}'`);
      }
    })(inverseField && (inverseField.kind === 'belongsTo' || inverseField.kind === 'hasMany')) : {};
    return inverseField || null;
  }

  /**
   The model's relationships as a map, keyed on the type of the
   relationship. The value of each entry is an array containing a descriptor
   for each relationship with that type, describing the name of the relationship
   as well as the type.
    For example, given the following model definition:
    ```js [app/models/blog.js]
   import { Model, belongsTo, hasMany } from '@warp-drive/legacy/model';
    export default class BlogModel extends Model {
      @hasMany('user') users;
      @belongsTo('user') owner;
      @hasMany('post') posts;
    }
   ```
    This computed property would return a map describing these
   relationships, like this:
    ```javascript
   import Blog from 'app/models/blog';
   import User from 'app/models/user';
   import Post from 'app/models/post';
    let relationships = Blog.relationships;
   relationships.user;
   //=> [ { name: 'users', kind: 'hasMany' },
   //     { name: 'owner', kind: 'belongsTo' } ]
   relationships.post;
   //=> [ { name: 'posts', kind: 'hasMany' } ]
   ```
    @property relationships
    @public
   @readonly
   */

  static get relationships() {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    const map = new Map();
    const relationshipsByName = this.relationshipsByName;

    // Loop through each computed property on the class
    relationshipsByName.forEach(desc => {
      const {
        type
      } = desc;
      if (!map.has(type)) {
        map.set(type, []);
      }
      map.get(type).push(desc);
    });
    return map;
  }

  /**
   A hash containing lists of the model's relationships, grouped
   by the relationship kind. For example, given a model with this
   definition:
    ```js [app/models/blog.js]
   import { Model, belongsTo, hasMany } from '@warp-drive/legacy/model';
    export default class BlogModel extends Model {
      @hasMany('user') users;
      @belongsTo('user') owner;
       @hasMany('post') posts;
    }
   ```
    This property would contain the following:
    ```javascript
   import Blog from 'app/models/blog';
    let relationshipNames = Blog.relationshipNames;
   relationshipNames.hasMany;
   //=> ['users', 'posts']
   relationshipNames.belongsTo;
   //=> ['owner']
   ```
    @property relationshipNames
    @public
   @readonly
   */
  static {
    decorateMethodV2(this, "relationships", [computeOnce]);
  }
  static get relationshipNames() {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    const names = {
      hasMany: [],
      belongsTo: []
    };
    this.eachComputedProperty((name, meta) => {
      if (isRelationshipSchema(meta)) {
        names[meta.kind].push(name);
      }
    });
    return names;
  }

  /**
   An array of types directly related to a model. Each type will be
   included once, regardless of the number of relationships it has with
   the model.
    For example, given a model with this definition:
    ```js [app/models/blog.js]
   import { Model, belongsTo, hasMany } from '@warp-drive/legacy/model';
    export default class BlogModel extends Model {
      @hasMany('user') users;
      @belongsTo('user') owner;
       @hasMany('post') posts;
    }
   ```
    This property would contain the following:
    ```javascript
   import Blog from 'app/models/blog';
    let relatedTypes = Blog.relatedTypes');
   //=> ['user', 'post']
   ```
    @property relatedTypes
   @public
   @readonly
   */
  static {
    decorateMethodV2(this, "relationshipNames", [computeOnce]);
  }
  static get relatedTypes() {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    const types = [];
    const rels = this.relationshipsObject;
    const relationships = Object.keys(rels);

    // create an array of the unique types involved
    // in relationships
    for (let i = 0; i < relationships.length; i++) {
      const name = relationships[i];
      const meta = rels[name];
      const modelName = meta.type;
      if (!types.includes(modelName)) {
        types.push(modelName);
      }
    }
    return types;
  }

  /**
   A map whose keys are the relationships of a model and whose values are
   relationship descriptors.
    For example, given a model with this
   definition:
    ```js [app/models/blog.js]
   import { Model, belongsTo, hasMany } from '@warp-drive/legacy/model';
    export default class BlogModel extends Model {
      @hasMany('user') users;
      @belongsTo('user') owner;
       @hasMany('post') posts;
    }
   ```
    This property would contain the following:
    ```javascript
   import Blog from 'app/models/blog';
    let relationshipsByName = Blog.relationshipsByName;
   relationshipsByName.users;
   //=> { name: 'users', kind: 'hasMany', type: 'user', options: Object }
   relationshipsByName.owner;
   //=> { name: 'owner', kind: 'belongsTo', type: 'user', options: Object }
   ```
    @property relationshipsByName
    @public
   @readonly
   */
  static {
    decorateMethodV2(this, "relatedTypes", [computeOnce]);
  }
  static get relationshipsByName() {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    const map = new Map();
    const rels = this.relationshipsObject;
    const relationships = Object.keys(rels);
    for (let i = 0; i < relationships.length; i++) {
      const name = relationships[i];
      const value = rels[name];
      map.set(value.name, value);
    }
    return map;
  }
  static {
    decorateMethodV2(this, "relationshipsByName", [computeOnce]);
  }
  static get relationshipsObject() {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    const relationships = Object.create(null);
    const modelName = this.modelName;
    this.eachComputedProperty((name, meta) => {
      if (!isRelationshipSchema(meta)) {
        return;
      }
      // TODO deprecate key being here
      meta.key = name;
      meta.name = name;
      relationships[name] = meta;
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        if (!test) {
          throw new Error(`Expected options in meta`);
        }
      })(meta.options && typeof meta.options === 'object') : {};
      macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
        if (!test) {
          throw new Error(`You should not specify both options.as and options.inverse as null on ${modelName}.${meta.name}, as if there is no inverse field there is no abstract type to conform to. You may have intended for this relationship to be polymorphic, or you may have mistakenly set inverse to null.`);
        }
      })(!(meta.options.inverse === null && meta.options.as?.length)) : {};
    });
    return relationships;
  }

  /**
   A map whose keys are the fields of the model and whose values are strings
   describing the kind of the field. A model's fields are the union of all of its
   attributes and relationships.
    For example:
    ```js [app/models/blog.js]
   import { Model, attr, belongsTo, hasMany } from '@warp-drive/legacy/model';
    export default class BlogModel extends Model {
      @hasMany('user') users;
      @belongsTo('user') owner;
       @hasMany('post') posts;
       @attr('string') title;
    }
   ```
    ```js
   import Blog from 'app/models/blog'
    let fields = Blog.fields;
   fields.forEach(function(kind, field) {
      // do thing
    });
    // prints:
   // users, hasMany
   // owner, belongsTo
   // posts, hasMany
   // title, attribute
   ```
    @property fields
    @public
   @readonly
   */
  static {
    decorateMethodV2(this, "relationshipsObject", [computeOnce]);
  }
  static get fields() {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    const map = new Map();
    this.eachComputedProperty((name, meta) => {
      if (isRelationshipSchema(meta)) {
        map.set(name, meta.kind);
      } else if (isAttributeSchema(meta)) {
        map.set(name, 'attribute');
      }
    });
    return map;
  }

  /**
   Given a callback, iterates over each of the relationships in the model,
   invoking the callback with the name of each relationship and its relationship
   descriptor.
     @public
   @param {Function} callback the callback to invoke
   @param {any} binding the value to which the callback's `this` should be bound
   */
  static {
    decorateMethodV2(this, "fields", [computeOnce]);
  }
  static eachRelationship(callback, binding) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    this.relationshipsByName.forEach((relationship, name) => {
      callback.call(binding, name, relationship);
    });
  }

  /**
   Given a callback, iterates over each of the types related to a model,
   invoking the callback with the related type's class. Each type will be
   returned just once, regardless of how many different relationships it has
   with a model.
     @public
   @param {Function} callback the callback to invoke
   @param {any} binding the value to which the callback's `this` should be bound
   */
  static eachRelatedType(callback, binding) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    const relationshipTypes = this.relatedTypes;
    for (let i = 0; i < relationshipTypes.length; i++) {
      const type = relationshipTypes[i];
      callback.call(binding, type);
    }
  }

  /**
   *
   * @private
   * @deprecated
   */
  static determineRelationshipType(knownSide, store) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    const knownKey = knownSide.name;
    const knownKind = knownSide.kind;
    const inverse = this.inverseFor(knownKey, store);
    // let key;

    if (!inverse) {
      return knownKind === 'belongsTo' ? 'oneToNone' : 'manyToNone';
    }

    // key = inverse.name;
    const otherKind = inverse.kind;
    if (otherKind === 'belongsTo') {
      return knownKind === 'belongsTo' ? 'oneToOne' : 'manyToOne';
    } else {
      return knownKind === 'belongsTo' ? 'oneToMany' : 'manyToMany';
    }
  }

  /**
   A map whose keys are the attributes of the model (properties
   described by attr) and whose values are the meta object for the
   property.
    Example
    ```js [app/models/person.js]
   import { Model, attr } from '@warp-drive/legacy/model';
    export default class PersonModel extends Model {
      @attr('string') firstName;
      @attr('string') lastName;
      @attr('date') birthday;
    }
   ```
    ```javascript
   import Person from 'app/models/person'
    let attributes = Person.attributes
    attributes.forEach(function(meta, name) {
      // do thing
    });
    // prints:
   // firstName {type: "string", kind: 'attribute', options: Object, parentType: function, name: "firstName"}
   // lastName {type: "string", kind: 'attribute', options: Object, parentType: function, name: "lastName"}
   // birthday {type: "date", kind: 'attribute', options: Object, parentType: function, name: "birthday"}
   ```
    @property attributes
    @public
   @readonly
   */
  static get attributes() {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    const map = new Map();
    this.eachComputedProperty((name, meta) => {
      if (isAttributeSchema(meta)) {
        macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
          if (!test) {
            throw new Error("You may not set 'id' as an attribute on your model. Please remove any lines that look like: `id: attr('<type>')` from " + this.toString());
          }
        })(name !== 'id') : {};

        // TODO deprecate key being here
        meta.key = name;
        meta.name = name;
        map.set(name, meta);
      }
    });
    return map;
  }

  /**
   A map whose keys are the attributes of the model (properties
   described by attr) and whose values are type of transformation
   applied to each attribute. This map does not include any
   attributes that do not have an transformation type.
    Example
    ```js [app/models/person.js]
   import { Model, attr } from '@warp-drive/legacy/model';
    export default class PersonModel extends Model {
      @attr firstName;
      @attr('string') lastName;
      @attr('date') birthday;
    }
   ```
    ```javascript
   import Person from 'app/models/person';
    let transformedAttributes = Person.transformedAttributes
    transformedAttributes.forEach(function(field, type) {
      // do thing
    });
    // prints:
   // lastName string
   // birthday date
   ```
    @property transformedAttributes
    @public
   @readonly
   */
  static {
    decorateMethodV2(this, "attributes", [computeOnce]);
  }
  static get transformedAttributes() {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    const map = new Map();
    this.eachAttribute((name, meta) => {
      if (meta.type) {
        map.set(name, meta.type);
      }
    });
    return map;
  }

  /**
   Iterates through the attributes of the model, calling the passed function on each
   attribute.
    The callback method you provide should have the following signature (all
   parameters are optional):
    ```javascript
   function(name, meta);
   ```
    - `name` the name of the current property in the iteration
   - `meta` the meta object for the attribute property in the iteration
    Note that in addition to a callback, you can also pass an optional target
   object that will be set as `this` on the context.
    Example
    ```javascript
   import { Model, attr } from '@warp-drive/legacy/model';
    class PersonModel extends Model {
      @attr('string') firstName;
      @attr('string') lastName;
      @attr('date') birthday;
    }
    PersonModel.eachAttribute(function(name, meta) {
      // do thing
    });
    // prints:
   // firstName {type: "string", kind: 'attribute', options: Object, parentType: function, name: "firstName"}
   // lastName {type: "string", kind: 'attribute', options: Object, parentType: function, name: "lastName"}
   // birthday {type: "date", kind: 'attribute', options: Object, parentType: function, name: "birthday"}
   ```
     @public
   @param {Function} callback The callback to execute
   @param {Object} [binding] the value to which the callback's `this` should be bound
   */
  static {
    decorateMethodV2(this, "transformedAttributes", [computeOnce]);
  }
  static eachAttribute(callback, binding) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    this.attributes.forEach((meta, name) => {
      callback.call(binding, name, meta);
    });
  }

  /**
   Iterates through the transformedAttributes of the model, calling
   the passed function on each attribute. Note the callback will not be
   called for any attributes that do not have an transformation type.
    The callback method you provide should have the following signature (all
   parameters are optional):
    ```javascript
   function(name, type);
   ```
    - `name` the name of the current property in the iteration
   - `type` a string containing the name of the type of transformed
   applied to the attribute
    Note that in addition to a callback, you can also pass an optional target
   object that will be set as `this` on the context.
    Example
    ```javascript
   import { Model, attr } from '@warp-drive/legacy/model';
    let Person = Model.extend({
      firstName: attr(),
      lastName: attr('string'),
      birthday: attr('date')
    });
    Person.eachTransformedAttribute(function(name, type) {
      // do thing
    });
    // prints:
   // lastName string
   // birthday date
   ```
     @public
   @param {Function} callback The callback to execute
   @param {Object} [binding] the value to which the callback's `this` should be bound
   */
  static eachTransformedAttribute(callback, binding) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    this.transformedAttributes.forEach((type, name) => {
      callback.call(binding, name, type);
    });
  }

  /**
   Returns the name of the model class.
     @public
   */
  static toString() {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);
      }
    })(this.modelName) : {};
    return `model:${this.modelName}`;
  }
}

// @ts-expect-error TS doesn't know how to do `this` function overloads
Model.prototype.save = save;
// @ts-expect-error TS doesn't know how to do `this` function overloads
Model.prototype.destroyRecord = destroyRecord;
Model.prototype.unloadRecord = unloadRecord;
Model.prototype.hasMany = hasMany;
Model.prototype.belongsTo = belongsTo;
Model.prototype.serialize = serialize;
Model.prototype._createSnapshot = createSnapshot;
Model.prototype.deleteRecord = deleteRecord;
Model.prototype.changedAttributes = changedAttributes;
Model.prototype.rollbackAttributes = rollbackAttributes;
Model.prototype.reload = reload;
defineSignal(Model.prototype, 'isReloading', false);

// this is required to prevent `init` from passing
// the values initialized during create to `setUnknownProperty`
Model.prototype._createProps = null;
Model.prototype._secretInit = null;
if (macroCondition(getGlobalConfig().WarpDrive.env.DEBUG)) {
  const lookupDescriptor = function lookupDescriptor(obj, keyName) {
    let current = obj;
    do {
      const descriptor = Object.getOwnPropertyDescriptor(current, keyName);
      if (descriptor !== undefined) {
        return descriptor;
      }
      current = Object.getPrototypeOf(current);
    } while (current !== null);
    return null;
  };

  // eslint-disable-next-line @typescript-eslint/unbound-method
  const init = Model.prototype.init;
  Model.prototype.init = function (createArgs) {
    init.call(this, createArgs);
    const ourDescriptor = lookupDescriptor(Model.prototype, 'currentState');
    const theirDescriptor = lookupDescriptor(this, 'currentState');
    if (!ourDescriptor || !theirDescriptor) {
      throw new Error(`Unable to determine if 'currentState' is a reserved property name on instances of classes extending Model. Please ensure that 'currentState' is not defined as a property on ${this.constructor.toString()}`);
    }
    const realState = this.___recordState;
    if (ourDescriptor.get !== theirDescriptor.get || realState !== this.currentState) {
      throw new Error(`'currentState' is a reserved property name on instances of classes extending Model. Please choose a different property name for ${this.constructor.toString()}`);
    }
    const ID_DESCRIPTOR = lookupDescriptor(Model.prototype, 'id');
    const idDesc = lookupDescriptor(this, 'id');
    if (!ID_DESCRIPTOR || !idDesc) {
      throw new Error(`Unable to determine if 'id' is a reserved property name on instances of classes extending Model. Please ensure that 'id' is not defined as a property on ${this.constructor.toString()}`);
    }
    if (idDesc.get !== ID_DESCRIPTOR.get) {
      throw new Error(`You may not set 'id' as an attribute on your model. Please remove any lines that look like: \`id: attr('<type>')\` from ${this.constructor.toString()}`);
    }
  };
  delete Model.reopen;
  delete Model.reopenClass;
}
function isRelationshipSchema(meta) {
  const hasKind = typeof meta === 'object' && meta !== null && 'kind' in meta && 'options' in meta;
  return hasKind && (meta.kind === 'hasMany' || meta.kind === 'belongsTo');
}
function isAttributeSchema(meta) {
  return typeof meta === 'object' && meta !== null && 'kind' in meta && meta.kind === 'attribute';
}

/*
    In case someone defined a relationship to a mixin, for example:
    ```ts
      class CommentModel extends Model {
        @belongsTo('commentable', { polymorphic: true }) owner;
      }

      let Commentable = Mixin.create({
        @hasMany('comment') comments;
      });
    ```
    we want to look up a Commentable class which has all the necessary
    relationship meta data. Thus, we look up the mixin and create a mock
    Model, so we can access the relationship CPs of the mixin (`comments`)
    in this case
  */
function modelForMixin(store, normalizedModelName) {
  const owner = getOwner(store);
  const MaybeMixin = owner.factoryFor(`mixin:${normalizedModelName}`);
  const mixin = MaybeMixin && MaybeMixin.class;
  if (mixin) {
    const ModelForMixin = Model.extend(mixin);
    ModelForMixin.__isMixin = true;
    ModelForMixin.__mixin = mixin;
    //Cache the class as a model
    owner.register(`model:${normalizedModelName}`, ModelForMixin);
  }
  return owner.factoryFor(`model:${normalizedModelName}`);
}
class ModelSchemaProvider {
  constructor(store) {
    this.store = store;
    this._schemas = new Map();
    this._typeMisses = new Set();
  }
  resourceTypes() {
    return Array.from(this._schemas.keys());
  }
  hasTrait(type) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`hasTrait is not available with @ember-data/model's SchemaService`);
      }
    })() : {};
    return false;
  }
  resourceHasTrait(resource, trait) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`resourceHasTrait is not available with @ember-data/model's SchemaService`);
      }
    })() : {};
    return false;
  }
  transformation(field) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`transformation is not available with @ember-data/model's SchemaService`);
      }
    })() : {};
  }
  derivation(field) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`derivation is not available with @ember-data/model's SchemaService`);
      }
    })() : {};
  }
  hashFn(field) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`hashFn is not available with @ember-data/model's SchemaService`);
      }
    })() : {};
  }
  resource(resource) {
    const type = normalizeModelName(resource.type);
    if (!this._schemas.has(type)) {
      this._loadModelSchema(type);
    }
    return this._schemas.get(type).schema;
  }
  registerResources(schemas) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`registerResources is not available with @ember-data/model's SchemaService`);
      }
    })() : {};
  }
  registerResource(schema) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`registerResource is not available with @ember-data/model's SchemaService`);
      }
    })() : {};
  }
  registerTransformation(transform) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`registerTransformation is not available with @ember-data/model's SchemaService`);
      }
    })() : {};
  }
  registerDerivation(derivation) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`registerDerivation is not available with @ember-data/model's SchemaService`);
      }
    })() : {};
  }
  registerHashFn(hashFn) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      {
        throw new Error(`registerHashFn is not available with @ember-data/model's SchemaService`);
      }
    })() : {};
  }
  _loadModelSchema(type) {
    const modelClass = this.store.modelFor(type);
    const attributeMap = modelClass.attributes;
    const attributes = Object.create(null);
    attributeMap.forEach((meta, name) => attributes[name] = meta);
    const relationships = modelClass.relationshipsObject || null;
    const fields = new Map();
    for (const attr of Object.values(attributes)) {
      fields.set(attr.name, attr);
    }
    for (const rel of Object.values(relationships)) {
      fields.set(rel.name, rel);
    }
    const schema = {
      legacy: true,
      identity: {
        name: 'id',
        kind: '@id'
      },
      type,
      fields: Array.from(fields.values())
    };
    const internalSchema = {
      schema,
      attributes,
      relationships,
      fields
    };
    this._schemas.set(type, internalSchema);
    return internalSchema;
  }
  fields(resource) {
    const type = normalizeModelName(resource.type);
    if (!this._schemas.has(type)) {
      this._loadModelSchema(type);
    }
    return this._schemas.get(type).fields;
  }
  hasResource(resource) {
    const type = normalizeModelName(resource.type);
    if (this._schemas.has(type)) {
      return true;
    }
    if (this._typeMisses.has(type)) {
      return false;
    }
    const factory = getModelFactory(this.store, type);
    const exists = factory !== null;
    if (!exists) {
      this._typeMisses.add(type);
      return false;
    }
    return true;
  }
}
if (macroCondition(getGlobalConfig().WarpDrive.deprecations.ENABLE_LEGACY_SCHEMA_SERVICE)) {
  ModelSchemaProvider.prototype.doesTypeExist = function (type) {
    deprecate(`Use \`schema.hasResource({ type })\` instead of \`schema.doesTypeExist(type)\``, false, {
      id: 'ember-data:schema-service-updates',
      until: '6.0',
      for: 'ember-data',
      since: {
        available: '4.13',
        enabled: '5.4'
      }
    });
    return this.hasResource({
      type
    });
  };
  ModelSchemaProvider.prototype.attributesDefinitionFor = function (resource) {
    deprecate(`Use \`schema.fields({ type })\` instead of \`schema.attributesDefinitionFor({ type })\``, false, {
      id: 'ember-data:schema-service-updates',
      until: '6.0',
      for: 'ember-data',
      since: {
        available: '4.13',
        enabled: '5.4'
      }
    });
    const type = normalizeModelName(resource.type);

    // @ts-expect-error intentional use of internal API
    if (!this._schemas.has(type)) {
      // @ts-expect-error intentional use of internal API
      this._loadModelSchema(type);
    }

    // @ts-expect-error intentional use of internal API
    return this._schemas.get(type).attributes;
  };
  ModelSchemaProvider.prototype.relationshipsDefinitionFor = function (resource) {
    deprecate(`Use \`schema.fields({ type })\` instead of \`schema.relationshipsDefinitionFor({ type })\``, false, {
      id: 'ember-data:schema-service-updates',
      until: '6.0',
      for: 'ember-data',
      since: {
        available: '4.13',
        enabled: '5.4'
      }
    });
    const type = normalizeModelName(resource.type);

    // @ts-expect-error intentional use of internal API
    if (!this._schemas.has(type)) {
      // @ts-expect-error intentional use of internal API
      this._loadModelSchema(type);
    }

    // @ts-expect-error intentional use of internal API
    return this._schemas.get(type).relationships;
  };
}
function buildSchema(store) {
  return new ModelSchemaProvider(store);
}
function getModelFactory(store, type) {
  if (!store._modelFactoryCache) {
    store._modelFactoryCache = Object.create(null);
  }
  const cache = store._modelFactoryCache;
  let factory = cache[type];
  if (!factory) {
    const owner = getOwner(store);
    factory = owner.factoryFor(`model:${type}`);
    if (!factory) {
      //Support looking up mixins as base types for polymorphic relationships
      factory = modelForMixin(store, type);
    }
    if (!factory) {
      // we don't cache misses in case someone wants to register a missing model
      return null;
    }
    const klass = factory.class;
    if (klass.isModel) {
      const hasOwnModelNameSet = klass.modelName && Object.prototype.hasOwnProperty.call(klass, 'modelName');
      if (!hasOwnModelNameSet) {
        Object.defineProperty(klass, 'modelName', {
          value: type
        });
      }
    }
    cache[type] = factory;
  }
  return factory;
}
export { Model as M, RecordState as R, save as a, buildSchema as b, reload as c, destroyRecord as d, deleteRecord as e, changedAttributes as f, belongsTo as g, hasMany as h, createSnapshot as i, isElementDescriptor as j, getModelFactory as k, normalizeModelName as n, rollbackAttributes as r, serialize as s, unloadRecord as u };