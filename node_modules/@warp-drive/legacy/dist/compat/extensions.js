import { get, set } from '@ember/object';
import { compare } from '@ember/utils';
import Ember from 'ember';
import { macroCondition, getGlobalConfig } from '@embroider/macros';
const EmberObjectFeatures = {};
const EmberObjectMethods = ['addObserver', 'cacheFor', 'decrementProperty', 'get', 'getProperties', 'incrementProperty', 'notifyPropertyChange', 'removeObserver', 'set', 'setProperties', 'toggleProperty'];
EmberObjectMethods.forEach(method => {
  EmberObjectFeatures[method] = function delegatedMethod(...args) {
    return Ember[method](this, ...args);
  };
});
const EmberObjectArrayExtension = {
  kind: 'array',
  name: 'ember-object',
  features: EmberObjectFeatures
};
const EmberObjectExtension = {
  kind: 'object',
  name: 'ember-object',
  features: EmberObjectFeatures
};
const EmberArrayLikeFeatures = {
  addObject(obj) {
    const index = this.indexOf(obj);
    if (index === -1) {
      this.push(obj);
    }
    return this;
  },
  addObjects(objs) {
    objs.forEach(obj => {
      const index = this.indexOf(obj);
      if (index === -1) {
        this.push(obj);
      }
    });
    return this;
  },
  popObject() {
    return this.pop();
  },
  pushObject(obj) {
    this.push(obj);
    return obj;
  },
  pushObjects(objs) {
    this.push(...objs);
    return this;
  },
  shiftObject() {
    return this.shift();
  },
  unshiftObject(obj) {
    this.unshift(obj);
    return obj;
  },
  unshiftObjects(objs) {
    this.unshift(...objs);
    return this;
  },
  objectAt(index) {
    //For negative index values go back from the end of the array
    const arrIndex = Math.sign(index) === -1 ? this.length + index : index;
    return this[arrIndex];
  },
  objectsAt(indices) {
    // @ts-expect-error adding MutableArray method
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call
    return indices.map(index => this.objectAt(index));
  },
  removeAt(index) {
    this.splice(index, 1);
    return this;
  },
  insertAt(index, obj) {
    this.splice(index, 0, obj);
    return this;
  },
  removeObject(obj) {
    const index = this.indexOf(obj);
    if (index !== -1) {
      this.splice(index, 1);
    }
    return this;
  },
  removeObjects(objs) {
    objs.forEach(obj => {
      const index = this.indexOf(obj);
      if (index !== -1) {
        this.splice(index, 1);
      }
    });
    return this;
  },
  toArray() {
    return this.slice();
  },
  replace(idx, amt, objects) {
    if (objects) {
      this.splice(idx, amt, ...objects);
    } else {
      this.splice(idx, amt);
    }
  },
  clear() {
    this.splice(0, this.length);
    return this;
  },
  setObjects(objects) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error(`setObjects expects to receive an array as its argument`);
      }
    })(Array.isArray(objects)) : {};
    this.splice(0, this.length);
    this.push(...objects);
    return this;
  },
  reverseObjects() {
    this.reverse();
    return this;
  },
  compact() {
    return this.filter(v => v !== null && v !== undefined);
  },
  any(callback, target) {
    return this.some(callback, target);
  },
  isAny(prop, value) {
    const hasValue = arguments.length === 2;
    return this.some(v => hasValue ? v[prop] === value : v[prop] === true);
  },
  isEvery(prop, value) {
    const hasValue = arguments.length === 2;
    return this.every(v => hasValue ? v[prop] === value : v[prop] === true);
  },
  getEach(key) {
    return this.map(value => get(value, key));
  },
  mapBy(key) {
    return this.map(value => get(value, key));
  },
  findBy(key, value) {
    if (arguments.length === 2) {
      return this.find(val => {
        return get(val, key) === value;
      });
    } else {
      return this.find(val => Boolean(get(val, key)));
    }
  },
  filterBy(key, value) {
    if (arguments.length === 2) {
      return this.filter(record => {
        return get(record, key) === value;
      });
    }
    return this.filter(record => {
      return Boolean(get(record, key));
    });
  },
  sortBy(...sortKeys) {
    return this.slice().sort((a, b) => {
      for (let i = 0; i < sortKeys.length; i++) {
        const key = sortKeys[i];
        const propA = get(a, key);
        const propB = get(b, key);
        // return 1 or -1 else continue to the next sortKey
        const compareValue = compare(propA, propB);
        if (compareValue) {
          return compareValue;
        }
      }
      return 0;
    });
  },
  invoke(key, ...args) {
    return this.map(value => value[key](...args));
  },
  addArrayObserver() {},
  removeArrayObserver() {},
  arrayContentWillChange() {},
  arrayContentDidChange() {},
  reject(callback, target) {
    macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
      if (!test) {
        throw new Error('`reject` expects a function as first argument.');
      }
    })(typeof callback === 'function') : {};
    return this.filter((...args) => {
      return !callback.apply(target, args);
    });
  },
  rejectBy(key, value) {
    if (arguments.length === 2) {
      return this.filter(record => {
        return get(record, key) !== value;
      });
    }
    return this.filter(record => {
      return !get(record, key);
    });
  },
  setEach(key, value) {
    this.forEach(item => set(item, key, value));
  },
  uniq() {
    return Array.from(new Set(this));
  },
  uniqBy(key) {
    const seen = new Set();
    const result = [];
    this.forEach(item => {
      const value = get(item, key);
      if (seen.has(value)) {
        return;
      }
      seen.add(value);
      result.push(item);
    });
    return result;
  },
  without(value) {
    const newArr = this.slice();
    const index = this.indexOf(value);
    if (index !== -1) {
      newArr.splice(index, 1);
    }
    return newArr;
  },
  get firstObject() {
    return this.at(0);
  },
  get lastObject() {
    return this.at(-1);
  }
};
const EmberArrayLikeExtension = {
  kind: 'array',
  name: 'ember-array-like',
  features: EmberArrayLikeFeatures
};
export { EmberArrayLikeExtension, EmberObjectArrayExtension, EmberObjectExtension };